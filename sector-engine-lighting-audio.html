<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sector Engine - Dynamic Lighting & Audio</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0c; color: #33ff33; font-family: 'Share Tech Mono', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
    #header { background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%); border-bottom: 2px solid #33ff33; padding: 8px 16px; display: flex; justify-content: space-between; align-items: center; }
    #header h1 { font-family: 'Orbitron', sans-serif; font-size: 1rem; letter-spacing: 3px; }
    .tag { font-size: 0.5rem; color: #ff6633; margin-left: 8px; letter-spacing: 2px; background: rgba(255,102,51,0.15); padding: 2px 6px; border-radius: 3px; }
    #stats { display: flex; gap: 16px; font-size: 0.7rem; }
    .stat { display: flex; flex-direction: column; align-items: center; }
    .stat-label { color: #555; font-size: 0.55rem; letter-spacing: 1px; }
    .stat-value { color: #33ff33; }
    .stat-value.warn { color: #ffaa33; }
    .stat-value.bad { color: #ff5533; }
    #main { flex: 1; display: flex; padding: 8px; min-height: 0; gap: 8px; }
    #viewport { flex: 2; position: relative; border: 2px solid #1a1a1a; border-radius: 4px; overflow: hidden; background: #000; }
    #game-canvas { width: 100%; height: 100%; display: block; }
    #overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    #click-prompt { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); border: 1px solid #33ff33; padding: 14px 28px; text-align: center; cursor: pointer; z-index: 10; }
    #click-prompt:hover { background: rgba(51,255,51,0.1); }
    #click-prompt.hidden { display: none; }
    #click-prompt h2 { font-family: 'Orbitron', sans-serif; font-size: 0.85rem; letter-spacing: 2px; }
    #click-prompt p { font-size: 0.65rem; color: #888; margin-top: 5px; }
    #sidebar { width: 280px; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; }
    .panel { background: #0f0f12; border: 1px solid #222; border-radius: 4px; padding: 8px; }
    .panel-title { font-family: 'Orbitron', sans-serif; font-size: 0.6rem; letter-spacing: 2px; color: #444; margin-bottom: 6px; }
    #minimap-panel { flex: 0 0 auto; height: 160px; display: flex; flex-direction: column; }
    #minimap-canvas { flex: 1; width: 100%; border: 1px solid #1a1a1a; background: #030305; }
    .perf-row { display: flex; justify-content: space-between; font-size: 0.65rem; color: #666; margin-bottom: 3px; }
    .perf-value { color: #33ff33; min-width: 55px; text-align: right; }
    .slider-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.6rem; color: #888; margin-bottom: 4px; }
    .slider-row input[type="range"] { width: 80px; height: 4px; -webkit-appearance: none; background: #1a1a1a; border-radius: 2px; }
    .slider-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; background: #33ff33; border-radius: 50%; cursor: pointer; }
    .slider-value { color: #33ff33; min-width: 35px; text-align: right; }
    .control-row { display: flex; justify-content: space-between; font-size: 0.6rem; color: #888; margin-bottom: 3px; }
    .key { background: #1a1a1f; border: 1px solid #2a2a2a; padding: 1px 4px; border-radius: 2px; color: #33ff33; font-size: 0.55rem; }
    .light-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
    #messages { position: absolute; bottom: 10px; left: 10px; max-width: 300px; z-index: 5; }
    .message { background: rgba(0,0,0,0.85); border-left: 2px solid #33ff33; padding: 4px 8px; margin-bottom: 2px; font-size: 0.7rem; animation: msgIn 0.2s ease-out, msgOut 0.3s ease-in 3s forwards; }
    @keyframes msgIn { from { opacity: 0; transform: translateX(-10px); } }
    @keyframes msgOut { to { opacity: 0; } }
    #audio-status { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; font-size: 0.6rem; }
  </style>
</head>
<body>
  <div id="header">
    <h1>SECTOR ENGINE <span class="tag">LIGHTING + AUDIO</span></h1>
    <div id="stats">
      <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="stat-fps">--</span></div>
      <div class="stat"><span class="stat-label">FRAME</span><span class="stat-value" id="stat-frame">--</span></div>
      <div class="stat"><span class="stat-label">LIGHTS</span><span class="stat-value" id="stat-lights">--</span></div>
      <div class="stat"><span class="stat-label">SECTOR</span><span class="stat-value" id="stat-sector">--</span></div>
    </div>
  </div>
  <div id="main">
    <div id="viewport">
      <canvas id="game-canvas"></canvas>
      <canvas id="overlay-canvas"></canvas>
      <div id="click-prompt"><h2>CLICK TO ENGAGE</h2><p>üîä Enable Audio | Dynamic Lighting</p></div>
      <div id="messages"></div>
      <div id="audio-status">üîá Click to enable audio</div>
    </div>
    <div id="sidebar">
      <div class="panel" id="minimap-panel"><div class="panel-title">TACTICAL MAP</div><canvas id="minimap-canvas"></canvas></div>
      <div class="panel">
        <div class="panel-title">‚ö° PERFORMANCE</div>
        <div class="perf-row"><span>Frame Total</span><span class="perf-value" id="perf-frame">--</span></div>
        <div class="perf-row"><span>‚îú Raycast</span><span class="perf-value" id="perf-raycast">--</span></div>
        <div class="perf-row"><span>‚îú GPU</span><span class="perf-value" id="perf-gpu">--</span></div>
        <div class="perf-row"><span>‚îú Lighting</span><span class="perf-value" id="perf-lighting">--</span></div>
        <div class="perf-row"><span>‚îî Audio</span><span class="perf-value" id="perf-audio">--</span></div>
      </div>
      <div class="panel">
        <div class="panel-title">üí° LIGHTING</div>
        <div id="light-list"></div>
        <div class="slider-row"><span>Ambient</span><input type="range" id="tune-ambient" min="0" max="50" value="15"><span class="slider-value" id="tune-ambient-val">15%</span></div>
        <div class="slider-row"><span>Flicker</span><input type="range" id="tune-flicker" min="0" max="100" value="50"><span class="slider-value" id="tune-flicker-val">50%</span></div>
      </div>
      <div class="panel">
        <div class="panel-title">üîä AUDIO</div>
        <div class="slider-row"><span>Master</span><input type="range" id="tune-master" min="0" max="100" value="70"><span class="slider-value" id="tune-master-val">70%</span></div>
        <div class="slider-row"><span>Ambience</span><input type="range" id="tune-ambience" min="0" max="100" value="50"><span class="slider-value" id="tune-ambience-val">50%</span></div>
        <div class="slider-row"><span>Footsteps</span><input type="range" id="tune-footsteps" min="0" max="100" value="60"><span class="slider-value" id="tune-footsteps-val">60%</span></div>
      </div>
      <div class="panel">
        <div class="panel-title">üéõÔ∏è RENDER</div>
        <div class="slider-row"><span>Ray Count</span><input type="range" id="tune-rays" min="200" max="640" value="400"><span class="slider-value" id="tune-rays-val">400</span></div>
        <div class="slider-row"><span>View Dist</span><input type="range" id="tune-viewdist" min="10" max="24" value="16"><span class="slider-value" id="tune-viewdist-val">16</span></div>
      </div>
      <div class="panel">
        <div class="panel-title">CONTROLS</div>
        <div class="control-row"><span>Move</span><span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></span></div>
        <div class="control-row"><span>Look</span><span>Mouse</span></div>
        <div class="control-row"><span>Run</span><span><span class="key">Shift</span></span></div>
        <div class="control-row"><span>Flashlight</span><span><span class="key">F</span></span></div>
      </div>
    </div>
  </div>
<script>
// Profiler
class Profiler {
  constructor() { this.timings = {}; this.history = {}; this.max = 100; }
  start(n) { this.timings[n] = performance.now(); }
  end(n) { if (!this.timings[n]) return 0; const d = performance.now() - this.timings[n]; if (!this.history[n]) this.history[n] = []; this.history[n].push(d); if (this.history[n].length > this.max) this.history[n].shift(); return d; }
  getAvg(n) { const h = this.history[n]; return h?.length ? h.reduce((a,b)=>a+b,0)/h.length : 0; }
}
const profiler = new Profiler();

// Dynamic Lighting System
class LightingSystem {
  constructor() { this.lights = []; this.ambientLevel = 0.15; this.flickerSpeed = 1.0; this.maxLights = 16; this.time = 0; }
  
  addLight(cfg) {
    if (this.lights.length >= this.maxLights) return null;
    const light = {
      id: this.lights.length, x: cfg.x || 0, y: cfg.y || 0, radius: cfg.radius || 5,
      intensity: cfg.intensity || 1.0, color: cfg.color || [1.0, 0.9, 0.7],
      flicker: cfg.flicker || 0, flickerOffset: Math.random() * 100,
      pulse: cfg.pulse || 0, pulseMin: cfg.pulseMin || 0.5,
      active: true, type: cfg.type || 'point', currentIntensity: cfg.intensity || 1.0
    };
    this.lights.push(light);
    return light;
  }
  
  update(dt, px, py, angle) {
    this.time += dt;
    for (const light of this.lights) {
      if (light.type === 'player') { light.x = px + Math.cos(angle) * 0.3; light.y = py + Math.sin(angle) * 0.3; }
      light.currentIntensity = light.intensity;
      if (light.flicker > 0) {
        const fn = Math.sin(this.time * 15 * this.flickerSpeed + light.flickerOffset) * 0.3 +
                   Math.sin(this.time * 23 * this.flickerSpeed + light.flickerOffset * 2) * 0.2 +
                   Math.sin(this.time * 7 * this.flickerSpeed + light.flickerOffset * 0.5) * 0.5;
        light.currentIntensity *= 1 + (fn * light.flicker * 0.3);
        if (Math.random() < 0.002 * light.flicker) light.currentIntensity *= 0.3;
      }
      if (light.pulse > 0) {
        const pv = (Math.sin(this.time * light.pulse) + 1) * 0.5;
        light.currentIntensity *= light.pulseMin + (1 - light.pulseMin) * pv;
      }
      light.currentIntensity = Math.max(0, Math.min(2, light.currentIntensity));
    }
  }
  
  getLightData() {
    const pos = new Float32Array(this.maxLights * 2);
    const col = new Float32Array(this.maxLights * 3);
    const par = new Float32Array(this.maxLights * 2);
    let count = 0;
    for (const l of this.lights) {
      if (!l.active || count >= this.maxLights) continue;
      pos[count*2] = l.x; pos[count*2+1] = l.y;
      col[count*3] = l.color[0]; col[count*3+1] = l.color[1]; col[count*3+2] = l.color[2];
      par[count*2] = l.radius; par[count*2+1] = l.currentIntensity;
      count++;
    }
    return { positions: pos, colors: col, params: par, count };
  }
  
  setAmbient(v) { this.ambientLevel = v; }
  setFlickerSpeed(v) { this.flickerSpeed = v; }
}

// Audio System
class AudioSystem {
  constructor() {
    this.ctx = null; this.masterGain = null; this.initialized = false;
    this.sounds = new Map(); this.ambientSources = [];
    this.masterVolume = 0.7; this.ambienceVolume = 0.5; this.footstepVolume = 0.6;
    this.lastFootstep = 0;
  }
  
  async init() {
    if (this.initialized) return true;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.gain.value = this.masterVolume;
      this.masterGain.connect(this.ctx.destination);
      this._createSounds();
      this.initialized = true;
      document.getElementById('audio-status').textContent = 'üîä Audio enabled';
      document.getElementById('audio-status').style.color = '#33ff33';
      this._startAmbient();
      return true;
    } catch (e) { console.error('Audio init failed:', e); return false; }
  }
  
  _createSounds() {
    this.sounds.set('footstep1', this._makeFootstep(0.8, 100));
    this.sounds.set('footstep2', this._makeFootstep(1.0, 120));
    this.sounds.set('footstep3', this._makeFootstep(0.9, 90));
    this.sounds.set('hum', this._makeHum());
    this.sounds.set('buzz', this._makeBuzz());
  }
  
  _makeFootstep(pitch, len) {
    const sr = this.ctx.sampleRate, dur = len/1000;
    const buf = this.ctx.createBuffer(1, sr * dur, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) {
      const t = i / sr;
      const env = Math.exp(-t * 30);
      const noise = (Math.random() * 2 - 1);
      const thump = Math.sin(t * 150 * pitch) * Math.exp(-t * 50);
      d[i] = (noise * 0.3 + thump * 0.7) * env;
    }
    return buf;
  }
  
  _makeHum() {
    const sr = this.ctx.sampleRate, buf = this.ctx.createBuffer(1, sr * 4, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) {
      const t = i / sr;
      const hum = Math.sin(t * 60 * Math.PI * 2) * 0.3 + Math.sin(t * 120 * Math.PI * 2) * 0.15;
      d[i] = hum * (0.8 + Math.sin(t * 0.5) * 0.2) * 0.3;
    }
    return buf;
  }
  
  _makeBuzz() {
    const sr = this.ctx.sampleRate, buf = this.ctx.createBuffer(1, sr * 2, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) {
      const t = i / sr;
      const buzz = Math.sin(t * 60 * Math.PI * 2) * (0.5 + 0.5 * Math.sin(t * 120 * Math.PI * 2));
      const crackle = Math.random() > 0.995 ? (Math.random() - 0.5) * 2 : 0;
      d[i] = (buzz * 0.2 + crackle * 0.5) * 0.4;
    }
    return buf;
  }
  
  _startAmbient() {
    const hum = this.ctx.createBufferSource();
    hum.buffer = this.sounds.get('hum'); hum.loop = true;
    const humG = this.ctx.createGain(); humG.gain.value = this.ambienceVolume * 0.3;
    hum.connect(humG); humG.connect(this.masterGain); hum.start();
    this.ambientSources.push({ source: hum, gain: humG, type: 'hum' });
    
    const buzz = this.ctx.createBufferSource();
    buzz.buffer = this.sounds.get('buzz'); buzz.loop = true;
    const buzzG = this.ctx.createGain(); buzzG.gain.value = this.ambienceVolume * 0.15;
    buzz.connect(buzzG); buzzG.connect(this.masterGain); buzz.start();
    this.ambientSources.push({ source: buzz, gain: buzzG, type: 'buzz' });
  }
  
  playFootstep(isRunning) {
    if (!this.initialized) return;
    const now = performance.now();
    if (now - this.lastFootstep < (isRunning ? 250 : 400)) return;
    this.lastFootstep = now;
    
    const sounds = ['footstep1', 'footstep2', 'footstep3'];
    const buf = this.sounds.get(sounds[Math.floor(Math.random() * 3)]);
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    src.playbackRate.value = 0.9 + Math.random() * 0.2;
    const g = this.ctx.createGain();
    g.gain.value = this.footstepVolume * (0.8 + Math.random() * 0.4) * this.masterVolume;
    src.connect(g); g.connect(this.masterGain); src.start();
  }
  
  update(dt, px, py, angle, isMoving, isRunning) {
    if (isMoving) this.playFootstep(isRunning);
  }
  
  setMasterVolume(v) { this.masterVolume = v; if (this.masterGain) this.masterGain.gain.value = v; }
  setAmbienceVolume(v) {
    this.ambienceVolume = v;
    for (const s of this.ambientSources) {
      if (s.type === 'hum') s.gain.gain.value = v * 0.3;
      if (s.type === 'buzz') s.gain.gain.value = v * 0.15;
    }
  }
  setFootstepVolume(v) { this.footstepVolume = v; }
}

// Texture Generator
class TextureGenerator {
  constructor(size = 64) { this.size = size; }
  _noise(x, y, seed = 0) { const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453; return n - Math.floor(n); }
  _fbm(x, y, oct = 4, seed = 0) { let v = 0, a = 0.5, f = 1; for (let i = 0; i < oct; i++) { v += a * this._noise(x*f, y*f, seed+i*100); a *= 0.5; f *= 2; } return v; }
  generate(fn, ...args) {
    const s = this.size, data = new Uint8Array(s * s * 4);
    for (let y = 0; y < s; y++) for (let x = 0; x < s; x++) {
      const [r, g, b] = fn.call(this, x, y, s, ...args);
      const i = (y * s + x) * 4; data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = 255;
    }
    return data;
  }
  metalPanels(x, y, s, base, seed) {
    const grid = (x % 16 < 2) || (y % 16 < 2);
    const rivet = (x % 16 >= 6 && x % 16 <= 9) && (y % 16 <= 2 || y % 16 >= 13);
    const n = this._fbm(x/6, y/6, 3, seed) * 40 - 20;
    let r = base[0]+n, g = base[1]+n, b = base[2]+n;
    if (grid) { r -= 50; g -= 50; b -= 45; } if (rivet) { r += 55; g += 55; b += 65; }
    return [Math.max(0,Math.min(255,r)), Math.max(0,Math.min(255,g)), Math.max(0,Math.min(255,b))];
  }
  techWall(x, y, s, base, seed) {
    let r = base[0]*0.5, g = base[1]*0.5, b = base[2]*0.5;
    if (y % 10 < 2 || x % 14 < 2) { r += 35; g += 40; b += 55; }
    if ((x % 14 < 4) && (y % 10 < 4)) { g += 70; b += 95; }
    const n = this._noise(x, y, seed) * 12 - 6;
    return [Math.max(0,Math.min(255,r+n)), Math.max(0,Math.min(255,g+n)), Math.max(0,Math.min(255,b+n))];
  }
  concrete(x, y, s, base, seed) {
    const t = this._fbm(x/4, y/4, 4, seed) * 70 - 35 + this._fbm(x/12, y/12, 2, seed+100) * 35 - 17;
    return [Math.max(0,Math.min(255,base[0]+t)), Math.max(0,Math.min(255,base[1]+t)), Math.max(0,Math.min(255,base[2]+t))];
  }
  grating(x, y, s, base, seed) {
    const cx = x % 8, cy = y % 8;
    if (Math.abs(cx - 3.5) + Math.abs(cy - 3.5) < 3) return [12, 15, 20];
    const hl = cx < 3.5 || cy < 3.5, n = this._noise(x, y, seed) * 18 - 9;
    return [Math.max(0,Math.min(255,(hl?base[0]+45:base[0])+n)), Math.max(0,Math.min(255,(hl?base[1]+45:base[1])+n)), Math.max(0,Math.min(255,(hl?base[2]+55:base[2])+n))];
  }
  brick(x, y, s, base, seed) {
    const row = Math.floor(y / 8), ox = (row % 2) * 8, bx = (x + ox) % 16, by = y % 8;
    if (bx < 2 || by < 2) { const n = this._noise(x,y,seed)*18; return [55+n, 52+n, 48+n]; }
    const bv = (this._noise(Math.floor((x+ox)/16) + row*1000, 0, seed) - 0.5) * 60;
    return [Math.max(0,Math.min(255,base[0]+bv)), Math.max(0,Math.min(255,base[1]+bv*0.8)), Math.max(0,Math.min(255,base[2]+bv*0.6))];
  }
  crate(x, y, s, base, seed) {
    const grain = Math.sin(y*0.6 + this._noise(x/15, y/4, seed)*8) * 22;
    const border = x < 6 || x >= s-6 || y < 6 || y >= s-6;
    let r = base[0]+grain, g = base[1]+grain*0.9, b = base[2]+grain*0.7;
    if (border) { r += 40; g += 35; b += 25; }
    return [Math.max(0,Math.min(255,r)), Math.max(0,Math.min(255,g)), Math.max(0,Math.min(255,b))];
  }
  pillar(x, y, s, base, seed) {
    const t = this._noise(x/4, 0, seed) * 28 - 14 + this._fbm(x/8, y/8, 3, seed+100) * 22 - 11;
    return [Math.max(0,Math.min(255,base[0]+t)), Math.max(0,Math.min(255,base[1]+t)), Math.max(0,Math.min(255,base[2]+t))];
  }
  tileFloor(x, y, s, base, seed) {
    if ((x % 16 < 1) || (y % 16 < 1)) { const n = this._noise(x,y,seed)*20-10; return [40+n, 42+n, 45+n]; }
    const tv = this._noise(Math.floor(x/16), Math.floor(y/16), seed+100) * 30 - 15;
    const n = this._noise(x, y, seed) * 20 - 10;
    return [Math.max(0,Math.min(255,base[0]+tv+n)), Math.max(0,Math.min(255,base[1]+tv+n)), Math.max(0,Math.min(255,base[2]+tv+n))];
  }
  metalFloor(x, y, s, base, seed) {
    const diamond = ((x % 8) + (y % 8)) % 8 < 2;
    const n = this._noise(x, y, seed) * 15 - 7;
    let r = base[0], g = base[1], b = base[2];
    if (diamond) { r += 25; g += 25; b += 30; }
    return [Math.max(0,Math.min(255,r+n)), Math.max(0,Math.min(255,g+n)), Math.max(0,Math.min(255,b+n))];
  }
  dirtFloor(x, y, s, base, seed) {
    const n1 = this._fbm(x/3, y/3, 4, seed) * 50 - 25;
    return [Math.max(0,Math.min(255,base[0]+n1)), Math.max(0,Math.min(255,base[1]+n1*0.9)), Math.max(0,Math.min(255,base[2]+n1*0.7))];
  }
  ceilingPanels(x, y, s, base, seed) {
    const frame = (x % 32 < 2) || (y % 32 < 2) || (x % 32 > 29) || (y % 32 > 29);
    const n = this._noise(x, y, seed) * 12 - 6;
    if (frame) return [Math.max(0,base[0]-30+n), Math.max(0,base[1]-30+n), Math.max(0,base[2]-25+n)];
    return [Math.max(0,Math.min(255,base[0]+n)), Math.max(0,Math.min(255,base[1]+n)), Math.max(0,Math.min(255,base[2]+n))];
  }
  techCeiling(x, y, s, base, seed) {
    const beam = (x % 24 < 3) || (y % 24 < 3);
    const light = (x % 24 > 8 && x % 24 < 16) && (y % 24 > 8 && y % 24 < 16);
    let r = base[0], g = base[1], b = base[2];
    if (beam) { r -= 20; g -= 20; b -= 15; } if (light) { r += 50; g += 60; b += 80; }
    return [Math.max(0,Math.min(255,r)), Math.max(0,Math.min(255,g)), Math.max(0,Math.min(255,b))];
  }
  skyCeiling(x, y, s, base, seed) {
    if (this._noise(x*5, y*5, seed) > 0.97) { const b = this._noise(x, y, seed+100) * 155 + 100; return [b, b, b+20]; }
    const n = this._noise(x, y, seed+50) * 8 - 4;
    return [Math.max(0,base[0]+n), Math.max(0,base[1]+n), Math.max(0,base[2]+n)];
  }
}

// WebGL2 Renderer with Lighting
class WebGL2Renderer {
  constructor(cfg = {}) {
    this.rayCount = cfg.rayCount || 400; this.fov = cfg.fov || Math.PI * 0.6; this.maxDepth = cfg.maxDepth || 16;
    this.texGen = new TextureGenerator(64); this.drawCalls = 0;
  }
  
  init(canvas) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl2', { antialias: false, alpha: false });
    if (!this.gl) return false;
    this._initWallProgram(); this._initFloorProgram(); this._initBuffers(); this._initTextures(); this._initWorldTexture();
    this.resize(); window.addEventListener('resize', () => this.resize());
    return true;
  }
  
  resize() { const c = this.canvas.parentElement; this.width = c.clientWidth; this.height = c.clientHeight; this.canvas.width = this.width; this.canvas.height = this.height; this.gl.viewport(0, 0, this.width, this.height); }
  _compile(type, src) { const gl = this.gl, s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s)); return s; }
  _program(vs, fs) { const gl = this.gl, p = gl.createProgram(); gl.attachShader(p, this._compile(gl.VERTEX_SHADER, vs)); gl.attachShader(p, this._compile(gl.FRAGMENT_SHADER, fs)); gl.linkProgram(p); return p; }
  
  _initWallProgram() {
    const vs = `#version 300 es
      in vec2 aPos; in vec2 aUV; in float aTex; in float aFog; in float aSide; in vec2 aWorldPos;
      out vec2 vUV; flat out int vTex; out float vFog; out float vSide; out vec2 vWorldPos;
      void main() { gl_Position = vec4(aPos, 0.0, 1.0); vUV = aUV; vTex = int(aTex); vFog = aFog; vSide = aSide; vWorldPos = aWorldPos; }`;
    const fs = `#version 300 es
      precision highp float; precision highp sampler2DArray;
      in vec2 vUV; flat in int vTex; in float vFog; in float vSide; in vec2 vWorldPos;
      uniform sampler2DArray uTex; uniform float uAmbient; uniform int uLightCount;
      uniform vec2 uLightPos[16]; uniform vec3 uLightColor[16]; uniform vec2 uLightParams[16];
      out vec4 fragColor;
      void main() {
        vec3 c = texture(uTex, vec3(fract(vUV), float(vTex))).rgb;
        c *= mix(1.0, 0.75, vSide);
        float totalLight = uAmbient; vec3 tint = vec3(0.0);
        for (int i = 0; i < 16; i++) { if (i >= uLightCount) break;
          float d = distance(vWorldPos, uLightPos[i]);
          float a = max(0.0, 1.0 - d / uLightParams[i].x); a = a * a * uLightParams[i].y;
          totalLight += a; tint += uLightColor[i] * a;
        }
        c *= min(totalLight, 2.0);
        if (length(tint) > 0.01) c *= normalize(vec3(1.0) + tint * 0.5);
        c = mix(c, vec3(0.07, 0.085, 0.11), vFog);
        fragColor = vec4(c, 1.0);
      }`;
    this.wallProg = this._program(vs, fs);
    const gl = this.gl;
    this.wallAttr = { pos: gl.getAttribLocation(this.wallProg, 'aPos'), uv: gl.getAttribLocation(this.wallProg, 'aUV'), tex: gl.getAttribLocation(this.wallProg, 'aTex'), fog: gl.getAttribLocation(this.wallProg, 'aFog'), side: gl.getAttribLocation(this.wallProg, 'aSide'), worldPos: gl.getAttribLocation(this.wallProg, 'aWorldPos') };
    this.wallUni = { tex: gl.getUniformLocation(this.wallProg, 'uTex'), ambient: gl.getUniformLocation(this.wallProg, 'uAmbient'), lightCount: gl.getUniformLocation(this.wallProg, 'uLightCount'), lightPos: gl.getUniformLocation(this.wallProg, 'uLightPos'), lightColor: gl.getUniformLocation(this.wallProg, 'uLightColor'), lightParams: gl.getUniformLocation(this.wallProg, 'uLightParams') };
  }
  
  _initFloorProgram() {
    const vs = `#version 300 es
      in vec2 aPos; out vec2 vScreenPos;
      void main() { gl_Position = vec4(aPos, 0.0, 1.0); vScreenPos = aPos; }`;
    const fs = `#version 300 es
      precision highp float; precision highp sampler2DArray; precision highp sampler2D;
      in vec2 vScreenPos;
      uniform sampler2DArray uTex; uniform sampler2D uWallDist; uniform sampler2D uWorldMap;
      uniform vec2 uPlayerPos; uniform float uPlayerAngle; uniform float uFov; uniform float uMaxDist; uniform int uRayCount;
      uniform float uAmbient; uniform int uLightCount; uniform vec2 uLightPos[16]; uniform vec3 uLightColor[16]; uniform vec2 uLightParams[16];
      out vec4 fragColor;
      int getFloorTex(int t) { if (t==1) return 10; if (t==2) return 10; if (t==3) return 11; if (t==4) return 9; if (t==5) return 15; if (t==6) return 12; return 13; }
      int getCeilTex(int t) { if (t==1) return 14; if (t==2) return 14; if (t==3) return 15; if (t==4) return 14; if (t==5) return 15; if (t==6) return 16; return 17; }
      void main() {
        vec2 uv = vScreenPos * 0.5 + 0.5;
        bool isFloor = uv.y < 0.5;
        float p = isFloor ? (0.5 - uv.y) : (uv.y - 0.5);
        if (p < 0.001) { fragColor = vec4(0.07, 0.085, 0.11, 1.0); return; }
        float rowDist = 0.5 / p;
        if (rowDist > uMaxDist) { fragColor = vec4(0.07, 0.085, 0.11, 1.0); return; }
        float wallDist = texture(uWallDist, vec2(uv.x * float(uRayCount) / 1024.0, 0.5)).r;
        if (rowDist > wallDist) { discard; }
        float rayAngle = uPlayerAngle + (uv.x - 0.5) * uFov;
        float worldX = uPlayerPos.x + rowDist * cos(rayAngle);
        float worldY = uPlayerPos.y + rowDist * sin(rayAngle);
        vec2 mapUV = vec2(worldX / 24.0, worldY / 24.0);
        if (mapUV.x < 0.0 || mapUV.x > 1.0 || mapUV.y < 0.0 || mapUV.y > 1.0) { fragColor = vec4(0.07, 0.085, 0.11, 1.0); return; }
        int st = int(texture(uWorldMap, mapUV).r * 255.0 + 0.5);
        if (st == 0 || st >= 7) { fragColor = vec4(0.07, 0.085, 0.11, 1.0); return; }
        vec3 c = texture(uTex, vec3(fract(vec2(worldX, worldY)), float(isFloor ? getFloorTex(st) : getCeilTex(st)))).rgb;
        float totalLight = uAmbient; vec3 tint = vec3(0.0); vec2 wp = vec2(worldX, worldY);
        for (int i = 0; i < 16; i++) { if (i >= uLightCount) break;
          float d = distance(wp, uLightPos[i]);
          float a = max(0.0, 1.0 - d / uLightParams[i].x); a = a * a * uLightParams[i].y;
          totalLight += a; tint += uLightColor[i] * a;
        }
        c *= min(totalLight, 2.0);
        if (length(tint) > 0.01) c *= normalize(vec3(1.0) + tint * 0.5);
        c *= max(0.5, 1.0 - rowDist * 0.03);
        c = mix(c, vec3(0.07, 0.085, 0.11), clamp((rowDist - 6.0) * 0.08, 0.0, 1.0));
        fragColor = vec4(c, 1.0);
      }`;
    this.floorProg = this._program(vs, fs);
    const gl = this.gl;
    this.floorAttr = { pos: gl.getAttribLocation(this.floorProg, 'aPos') };
    this.floorUni = { tex: gl.getUniformLocation(this.floorProg, 'uTex'), wallDist: gl.getUniformLocation(this.floorProg, 'uWallDist'), worldMap: gl.getUniformLocation(this.floorProg, 'uWorldMap'), playerPos: gl.getUniformLocation(this.floorProg, 'uPlayerPos'), playerAngle: gl.getUniformLocation(this.floorProg, 'uPlayerAngle'), fov: gl.getUniformLocation(this.floorProg, 'uFov'), maxDist: gl.getUniformLocation(this.floorProg, 'uMaxDist'), rayCount: gl.getUniformLocation(this.floorProg, 'uRayCount'), ambient: gl.getUniformLocation(this.floorProg, 'uAmbient'), lightCount: gl.getUniformLocation(this.floorProg, 'uLightCount'), lightPos: gl.getUniformLocation(this.floorProg, 'uLightPos'), lightColor: gl.getUniformLocation(this.floorProg, 'uLightColor'), lightParams: gl.getUniformLocation(this.floorProg, 'uLightParams') };
  }
  
  _initBuffers() {
    const gl = this.gl;
    this.wallVAO = gl.createVertexArray(); gl.bindVertexArray(this.wallVAO);
    this.wallBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this.wallBuf);
    const stride = 9 * 4;
    gl.enableVertexAttribArray(this.wallAttr.pos); gl.vertexAttribPointer(this.wallAttr.pos, 2, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(this.wallAttr.uv); gl.vertexAttribPointer(this.wallAttr.uv, 2, gl.FLOAT, false, stride, 8);
    gl.enableVertexAttribArray(this.wallAttr.tex); gl.vertexAttribPointer(this.wallAttr.tex, 1, gl.FLOAT, false, stride, 16);
    gl.enableVertexAttribArray(this.wallAttr.fog); gl.vertexAttribPointer(this.wallAttr.fog, 1, gl.FLOAT, false, stride, 20);
    gl.enableVertexAttribArray(this.wallAttr.side); gl.vertexAttribPointer(this.wallAttr.side, 1, gl.FLOAT, false, stride, 24);
    gl.enableVertexAttribArray(this.wallAttr.worldPos); gl.vertexAttribPointer(this.wallAttr.worldPos, 2, gl.FLOAT, false, stride, 28);
    
    this.floorVAO = gl.createVertexArray(); gl.bindVertexArray(this.floorVAO);
    this.floorBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this.floorBuf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(this.floorAttr.pos); gl.vertexAttribPointer(this.floorAttr.pos, 2, gl.FLOAT, false, 0, 0);
    gl.bindVertexArray(null);
    this.wallData = new Float32Array(800 * 6 * 9);
    this.wallDistData = new Float32Array(1024);
  }
  
  _initTextures() {
    const gl = this.gl, tg = this.texGen, s = 64;
    const textures = [
      tg.generate(tg.metalPanels, [120,125,135], 42), tg.generate(tg.metalPanels, [150,135,95], 43),
      tg.generate(tg.techWall, [70,85,110], 44), tg.generate(tg.concrete, [100,100,105], 45),
      tg.generate(tg.concrete, [85,110,90], 46), tg.generate(tg.brick, [145,95,75], 47),
      tg.generate(tg.grating, [110,115,125], 48), tg.generate(tg.crate, [160,130,85], 49),
      tg.generate(tg.pillar, [150,148,145], 50),
      tg.generate(tg.tileFloor, [70,72,78], 60), tg.generate(tg.metalFloor, [85,88,95], 61),
      tg.generate(tg.grating, [90,95,105], 62), tg.generate(tg.dirtFloor, [110,95,70], 63),
      tg.generate(tg.concrete, [75,78,82], 64),
      tg.generate(tg.ceilingPanels, [55,58,65], 70), tg.generate(tg.techCeiling, [50,55,65], 71),
      tg.generate(tg.skyCeiling, [15,18,28], 72), tg.generate(tg.concrete, [60,62,68], 73),
    ];
    this.texAtlas = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texAtlas);
    gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, s, s, textures.length, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    for (let i = 0; i < textures.length; i++) gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, s, s, 1, gl.RGBA, gl.UNSIGNED_BYTE, textures[i]);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
    this.wallDistTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, this.wallDistTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, 1024, 1, 0, gl.RED, gl.FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    this.wallTexMap = { 'HANGAR': 0, 'PLATFORM': 1, 'TERMINAL BAY': 2, 'VOID': 3, 'OPS CENTER': 4, 'EXTERIOR': 5, 'CORRIDOR': 6, 'CRATE': 7, 'PILLAR': 8 };
  }
  
  _initWorldTexture() {
    const gl = this.gl;
    this.worldMapTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, this.worldMapTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, 24, 24, 0, gl.RED, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }
  
  updateWorldMap(world) {
    const gl = this.gl, data = new Uint8Array(24 * 24);
    const tm = { 'void': 0, 'hangar': 1, 'hangar_platform': 2, 'corridor': 3, 'zigzag': 4, 'computer': 5, 'outdoor': 6, 'pillar': 7, 'crate': 8 };
    for (let y = 0; y < 24; y++) for (let x = 0; x < 24; x++) data[y * 24 + x] = tm[world.grid[y][x]] || 0;
    gl.bindTexture(gl.TEXTURE_2D, this.worldMapTex);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 24, 24, gl.RED, gl.UNSIGNED_BYTE, data);
  }
  
  setRayCount(n) { this.rayCount = n; }
  setViewDist(d) { this.maxDepth = d; }
  
  render(world, vis, px, py, angle, lighting) {
    profiler.start('raycast');
    const gl = this.gl; gl.clearColor(0.04, 0.05, 0.07, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);
    const ld = lighting.getLightData();
    const colW = 2.0 / this.rayCount;
    let wv = 0; const d = this.wallData;
    for (let i = 0; i < this.rayCount; i++) {
      const ra = angle + ((i / this.rayCount) - 0.5) * this.fov;
      const hit = this._castRay(world, vis, px, py, angle, ra);
      this.wallDistData[i] = hit ? hit.dist : this.maxDepth;
      if (hit) {
        const x0 = -1 + i * colW, x1 = x0 + colW;
        const vs = [[x0, hit.top, hit.u, 0], [x1, hit.top, hit.u, 0], [x0, hit.bottom, hit.u, 1], [x1, hit.top, hit.u, 0], [x1, hit.bottom, hit.u, 1], [x0, hit.bottom, hit.u, 1]];
        for (let v = 0; v < 6; v++) {
          const idx = wv * 9;
          d[idx] = vs[v][0]; d[idx+1] = vs[v][1]; d[idx+2] = vs[v][2]; d[idx+3] = vs[v][3];
          d[idx+4] = hit.tex; d[idx+5] = hit.fog; d[idx+6] = hit.side; d[idx+7] = hit.worldX; d[idx+8] = hit.worldY;
          wv++;
        }
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, this.wallDistTex);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.rayCount, 1, gl.RED, gl.FLOAT, this.wallDistData.subarray(0, this.rayCount));
    profiler.end('raycast');
    profiler.start('gpu');
    this.drawCalls = 0;
    // Floors
    gl.useProgram(this.floorProg); gl.bindVertexArray(this.floorVAO);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texAtlas); gl.uniform1i(this.floorUni.tex, 0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, this.wallDistTex); gl.uniform1i(this.floorUni.wallDist, 1);
    gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, this.worldMapTex); gl.uniform1i(this.floorUni.worldMap, 2);
    gl.uniform2f(this.floorUni.playerPos, px, py); gl.uniform1f(this.floorUni.playerAngle, angle);
    gl.uniform1f(this.floorUni.fov, this.fov); gl.uniform1f(this.floorUni.maxDist, this.maxDepth); gl.uniform1i(this.floorUni.rayCount, this.rayCount);
    gl.uniform1f(this.floorUni.ambient, lighting.ambientLevel); gl.uniform1i(this.floorUni.lightCount, ld.count);
    gl.uniform2fv(this.floorUni.lightPos, ld.positions); gl.uniform3fv(this.floorUni.lightColor, ld.colors); gl.uniform2fv(this.floorUni.lightParams, ld.params);
    gl.drawArrays(gl.TRIANGLES, 0, 6); this.drawCalls++;
    // Walls
    if (wv > 0) {
      gl.useProgram(this.wallProg); gl.bindVertexArray(this.wallVAO);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.wallBuf); gl.bufferData(gl.ARRAY_BUFFER, d.subarray(0, wv * 9), gl.DYNAMIC_DRAW);
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texAtlas); gl.uniform1i(this.wallUni.tex, 0);
      gl.uniform1f(this.wallUni.ambient, lighting.ambientLevel); gl.uniform1i(this.wallUni.lightCount, ld.count);
      gl.uniform2fv(this.wallUni.lightPos, ld.positions); gl.uniform3fv(this.wallUni.lightColor, ld.colors); gl.uniform2fv(this.wallUni.lightParams, ld.params);
      gl.drawArrays(gl.TRIANGLES, 0, wv); this.drawCalls++;
    }
    profiler.end('gpu');
  }
  
  _castRay(world, vis, px, py, va, ra) {
    const step = 0.02, cosA = Math.cos(ra), sinA = Math.sin(ra), cosCorr = Math.cos(ra - va);
    let x = px, y = py, dist = 0;
    while (dist < this.maxDepth) {
      x += cosA * step; y += sinA * step; dist += step;
      const gx = Math.floor(x), gy = Math.floor(y), sec = world.getSector(x, y);
      if (!sec.walkable) {
        if (!vis.isVisible(gx, gy) && !vis.isDiscovered(gx, gy)) return null;
        const cd = dist * cosCorr, wh = Math.min(2.0, 1.7 / cd);
        const hx = x - gx, hy = y - gy, isNS = hx < 0.03 || hx > 0.97;
        return { dist: cd, top: wh/2, bottom: -wh/2, u: isNS ? hy : hx, tex: this.wallTexMap[sec.name] || 3, fog: Math.max(0, Math.min(1, (cd - 5) * 0.08)), side: isNS ? 1.0 : 0.0, worldX: x, worldY: y };
      }
    }
    return null;
  }
}

// Engine Core Classes
class World {
  constructor(cfg = {}) { this.width = cfg.width || 32; this.height = cfg.height || 32; this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill('void')); this.sectorTypes = new Map(); this.sectorTypes.set('void', { walkable: false, floorColor: [20,20,25], name: 'VOID' }); }
  registerSectorTypes(t) { for (const [k,v] of Object.entries(t)) this.sectorTypes.set(k, v); }
  getSector(x, y) { const gx = Math.floor(x), gy = Math.floor(y); if (gx < 0 || gx >= this.width || gy < 0 || gy >= this.height) return this.sectorTypes.get('void'); return this.sectorTypes.get(this.grid[gy][gx]) || this.sectorTypes.get('void'); }
  fillRect(x1, y1, x2, y2, type) { for (let y = Math.min(y1,y2); y <= Math.max(y1,y2); y++) for (let x = Math.min(x1,x2); x <= Math.max(x1,x2); x++) if (x >= 0 && x < this.width && y >= 0 && y < this.height) this.grid[y][x] = type; }
  countWalkable() { let c = 0; for (let y = 0; y < this.height; y++) for (let x = 0; x < this.width; x++) if (this.getSector(x,y).walkable) c++; return c; }
}

class Visibility {
  constructor(world, cfg = {}) { this.world = world; this.viewDistance = cfg.viewDistance || 16; this.discovered = new Set(); this.currentlyVisible = new Set(); this.lastCell = null; }
  update(x, y) {
    const cell = `${Math.floor(x)},${Math.floor(y)}`; if (cell === this.lastCell) return false; this.lastCell = cell;
    profiler.start('visibility'); this.currentlyVisible.clear();
    for (let i = 0; i < 180; i++) { const ang = (i/180)*Math.PI*2; let rx = x, ry = y; const dx = Math.cos(ang)*0.4, dy = Math.sin(ang)*0.4;
      for (let d = 0; d < this.viewDistance; d += 0.4) { rx += dx; ry += dy; const k = `${Math.floor(rx)},${Math.floor(ry)}`; this.currentlyVisible.add(k); const s = this.world.getSector(rx, ry); if (s.walkable) this.discovered.add(k); if (!s.walkable) break; }
    } profiler.end('visibility'); return true;
  }
  isVisible(gx, gy) { return this.currentlyVisible.has(`${gx},${gy}`); }
  isDiscovered(gx, gy) { return this.discovered.has(`${gx},${gy}`); }
}

class Movement {
  constructor(world) { this.world = world; }
  move(e, dx, dy) { const r = e.radius || 0.2, nx = e.x + dx, ny = e.y + dy; if (this._can(nx, ny, r)) return { x: nx, y: ny }; if (this._can(nx, e.y, r)) return { x: nx, y: e.y }; if (this._can(e.x, ny, r)) return { x: e.x, y: ny }; return { x: e.x, y: e.y }; }
  _can(x, y, r) { for (const [px,py] of [[x,y],[x-r,y-r],[x+r,y-r],[x-r,y+r],[x+r,y+r]]) if (!this.world.getSector(px,py).walkable) return false; return true; }
}

class Input {
  constructor() { this.keys = {}; this.mouseDX = 0; this.locked = false; }
  init(target) {
    window.addEventListener('keydown', e => { this.keys[e.code] = true; if (['KeyW','KeyA','KeyS','KeyD','ArrowLeft','ArrowRight','KeyF'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup', e => this.keys[e.code] = false);
    document.addEventListener('mousemove', e => { if (this.locked) this.mouseDX += e.movementX; });
    document.addEventListener('pointerlockchange', () => { this.locked = document.pointerLockElement === target; document.getElementById('click-prompt').classList.toggle('hidden', this.locked); });
    target.addEventListener('click', () => { if (!this.locked) target.requestPointerLock(); });
  }
  getMovement(dt, speed) { let f=0,s=0,t=0; if (this.keys['KeyW']||this.keys['ArrowUp']) f+=speed; if (this.keys['KeyS']||this.keys['ArrowDown']) f-=speed; if (this.keys['KeyA']) s-=speed; if (this.keys['KeyD']) s+=speed; if (this.keys['ArrowLeft']) t-=2.2*dt; if (this.keys['ArrowRight']) t+=2.2*dt; if (this.keys['ShiftLeft']||this.keys['ShiftRight']) { f*=1.7; s*=1.7; } t+=this.mouseDX*0.002; this.mouseDX=0; return { forward:f, strafe:s, turn:t }; }
  isRunning() { return this.keys['ShiftLeft'] || this.keys['ShiftRight']; }
}

class Minimap {
  constructor(cfg={}) { this.fov=cfg.fov||Math.PI*0.6; this.viewDist=cfg.viewDistance||16; }
  init(canvas) { this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.resize(); window.addEventListener('resize',()=>this.resize()); }
  resize() { const c=this.canvas.parentElement; const sz=Math.min(c.clientWidth-16,c.clientHeight-24); this.canvas.width=sz; this.canvas.height=sz; }
  render(world,vis,px,py,angle,lights) {
    const ctx=this.ctx,w=this.canvas.width,h=this.canvas.height,cw=w/world.width,ch=h/world.height;
    ctx.fillStyle='#030305'; ctx.fillRect(0,0,w,h);
    for(let gy=0;gy<world.height;gy++) for(let gx=0;gx<world.width;gx++) {
      const sec=world.getSector(gx,gy),v=vis.isVisible(gx,gy),d=vis.isDiscovered(gx,gy);
      let col; if(!d&&!v) col='#050508'; else if(!sec.walkable) col=v?'#3a3a45':'#1a1a22'; else if(v) { const c=sec.floorColor; col=`rgb(${c[0]*0.6|0},${c[1]*0.6|0},${c[2]*0.6|0})`; } else col='#121215';
      ctx.fillStyle=col; ctx.fillRect(gx*cw,gy*ch,cw+0.5,ch+0.5);
    }
    for (const l of lights) {
      ctx.fillStyle = `rgba(${l.color[0]*255|0},${l.color[1]*255|0},${l.color[2]*255|0},${l.currentIntensity*0.4})`;
      ctx.beginPath(); ctx.arc(l.x*cw, l.y*ch, l.radius*cw*0.3, 0, Math.PI*2); ctx.fill();
    }
    const mx=px*cw,my=py*ch;
    ctx.fillStyle='#33ff33'; ctx.shadowColor='#33ff33'; ctx.shadowBlur=5;
    ctx.beginPath(); ctx.arc(mx,my,3,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
    ctx.strokeStyle='#33ff33'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(angle)*8,my+Math.sin(angle)*8); ctx.stroke();
  }
}

class OverlayRenderer {
  init(canvas) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.resize(); window.addEventListener('resize', () => this.resize()); }
  resize() { const c = this.canvas.parentElement; this.width = c.clientWidth; this.height = c.clientHeight; this.canvas.width = this.width; this.canvas.height = this.height; }
  render() {
    const ctx = this.ctx, w = this.width, h = this.height;
    ctx.clearRect(0, 0, w, h);
    const vig = ctx.createRadialGradient(w/2, h/2, h*0.15, w/2, h/2, h*0.95);
    vig.addColorStop(0, 'rgba(0,0,0,0)'); vig.addColorStop(1, 'rgba(0,0,0,0.6)');
    ctx.fillStyle = vig; ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = 'rgba(51,255,51,0.8)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(w/2-14, h/2); ctx.lineTo(w/2-5, h/2); ctx.moveTo(w/2+5, h/2); ctx.lineTo(w/2+14, h/2);
    ctx.moveTo(w/2, h/2-14); ctx.lineTo(w/2, h/2-5); ctx.moveTo(w/2, h/2+5); ctx.lineTo(w/2, h/2+14); ctx.stroke();
  }
}

// Level Data
const SECTOR_TYPES = {
  hangar: { walkable:true, floorColor:[80,82,88], name:'HANGAR' },
  hangar_platform: { walkable:true, floorColor:[120,110,85], name:'PLATFORM' },
  corridor: { walkable:true, floorColor:[75,78,85], name:'CORRIDOR' },
  zigzag: { walkable:true, floorColor:[70,90,78], name:'OPS CENTER' },
  computer: { walkable:true, floorColor:[75,80,100], name:'TERMINAL BAY' },
  outdoor: { walkable:true, floorColor:[100,95,80], name:'EXTERIOR' },
  pillar: { walkable:false, floorColor:[130,125,118], name:'PILLAR' },
  crate: { walkable:false, floorColor:[130,105,70], name:'CRATE' }
};
const REGIONS = [
  { type:'hangar', x1:1, y1:9, x2:7, y2:15 }, { type:'hangar_platform', x1:4, y1:11, x2:6, y2:13 },
  { type:'corridor', x1:7, y1:11, x2:11, y2:13 }, { type:'corridor', x1:17, y1:11, x2:19, y2:13 },
  { type:'zigzag', x1:11, y1:7, x2:17, y2:17 },
  { type:'pillar', x1:13, y1:9, x2:13, y2:9 }, { type:'pillar', x1:15, y1:9, x2:15, y2:9 },
  { type:'pillar', x1:13, y1:15, x2:13, y2:15 }, { type:'pillar', x1:15, y1:15, x2:15, y2:15 },
  { type:'computer', x1:19, y1:9, x2:23, y2:15 },
  { type:'crate', x1:21, y1:10, x2:22, y2:10 }, { type:'crate', x1:21, y1:14, x2:21, y2:14 },
  { type:'outdoor', x1:1, y1:1, x2:7, y2:7 }, { type:'hangar', x1:3, y1:8, x2:5, y2:8 }
];

// Setup
const world = new World({ width:24, height:24 });
world.registerSectorTypes(SECTOR_TYPES);
REGIONS.forEach(r => world.fillRect(r.x1, r.y1, r.x2, r.y2, r.type));

const visibility = new Visibility(world, { viewDistance:16 });
const movement = new Movement(world);
const input = new Input();
const renderer = new WebGL2Renderer({ rayCount:400, maxDepth:16 });
const overlay = new OverlayRenderer();
const minimap = new Minimap({ viewDistance:16 });
const lighting = new LightingSystem();
const audio = new AudioSystem();
const player = { x:3.5, y:12.5, angle:0, radius:0.2, speed:3.0 };

// Setup lights
lighting.addLight({ x: 3, y: 11, radius: 6, intensity: 0.9, color: [1.0, 0.95, 0.8], flicker: 0.3 });
lighting.addLight({ x: 6, y: 14, radius: 5, intensity: 0.7, color: [1.0, 0.9, 0.7], flicker: 0.2 });
lighting.addLight({ x: 9, y: 12, radius: 4, intensity: 0.8, color: [0.9, 0.95, 1.0], flicker: 0.6 });
lighting.addLight({ x: 18, y: 12, radius: 4, intensity: 0.8, color: [0.9, 0.95, 1.0], flicker: 0.5 });
lighting.addLight({ x: 14, y: 12, radius: 7, intensity: 0.8, color: [0.7, 1.0, 0.8], flicker: 0.1 });
lighting.addLight({ x: 21, y: 12, radius: 5, intensity: 0.9, color: [0.6, 0.8, 1.0], pulse: 2 });
lighting.addLight({ x: 4, y: 4, radius: 8, intensity: 0.5, color: [0.7, 0.8, 1.0], flicker: 0 });
lighting.addLight({ x: 21, y: 10, radius: 3, intensity: 0.6, color: [1.0, 0.3, 0.2], pulse: 4, pulseMin: 0.2 });
const flashlight = lighting.addLight({ x: player.x, y: player.y, radius: 8, intensity: 0, color: [1.0, 1.0, 0.95], type: 'player' });
let flashlightOn = false;

renderer.init(document.getElementById('game-canvas'));
renderer.updateWorldMap(world);
overlay.init(document.getElementById('overlay-canvas'));
minimap.init(document.getElementById('minimap-canvas'));
input.init(document.getElementById('viewport'));
visibility.update(player.x, player.y);

document.getElementById('viewport').addEventListener('click', async () => { if (!audio.initialized) await audio.init(); });

let lastFKey = false;
function updateLightListUI() {
  const list = document.getElementById('light-list');
  list.innerHTML = lighting.lights.slice(0, 5).map(l => {
    const c = `rgb(${l.color[0]*255|0},${l.color[1]*255|0},${l.color[2]*255|0})`;
    return `<div class="perf-row"><span><span class="light-indicator" style="background:${c}"></span>${l.type === 'player' ? 'Flashlight' : 'Light '+l.id}</span><span class="perf-value">${(l.currentIntensity*100|0)}%</span></div>`;
  }).join('');
}

// Sliders
document.getElementById('tune-ambient').addEventListener('input', e => { lighting.setAmbient(parseInt(e.target.value)/100); document.getElementById('tune-ambient-val').textContent=e.target.value+'%'; });
document.getElementById('tune-flicker').addEventListener('input', e => { lighting.setFlickerSpeed(parseInt(e.target.value)/50); document.getElementById('tune-flicker-val').textContent=e.target.value+'%'; });
document.getElementById('tune-master').addEventListener('input', e => { audio.setMasterVolume(parseInt(e.target.value)/100); document.getElementById('tune-master-val').textContent=e.target.value+'%'; });
document.getElementById('tune-ambience').addEventListener('input', e => { audio.setAmbienceVolume(parseInt(e.target.value)/100); document.getElementById('tune-ambience-val').textContent=e.target.value+'%'; });
document.getElementById('tune-footsteps').addEventListener('input', e => { audio.setFootstepVolume(parseInt(e.target.value)/100); document.getElementById('tune-footsteps-val').textContent=e.target.value+'%'; });
document.getElementById('tune-rays').addEventListener('input', e => { renderer.setRayCount(parseInt(e.target.value)); document.getElementById('tune-rays-val').textContent=e.target.value; });
document.getElementById('tune-viewdist').addEventListener('input', e => { renderer.setViewDist(parseInt(e.target.value)); visibility.viewDistance=parseInt(e.target.value); document.getElementById('tune-viewdist-val').textContent=e.target.value; });

function showMessage(t) { const log=document.getElementById('messages'), msg=document.createElement('div'); msg.className='message'; msg.textContent=t; log.appendChild(msg); setTimeout(()=>msg.remove(),3500); }

// Game Loop
let lastTime=0, uiTimer=0;
function gameLoop(time) {
  profiler.start('frame');
  const dt=Math.min((time-lastTime)/1000,0.1); lastTime=time;
  
  if (input.keys['KeyF'] && !lastFKey) {
    flashlightOn = !flashlightOn;
    flashlight.intensity = flashlightOn ? 1.2 : 0;
    showMessage(flashlightOn ? 'üî¶ Flashlight ON' : 'üî¶ Flashlight OFF');
  }
  lastFKey = input.keys['KeyF'];
  
  const move=input.getMovement(dt,player.speed*dt);
  player.angle+=move.turn; while(player.angle<0) player.angle+=Math.PI*2; while(player.angle>=Math.PI*2) player.angle-=Math.PI*2;
  const fx=Math.cos(player.angle),fy=Math.sin(player.angle),sx=Math.cos(player.angle+Math.PI/2),sy=Math.sin(player.angle+Math.PI/2);
  const dx=fx*move.forward+sx*move.strafe, dy=fy*move.forward+sy*move.strafe;
  const isMoving = dx !== 0 || dy !== 0;
  if(isMoving) { const res=movement.move(player,dx,dy); player.x=res.x; player.y=res.y; }
  
  visibility.update(player.x,player.y);
  profiler.start('lighting'); lighting.update(dt, player.x, player.y, player.angle); profiler.end('lighting');
  profiler.start('audio'); audio.update(dt, player.x, player.y, player.angle, isMoving, input.isRunning()); profiler.end('audio');
  
  renderer.render(world, visibility, player.x, player.y, player.angle, lighting);
  overlay.render();
  minimap.render(world, visibility, player.x, player.y, player.angle, lighting.lights);
  
  profiler.end('frame');
  
  uiTimer+=dt;
  if(uiTimer>0.1) {
    uiTimer=0;
    const frame=profiler.getAvg('frame'), fps=frame>0?1000/frame:0;
    const fpsEl=document.getElementById('stat-fps'); fpsEl.textContent=fps.toFixed(0); fpsEl.className='stat-value'+(fps>=55?'':fps>=30?' warn':' bad');
    document.getElementById('stat-frame').textContent=frame.toFixed(1)+'ms';
    document.getElementById('stat-lights').textContent=lighting.lights.length;
    document.getElementById('stat-sector').textContent=world.getSector(player.x,player.y).name||'--';
    document.getElementById('perf-frame').textContent=frame.toFixed(2)+'ms';
    document.getElementById('perf-raycast').textContent=profiler.getAvg('raycast').toFixed(2)+'ms';
    document.getElementById('perf-gpu').textContent=profiler.getAvg('gpu').toFixed(2)+'ms';
    document.getElementById('perf-lighting').textContent=profiler.getAvg('lighting').toFixed(2)+'ms';
    document.getElementById('perf-audio').textContent=profiler.getAvg('audio').toFixed(2)+'ms';
    updateLightListUI();
  }
  
  requestAnimationFrame(gameLoop);
}

showMessage('üî¶ Press F for flashlight');
showMessage('üîä Click to enable spatial audio');
showMessage('üí° Dynamic lighting active');
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
