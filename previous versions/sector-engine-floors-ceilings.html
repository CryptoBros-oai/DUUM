<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sector Engine - Textured Floors & Ceilings</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0c;
      color: #33ff33;
      font-family: 'Share Tech Mono', monospace;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    #header {
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border-bottom: 2px solid #33ff33;
      padding: 8px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      letter-spacing: 3px;
      text-shadow: 0 0 10px rgba(51, 255, 51, 0.5);
    }
    
    .tag { font-size: 0.5rem; color: #33aa33; margin-left: 8px; letter-spacing: 2px; background: rgba(51,255,51,0.1); padding: 2px 6px; border-radius: 3px; }
    
    #stats { display: flex; gap: 16px; font-size: 0.7rem; }
    .stat { display: flex; flex-direction: column; align-items: center; }
    .stat-label { color: #555; font-size: 0.55rem; letter-spacing: 1px; }
    .stat-value { color: #33ff33; }
    .stat-value.warn { color: #ffaa33; }
    .stat-value.bad { color: #ff5533; }
    
    #main { flex: 1; display: flex; padding: 8px; min-height: 0; gap: 8px; }
    
    #viewport {
      flex: 2;
      position: relative;
      border: 2px solid #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
      background: #000;
    }
    
    #game-canvas { width: 100%; height: 100%; display: block; }
    #overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    
    #click-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #33ff33;
      padding: 14px 28px;
      text-align: center;
      cursor: pointer;
      z-index: 10;
    }
    #click-prompt:hover { background: rgba(51, 255, 51, 0.1); }
    #click-prompt.hidden { display: none; }
    #click-prompt h2 { font-family: 'Orbitron', sans-serif; font-size: 0.85rem; letter-spacing: 2px; }
    #click-prompt p { font-size: 0.65rem; color: #888; margin-top: 5px; }
    
    #sidebar {
      width: 260px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow-y: auto;
    }
    
    .panel {
      background: #0f0f12;
      border: 1px solid #222;
      border-radius: 4px;
      padding: 8px;
    }
    
    .panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.6rem;
      letter-spacing: 2px;
      color: #444;
      margin-bottom: 6px;
    }
    
    #minimap-panel { flex: 0 0 auto; height: 170px; display: flex; flex-direction: column; }
    #minimap-canvas { flex: 1; width: 100%; border: 1px solid #1a1a1a; background: #030305; }
    
    .perf-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: #666;
      margin-bottom: 3px;
    }
    .perf-value { color: #33ff33; min-width: 55px; text-align: right; }
    .perf-value.warn { color: #ffaa33; }
    .perf-value.bad { color: #ff5533; }
    
    .perf-bar {
      height: 4px;
      background: #1a1a1a;
      margin: 2px 0 6px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    .perf-bar-fill {
      height: 100%;
      background: #33ff33;
      transition: width 0.1s;
    }
    .perf-bar-fill.warn { background: #ffaa33; }
    .perf-bar-fill.bad { background: #ff5533; }
    
    #perf-graph {
      height: 40px;
      background: #0a0a0c;
      border: 1px solid #1a1a1a;
      margin-top: 6px;
    }
    #perf-graph canvas { width: 100%; height: 100%; }
    
    .slider-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.6rem;
      color: #888;
      margin-bottom: 4px;
    }
    .slider-row input[type="range"] {
      width: 70px;
      height: 4px;
      -webkit-appearance: none;
      background: #1a1a1a;
      border-radius: 2px;
    }
    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 10px;
      height: 10px;
      background: #33ff33;
      border-radius: 50%;
      cursor: pointer;
    }
    .slider-value { color: #33ff33; min-width: 35px; text-align: right; }
    
    .control-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.6rem;
      color: #888;
      margin-bottom: 3px;
    }
    .key {
      background: #1a1a1f;
      border: 1px solid #2a2a2a;
      padding: 1px 4px;
      border-radius: 2px;
      color: #33ff33;
      font-size: 0.55rem;
    }
    
    #messages {
      position: absolute;
      bottom: 10px;
      left: 10px;
      max-width: 280px;
      z-index: 5;
    }
    .message {
      background: rgba(0,0,0,0.85);
      border-left: 2px solid #33ff33;
      padding: 4px 8px;
      margin-bottom: 2px;
      font-size: 0.7rem;
      animation: msgIn 0.2s ease-out, msgOut 0.3s ease-in 2s forwards;
    }
    @keyframes msgIn { from { opacity: 0; transform: translateX(-10px); } }
    @keyframes msgOut { to { opacity: 0; } }
  </style>
</head>
<body>
  <div id="header">
    <h1>SECTOR ENGINE <span class="tag">FLOORS + CEILINGS</span></h1>
    <div id="stats">
      <div class="stat">
        <span class="stat-label">FPS</span>
        <span class="stat-value" id="stat-fps">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">FRAME</span>
        <span class="stat-value" id="stat-frame">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">DRAWS</span>
        <span class="stat-value" id="stat-draws">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">SECTOR</span>
        <span class="stat-value" id="stat-sector">--</span>
      </div>
    </div>
  </div>
  
  <div id="main">
    <div id="viewport">
      <canvas id="game-canvas"></canvas>
      <canvas id="overlay-canvas"></canvas>
      <div id="click-prompt">
        <h2>CLICK TO ENGAGE</h2>
        <p>Textured Floors & Ceilings</p>
      </div>
      <div id="messages"></div>
    </div>
    
    <div id="sidebar">
      <div class="panel" id="minimap-panel">
        <div class="panel-title">TACTICAL MAP</div>
        <canvas id="minimap-canvas"></canvas>
      </div>
      
      <div class="panel">
        <div class="panel-title">‚ö° PERFORMANCE</div>
        <div class="perf-row">
          <span>Frame Total</span>
          <span class="perf-value" id="perf-frame">--</span>
        </div>
        <div class="perf-bar"><div class="perf-bar-fill" id="bar-frame"></div></div>
        <div class="perf-row">
          <span>‚îú Walls</span>
          <span class="perf-value" id="perf-walls">--</span>
        </div>
        <div class="perf-row">
          <span>‚îú Floors</span>
          <span class="perf-value" id="perf-floors">--</span>
        </div>
        <div class="perf-row">
          <span>‚îú Visibility</span>
          <span class="perf-value" id="perf-visibility">--</span>
        </div>
        <div class="perf-row">
          <span>‚îî Minimap</span>
          <span class="perf-value" id="perf-minimap">--</span>
        </div>
        <div class="perf-row" style="margin-top:4px;border-top:1px solid #1a1a1a;padding-top:4px;">
          <span>Triangles</span>
          <span class="perf-value" id="perf-tris">--</span>
        </div>
        <div id="perf-graph"><canvas id="graph-canvas"></canvas></div>
      </div>
      
      <div class="panel">
        <div class="panel-title">üéõÔ∏è TUNING</div>
        <div class="slider-row">
          <span>Ray Count</span>
          <input type="range" id="tune-rays" min="200" max="640" value="400">
          <span class="slider-value" id="tune-rays-val">400</span>
        </div>
        <div class="slider-row">
          <span>View Dist</span>
          <input type="range" id="tune-viewdist" min="10" max="24" value="16">
          <span class="slider-value" id="tune-viewdist-val">16</span>
        </div>
        <div class="slider-row">
          <span>Floor Detail</span>
          <input type="range" id="tune-floordetail" min="1" max="4" value="2">
          <span class="slider-value" id="tune-floordetail-val">2</span>
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">CONTROLS</div>
        <div class="control-row">
          <span>Move</span>
          <span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></span>
        </div>
        <div class="control-row">
          <span>Look</span>
          <span>Mouse / <span class="key">‚Üê</span><span class="key">‚Üí</span></span>
        </div>
        <div class="control-row">
          <span>Run</span>
          <span><span class="key">Shift</span></span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================================================
    // SECTOR ENGINE - TEXTURED FLOORS & CEILINGS
    // Full 2.5D rendering with horizontal surface texturing
    // =========================================================
    
    // ============ PROFILER ============
    class Profiler {
      constructor() {
        this.timings = {};
        this.history = {};
        this.maxHistory = 100;
      }
      start(n) { this.timings[n] = performance.now(); }
      end(n) {
        if (!this.timings[n]) return 0;
        const d = performance.now() - this.timings[n];
        if (!this.history[n]) this.history[n] = [];
        this.history[n].push(d);
        if (this.history[n].length > this.maxHistory) this.history[n].shift();
        return d;
      }
      get(n) { const h = this.history[n]; return h?.length ? h[h.length-1] : 0; }
      getAvg(n) { const h = this.history[n]; return h?.length ? h.reduce((a,b)=>a+b,0)/h.length : 0; }
      getHistory(n) { return this.history[n] || []; }
    }
    const profiler = new Profiler();
    
    // ============ TEXTURE GENERATOR ============
    class TextureGenerator {
      constructor(size = 64) {
        this.size = size;
        this.canvas = document.createElement('canvas');
        this.canvas.width = size;
        this.canvas.height = size;
        this.ctx = this.canvas.getContext('2d');
      }
      
      _noise(x, y, seed = 0) {
        const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
        return n - Math.floor(n);
      }
      
      _fbm(x, y, oct = 4, seed = 0) {
        let v = 0, a = 0.5, f = 1;
        for (let i = 0; i < oct; i++) { v += a * this._noise(x*f, y*f, seed+i*100); a *= 0.5; f *= 2; }
        return v;
      }
      
      // Wall textures
      generateMetalPanels(base, seed = 0) {
        const s = this.size, d = this.ctx.createImageData(s, s).data;
        const img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const grid = (x % 16 < 2) || (y % 16 < 2);
            const rivet = (x % 16 >= 6 && x % 16 <= 9) && (y % 16 <= 2 || y % 16 >= 13);
            const highlight = (x % 16 >= 2 && x % 16 <= 4) && (y % 16 >= 2 && y % 16 <= 4);
            const noise = this._fbm(x/6, y/6, 3, seed) * 40 - 20;
            let r = base[0] + noise, g = base[1] + noise, b = base[2] + noise;
            if (grid) { r -= 50; g -= 50; b -= 45; }
            else if (highlight) { r += 40; g += 40; b += 50; }
            if (rivet) { r += 55; g += 55; b += 65; }
            img.data[i] = Math.max(0, Math.min(255, r));
            img.data[i+1] = Math.max(0, Math.min(255, g));
            img.data[i+2] = Math.max(0, Math.min(255, b));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateTechWall(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            let r = base[0]*0.5, g = base[1]*0.5, b = base[2]*0.5;
            const lineH = y % 10 < 2, lineV = x % 14 < 2;
            const node = (x % 14 < 4) && (y % 10 < 4);
            const traceH = y % 10 === 5 && this._noise(Math.floor(x/7), y, seed) > 0.4;
            const traceV = x % 14 === 7 && this._noise(x, Math.floor(y/5), seed+50) > 0.4;
            if (lineH || lineV) { r += 35; g += 40; b += 55; }
            if (node) { g += 70; b += 95; }
            if (traceH || traceV) { r += 30; g += 100; b += 130; }
            const n = this._noise(x, y, seed) * 12 - 6;
            img.data[i] = Math.max(0, Math.min(255, r+n));
            img.data[i+1] = Math.max(0, Math.min(255, g+n));
            img.data[i+2] = Math.max(0, Math.min(255, b+n));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateConcrete(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const n1 = this._fbm(x/4, y/4, 4, seed) * 70 - 35;
            const n2 = this._fbm(x/12, y/12, 2, seed+100) * 35 - 17;
            const crack = this._noise(x/3, y/3, seed+200) > 0.92 ? -45 : 0;
            const t = n1 + n2 + crack;
            img.data[i] = Math.max(0, Math.min(255, base[0]+t));
            img.data[i+1] = Math.max(0, Math.min(255, base[1]+t));
            img.data[i+2] = Math.max(0, Math.min(255, base[2]+t));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateGrating(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const cx = x % 8, cy = y % 8;
            const diamond = Math.abs(cx - 3.5) + Math.abs(cy - 3.5) < 3;
            if (diamond) {
              img.data[i] = 12; img.data[i+1] = 15; img.data[i+2] = 20;
            } else {
              const hl = cx < 3.5 || cy < 3.5;
              const n = this._noise(x, y, seed) * 18 - 9;
              img.data[i] = Math.max(0, Math.min(255, (hl ? base[0]+45 : base[0]) + n));
              img.data[i+1] = Math.max(0, Math.min(255, (hl ? base[1]+45 : base[1]) + n));
              img.data[i+2] = Math.max(0, Math.min(255, (hl ? base[2]+55 : base[2]) + n));
            }
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateBrick(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const row = Math.floor(y / 8);
            const ox = (row % 2) * 8;
            const bx = (x + ox) % 16, by = y % 8;
            const mortar = bx < 2 || by < 2;
            if (mortar) {
              const n = this._noise(x, y, seed) * 18;
              img.data[i] = 55+n; img.data[i+1] = 52+n; img.data[i+2] = 48+n;
            } else {
              const bid = Math.floor((x+ox)/16) + row*1000;
              const bv = (this._noise(bid, 0, seed) - 0.5) * 60;
              const sn = this._noise(x*2, y*2, seed+300) * 28 - 14;
              img.data[i] = Math.max(0, Math.min(255, base[0]+bv+sn));
              img.data[i+1] = Math.max(0, Math.min(255, base[1]+bv*0.8+sn));
              img.data[i+2] = Math.max(0, Math.min(255, base[2]+bv*0.6+sn));
            }
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateCrate(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const grain = Math.sin(y*0.6 + this._noise(x/15, y/4, seed)*8) * 22;
            const border = x < 6 || x >= s-6 || y < 6 || y >= s-6;
            const inner = (x >= 6 && x < 10) || (x >= s-10 && x < s-6) || (y >= 6 && y < 10) || (y >= s-10 && y < s-6);
            const d1 = Math.abs((x-s/2)-(y-s/2)) < 4, d2 = Math.abs((x-s/2)+(y-s/2)) < 4;
            const cross = (d1||d2) && !border;
            const plank = y % 12 < 1;
            let r = base[0]+grain, g = base[1]+grain*0.9, b = base[2]+grain*0.7;
            if (border) { r += 40; g += 35; b += 25; }
            if (inner && border) { r -= 30; g -= 26; b -= 20; }
            if (cross) { r += 35; g += 30; b += 22; }
            if (plank && !border) { r -= 35; g -= 32; b -= 25; }
            const n = this._noise(x, y, seed) * 20 - 10;
            img.data[i] = Math.max(0, Math.min(255, r+n));
            img.data[i+1] = Math.max(0, Math.min(255, g+n*0.9));
            img.data[i+2] = Math.max(0, Math.min(255, b+n*0.7));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generatePillar(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const streak = this._noise(x/4, 0, seed) * 28 - 14;
            const n = this._fbm(x/8, y/8, 3, seed+100) * 22 - 11;
            const band = (y % 32 < 2) ? -25 : 0;
            const t = streak + n + band;
            img.data[i] = Math.max(0, Math.min(255, base[0]+t));
            img.data[i+1] = Math.max(0, Math.min(255, base[1]+t));
            img.data[i+2] = Math.max(0, Math.min(255, base[2]+t));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      // Floor textures
      generateTileFloor(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const tx = x % 16, ty = y % 16;
            const grout = tx < 1 || ty < 1;
            const n = this._noise(x, y, seed) * 20 - 10;
            if (grout) {
              img.data[i] = 40+n; img.data[i+1] = 42+n; img.data[i+2] = 45+n;
            } else {
              const tileVar = this._noise(Math.floor(x/16), Math.floor(y/16), seed+100) * 30 - 15;
              img.data[i] = Math.max(0, Math.min(255, base[0]+tileVar+n));
              img.data[i+1] = Math.max(0, Math.min(255, base[1]+tileVar+n));
              img.data[i+2] = Math.max(0, Math.min(255, base[2]+tileVar+n));
            }
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateMetalFloor(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            // Diamond plate pattern
            const px = x % 8, py = y % 8;
            const diamond = (px + py) % 8 < 2 || Math.abs(px - py) % 8 < 2;
            const n = this._noise(x, y, seed) * 15 - 7;
            let r = base[0], g = base[1], b = base[2];
            if (diamond) { r += 25; g += 25; b += 30; }
            img.data[i] = Math.max(0, Math.min(255, r+n));
            img.data[i+1] = Math.max(0, Math.min(255, g+n));
            img.data[i+2] = Math.max(0, Math.min(255, b+n));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateDirtFloor(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const n1 = this._fbm(x/3, y/3, 4, seed) * 50 - 25;
            const n2 = this._fbm(x/8, y/8, 2, seed+50) * 25 - 12;
            const pebble = this._noise(x*3, y*3, seed+100) > 0.9 ? 20 : 0;
            const t = n1 + n2 + pebble;
            img.data[i] = Math.max(0, Math.min(255, base[0]+t));
            img.data[i+1] = Math.max(0, Math.min(255, base[1]+t*0.9));
            img.data[i+2] = Math.max(0, Math.min(255, base[2]+t*0.7));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      // Ceiling textures
      generateCeilingPanels(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const px = x % 32, py = y % 32;
            const frame = px < 2 || py < 2 || px > 29 || py > 29;
            const n = this._noise(x, y, seed) * 12 - 6;
            if (frame) {
              img.data[i] = Math.max(0, Math.min(255, base[0]-30+n));
              img.data[i+1] = Math.max(0, Math.min(255, base[1]-30+n));
              img.data[i+2] = Math.max(0, Math.min(255, base[2]-25+n));
            } else {
              const panelN = this._fbm(x/6, y/6, 2, seed+100) * 20 - 10;
              img.data[i] = Math.max(0, Math.min(255, base[0]+panelN+n));
              img.data[i+1] = Math.max(0, Math.min(255, base[1]+panelN+n));
              img.data[i+2] = Math.max(0, Math.min(255, base[2]+panelN+n));
            }
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateTechCeiling(base, seed = 0) {
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const beam = (x % 24 < 3) || (y % 24 < 3);
            const light = (x % 24 > 8 && x % 24 < 16) && (y % 24 > 8 && y % 24 < 16);
            const n = this._noise(x, y, seed) * 10 - 5;
            let r = base[0], g = base[1], b = base[2];
            if (beam) { r -= 20; g -= 20; b -= 15; }
            if (light) { r += 40; g += 50; b += 70; }
            img.data[i] = Math.max(0, Math.min(255, r+n));
            img.data[i+1] = Math.max(0, Math.min(255, g+n));
            img.data[i+2] = Math.max(0, Math.min(255, b+n));
            img.data[i+3] = 255;
          }
        }
        return img;
      }
      
      generateSkyCeiling(base, seed = 0) {
        // Dark sky with stars
        const s = this.size, img = this.ctx.createImageData(s, s);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const i = (y * s + x) * 4;
            const star = this._noise(x*5, y*5, seed) > 0.97;
            const n = this._noise(x, y, seed+50) * 8 - 4;
            if (star) {
              const bright = this._noise(x, y, seed+100) * 155 + 100;
              img.data[i] = bright; img.data[i+1] = bright; img.data[i+2] = bright + 20;
            } else {
              img.data[i] = Math.max(0, Math.min(255, base[0]+n));
              img.data[i+1] = Math.max(0, Math.min(255, base[1]+n));
              img.data[i+2] = Math.max(0, Math.min(255, base[2]+n));
            }
            img.data[i+3] = 255;
          }
        }
        return img;
      }
    }
    
    // ============ WEBGL2 RENDERER WITH FLOORS/CEILINGS ============
    class WebGL2Renderer {
      constructor(config = {}) {
        this.rayCount = config.rayCount || 400;
        this.fov = config.fov || Math.PI * 0.6;
        this.maxDepth = config.maxDepth || 16;
        this.floorDetail = 2;
        
        this.gl = null;
        this.wallProgram = null;
        this.floorProgram = null;
        this.texGen = new TextureGenerator(64);
        
        this.drawCalls = 0;
        this.triangleCount = 0;
      }
      
      init(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl2', { antialias: false, alpha: false });
        if (!this.gl) { console.error('WebGL2 not supported'); return false; }
        
        this._initWallShaders();
        this._initFloorShaders();
        this._initBuffers();
        this._initTextures();
        this.resize();
        
        window.addEventListener('resize', () => this.resize());
        return true;
      }
      
      resize() {
        const c = this.canvas.parentElement;
        this.width = c.clientWidth;
        this.height = c.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.gl.viewport(0, 0, this.width, this.height);
      }
      
      _compileShader(type, src) {
        const gl = this.gl;
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error('Shader error:', gl.getShaderInfoLog(s));
        return s;
      }
      
      _createProgram(vsSrc, fsSrc) {
        const gl = this.gl;
        const vs = this._compileShader(gl.VERTEX_SHADER, vsSrc);
        const fs = this._compileShader(gl.FRAGMENT_SHADER, fsSrc);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) console.error('Link error:', gl.getProgramInfoLog(prog));
        return prog;
      }
      
      _initWallShaders() {
        const vsSrc = `#version 300 es
          in vec2 aPos;
          in vec2 aUV;
          in float aTex;
          in float aShade;
          in float aFog;
          in float aSide;
          out vec2 vUV;
          flat out int vTex;
          out float vShade;
          out float vFog;
          out float vSide;
          void main() {
            gl_Position = vec4(aPos, 0.0, 1.0);
            vUV = aUV;
            vTex = int(aTex);
            vShade = aShade;
            vFog = aFog;
            vSide = aSide;
          }
        `;
        const fsSrc = `#version 300 es
          precision highp float;
          precision highp sampler2DArray;
          in vec2 vUV;
          flat in int vTex;
          in float vShade;
          in float vFog;
          in float vSide;
          uniform sampler2DArray uTex;
          out vec4 fragColor;
          void main() {
            vec3 c = texture(uTex, vec3(fract(vUV), float(vTex))).rgb;
            c *= mix(1.0, 0.75, vSide);
            c *= vShade;
            c = mix(c, vec3(0.07, 0.085, 0.11), vFog);
            fragColor = vec4(c, 1.0);
          }
        `;
        this.wallProgram = this._createProgram(vsSrc, fsSrc);
        
        const gl = this.gl;
        this.wallAttribs = {
          pos: gl.getAttribLocation(this.wallProgram, 'aPos'),
          uv: gl.getAttribLocation(this.wallProgram, 'aUV'),
          tex: gl.getAttribLocation(this.wallProgram, 'aTex'),
          shade: gl.getAttribLocation(this.wallProgram, 'aShade'),
          fog: gl.getAttribLocation(this.wallProgram, 'aFog'),
          side: gl.getAttribLocation(this.wallProgram, 'aSide')
        };
        this.wallUniforms = { tex: gl.getUniformLocation(this.wallProgram, 'uTex') };
      }
      
      _initFloorShaders() {
        // Floor/ceiling shader - renders horizontal spans
        const vsSrc = `#version 300 es
          in vec2 aPos;
          in vec2 aWorldPos;
          in float aTex;
          in float aShade;
          in float aFog;
          out vec2 vWorldPos;
          flat out int vTex;
          out float vShade;
          out float vFog;
          void main() {
            gl_Position = vec4(aPos, 0.0, 1.0);
            vWorldPos = aWorldPos;
            vTex = int(aTex);
            vShade = aShade;
            vFog = aFog;
          }
        `;
        const fsSrc = `#version 300 es
          precision highp float;
          precision highp sampler2DArray;
          in vec2 vWorldPos;
          flat in int vTex;
          in float vShade;
          in float vFog;
          uniform sampler2DArray uTex;
          out vec4 fragColor;
          void main() {
            vec2 uv = fract(vWorldPos);
            vec3 c = texture(uTex, vec3(uv, float(vTex))).rgb;
            c *= vShade;
            c = mix(c, vec3(0.07, 0.085, 0.11), vFog);
            fragColor = vec4(c, 1.0);
          }
        `;
        this.floorProgram = this._createProgram(vsSrc, fsSrc);
        
        const gl = this.gl;
        this.floorAttribs = {
          pos: gl.getAttribLocation(this.floorProgram, 'aPos'),
          worldPos: gl.getAttribLocation(this.floorProgram, 'aWorldPos'),
          tex: gl.getAttribLocation(this.floorProgram, 'aTex'),
          shade: gl.getAttribLocation(this.floorProgram, 'aShade'),
          fog: gl.getAttribLocation(this.floorProgram, 'aFog')
        };
        this.floorUniforms = { tex: gl.getUniformLocation(this.floorProgram, 'uTex') };
      }
      
      _initBuffers() {
        const gl = this.gl;
        
        // Wall VAO
        this.wallVAO = gl.createVertexArray();
        gl.bindVertexArray(this.wallVAO);
        this.wallBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.wallBuffer);
        const wStride = 8 * 4;
        gl.enableVertexAttribArray(this.wallAttribs.pos);
        gl.vertexAttribPointer(this.wallAttribs.pos, 2, gl.FLOAT, false, wStride, 0);
        gl.enableVertexAttribArray(this.wallAttribs.uv);
        gl.vertexAttribPointer(this.wallAttribs.uv, 2, gl.FLOAT, false, wStride, 8);
        gl.enableVertexAttribArray(this.wallAttribs.tex);
        gl.vertexAttribPointer(this.wallAttribs.tex, 1, gl.FLOAT, false, wStride, 16);
        gl.enableVertexAttribArray(this.wallAttribs.shade);
        gl.vertexAttribPointer(this.wallAttribs.shade, 1, gl.FLOAT, false, wStride, 20);
        gl.enableVertexAttribArray(this.wallAttribs.fog);
        gl.vertexAttribPointer(this.wallAttribs.fog, 1, gl.FLOAT, false, wStride, 24);
        gl.enableVertexAttribArray(this.wallAttribs.side);
        gl.vertexAttribPointer(this.wallAttribs.side, 1, gl.FLOAT, false, wStride, 28);
        
        // Floor VAO
        this.floorVAO = gl.createVertexArray();
        gl.bindVertexArray(this.floorVAO);
        this.floorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.floorBuffer);
        const fStride = 7 * 4;
        gl.enableVertexAttribArray(this.floorAttribs.pos);
        gl.vertexAttribPointer(this.floorAttribs.pos, 2, gl.FLOAT, false, fStride, 0);
        gl.enableVertexAttribArray(this.floorAttribs.worldPos);
        gl.vertexAttribPointer(this.floorAttribs.worldPos, 2, gl.FLOAT, false, fStride, 8);
        gl.enableVertexAttribArray(this.floorAttribs.tex);
        gl.vertexAttribPointer(this.floorAttribs.tex, 1, gl.FLOAT, false, fStride, 16);
        gl.enableVertexAttribArray(this.floorAttribs.shade);
        gl.vertexAttribPointer(this.floorAttribs.shade, 1, gl.FLOAT, false, fStride, 20);
        gl.enableVertexAttribArray(this.floorAttribs.fog);
        gl.vertexAttribPointer(this.floorAttribs.fog, 1, gl.FLOAT, false, fStride, 24);
        
        gl.bindVertexArray(null);
        
        // Allocate data arrays
        this.wallData = new Float32Array(800 * 6 * 8);
        this.floorData = new Float32Array(120000); // Generous for floor/ceiling spans
      }
      
      _initTextures() {
        const gl = this.gl;
        const tg = this.texGen;
        const s = 64;
        
        // Wall textures (0-8)
        // Floor textures (9-13)
        // Ceiling textures (14-17)
        const textures = [
          // Walls
          tg.generateMetalPanels([120, 125, 135], 42),      // 0
          tg.generateMetalPanels([150, 135, 95], 43),       // 1
          tg.generateTechWall([70, 85, 110], 44),           // 2
          tg.generateConcrete([100, 100, 105], 45),         // 3
          tg.generateConcrete([85, 110, 90], 46),           // 4
          tg.generateBrick([145, 95, 75], 47),              // 5
          tg.generateGrating([110, 115, 125], 48),          // 6
          tg.generateCrate([160, 130, 85], 49),             // 7
          tg.generatePillar([150, 148, 145], 50),           // 8
          // Floors
          tg.generateTileFloor([70, 72, 78], 60),           // 9
          tg.generateMetalFloor([85, 88, 95], 61),          // 10
          tg.generateGrating([90, 95, 105], 62),            // 11
          tg.generateDirtFloor([110, 95, 70], 63),          // 12
          tg.generateConcrete([75, 78, 82], 64),            // 13
          // Ceilings
          tg.generateCeilingPanels([55, 58, 65], 70),       // 14
          tg.generateTechCeiling([50, 55, 65], 71),         // 15
          tg.generateSkyCeiling([15, 18, 28], 72),          // 16
          tg.generateConcrete([60, 62, 68], 73),            // 17
        ];
        
        this.textureAtlas = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.textureAtlas);
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, s, s, textures.length, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        for (let i = 0; i < textures.length; i++) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, s, s, 1, gl.RGBA, gl.UNSIGNED_BYTE, textures[i].data);
        }
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
        
        // Texture mappings
        this.wallTexMap = { 'HANGAR': 0, 'PLATFORM': 1, 'TERMINAL BAY': 2, 'VOID': 3, 'OPS CENTER': 4, 'EXTERIOR': 5, 'CORRIDOR': 6, 'CRATE': 7, 'PILLAR': 8 };
        this.floorTexMap = { 'HANGAR': 10, 'PLATFORM': 10, 'TERMINAL BAY': 11, 'OPS CENTER': 9, 'EXTERIOR': 12, 'CORRIDOR': 11, 'CRATE': 13, 'PILLAR': 13, 'VOID': 13 };
        this.ceilTexMap = { 'HANGAR': 14, 'PLATFORM': 14, 'TERMINAL BAY': 15, 'OPS CENTER': 14, 'EXTERIOR': 16, 'CORRIDOR': 15, 'CRATE': 17, 'PILLAR': 17, 'VOID': 17 };
      }
      
      setRayCount(n) { this.rayCount = n; }
      setViewDist(d) { this.maxDepth = d; }
      setFloorDetail(d) { this.floorDetail = d; }
      
      render(world, visibility, px, py, angle) {
        const gl = this.gl;
        gl.clearColor(0.07, 0.085, 0.11, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Store wall hit distances for floor/ceiling clipping
        this.wallDistances = new Float32Array(this.rayCount);
        this.wallTops = new Float32Array(this.rayCount);
        this.wallBottoms = new Float32Array(this.rayCount);
        
        // Build wall geometry
        profiler.start('walls');
        const wallVerts = this._buildWalls(world, visibility, px, py, angle);
        profiler.end('walls');
        
        // Build floor/ceiling geometry
        profiler.start('floors');
        const floorVerts = this._buildFloors(world, visibility, px, py, angle);
        profiler.end('floors');
        
        this.drawCalls = 0;
        this.triangleCount = 0;
        
        // Draw floors/ceilings first (behind walls)
        if (floorVerts > 0) {
          gl.useProgram(this.floorProgram);
          gl.bindVertexArray(this.floorVAO);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.floorBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.floorData.subarray(0, floorVerts * 7), gl.DYNAMIC_DRAW);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.textureAtlas);
          gl.uniform1i(this.floorUniforms.tex, 0);
          gl.drawArrays(gl.TRIANGLES, 0, floorVerts);
          this.drawCalls++;
          this.triangleCount += floorVerts / 3;
        }
        
        // Draw walls
        if (wallVerts > 0) {
          gl.useProgram(this.wallProgram);
          gl.bindVertexArray(this.wallVAO);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.wallBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.wallData.subarray(0, wallVerts * 8), gl.DYNAMIC_DRAW);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.textureAtlas);
          gl.uniform1i(this.wallUniforms.tex, 0);
          gl.drawArrays(gl.TRIANGLES, 0, wallVerts);
          this.drawCalls++;
          this.triangleCount += wallVerts / 3;
        }
      }
      
      _buildWalls(world, vis, px, py, angle) {
        const data = this.wallData;
        const colW = 2.0 / this.rayCount;
        let vCount = 0;
        
        for (let i = 0; i < this.rayCount; i++) {
          const rayAngle = angle + ((i / this.rayCount) - 0.5) * this.fov;
          const hit = this._castRay(world, vis, px, py, angle, rayAngle);
          
          this.wallDistances[i] = hit ? hit.dist : this.maxDepth;
          
          if (hit) {
            const x0 = -1 + i * colW, x1 = x0 + colW;
            const y0 = hit.top, y1 = hit.bottom;
            
            this.wallTops[i] = y0;
            this.wallBottoms[i] = y1;
            
            const vi = vCount * 8;
            // 6 vertices for 2 triangles
            data[vi] = x0; data[vi+1] = y0; data[vi+2] = hit.u; data[vi+3] = 0; data[vi+4] = hit.tex; data[vi+5] = hit.shade; data[vi+6] = hit.fog; data[vi+7] = hit.side;
            data[vi+8] = x1; data[vi+9] = y0; data[vi+10] = hit.u; data[vi+11] = 0; data[vi+12] = hit.tex; data[vi+13] = hit.shade; data[vi+14] = hit.fog; data[vi+15] = hit.side;
            data[vi+16] = x0; data[vi+17] = y1; data[vi+18] = hit.u; data[vi+19] = 1; data[vi+20] = hit.tex; data[vi+21] = hit.shade; data[vi+22] = hit.fog; data[vi+23] = hit.side;
            data[vi+24] = x1; data[vi+25] = y0; data[vi+26] = hit.u; data[vi+27] = 0; data[vi+28] = hit.tex; data[vi+29] = hit.shade; data[vi+30] = hit.fog; data[vi+31] = hit.side;
            data[vi+32] = x1; data[vi+33] = y1; data[vi+34] = hit.u; data[vi+35] = 1; data[vi+36] = hit.tex; data[vi+37] = hit.shade; data[vi+38] = hit.fog; data[vi+39] = hit.side;
            data[vi+40] = x0; data[vi+41] = y1; data[vi+42] = hit.u; data[vi+43] = 1; data[vi+44] = hit.tex; data[vi+45] = hit.shade; data[vi+46] = hit.fog; data[vi+47] = hit.side;
            vCount += 6;
          } else {
            this.wallTops[i] = 0;
            this.wallBottoms[i] = 0;
          }
        }
        
        return vCount;
      }
      
      _buildFloors(world, vis, px, py, angle) {
        const data = this.floorData;
        const h = this.height;
        const detail = this.floorDetail;
        let vCount = 0;
        
        const halfFov = this.fov / 2;
        const dirX = Math.cos(angle), dirY = Math.sin(angle);
        const planeX = Math.cos(angle - Math.PI/2) * Math.tan(halfFov);
        const planeY = Math.sin(angle - Math.PI/2) * Math.tan(halfFov);
        
        // For each horizontal scanline
        for (let screenY = 0; screenY < h; screenY += detail) {
          const isFloor = screenY > h / 2;
          const p = isFloor ? (screenY - h / 2) : (h / 2 - screenY);
          if (p <= 0) continue;
          
          // Distance to this row
          const rowDist = (h * 0.5) / p;
          if (rowDist > this.maxDepth) continue;
          
          // World coordinates at row edges
          const floorStepX = rowDist * (planeX * 2) / this.rayCount;
          const floorStepY = rowDist * (planeY * 2) / this.rayCount;
          
          let floorX = px + rowDist * dirX - rowDist * planeX;
          let floorY = py + rowDist * dirY - rowDist * planeY;
          
          // Shading based on distance
          const shade = Math.max(0.25, 1.0 - rowDist * 0.055);
          const fog = Math.max(0, Math.min(1, (rowDist - 5) * 0.1));
          
          // Screen Y in clip space
          const clipY = 1.0 - (screenY / h) * 2;
          const clipY2 = 1.0 - ((screenY + detail) / h) * 2;
          
          // Build spans for each column that isn't blocked by a wall
          let spanStart = -1;
          let spanTex = -1;
          let spanWorldStartX = 0, spanWorldStartY = 0;
          
          for (let x = 0; x < this.rayCount; x++) {
            const wallTop = this.wallTops[x];
            const wallBottom = this.wallBottoms[x];
            
            // Check if this pixel is visible (not behind wall)
            const blocked = isFloor ? (clipY < wallBottom) : (clipY > wallTop);
            
            // Get sector at this floor position
            const sector = world.getSector(floorX, floorY);
            const visible = vis.isVisible(Math.floor(floorX), Math.floor(floorY));
            const discovered = vis.isDiscovered(Math.floor(floorX), Math.floor(floorY));
            
            const tex = isFloor ? (this.floorTexMap[sector.name] || 13) : (this.ceilTexMap[sector.name] || 17);
            const canDraw = (visible || discovered) && !blocked && sector.walkable;
            
            if (canDraw) {
              if (spanStart < 0 || tex !== spanTex) {
                // End previous span if any
                if (spanStart >= 0) {
                  this._addFloorSpan(data, vCount, spanStart, x, clipY, clipY2, spanWorldStartX, spanWorldStartY, floorX, floorY, spanTex, shade * (visible ? 1.0 : 0.5), fog);
                  vCount += 6;
                }
                // Start new span
                spanStart = x;
                spanTex = tex;
                spanWorldStartX = floorX;
                spanWorldStartY = floorY;
              }
            } else {
              // End span
              if (spanStart >= 0) {
                this._addFloorSpan(data, vCount, spanStart, x, clipY, clipY2, spanWorldStartX, spanWorldStartY, floorX, floorY, spanTex, shade * (visible ? 1.0 : 0.5), fog);
                vCount += 6;
                spanStart = -1;
              }
            }
            
            floorX += floorStepX;
            floorY += floorStepY;
          }
          
          // End final span
          if (spanStart >= 0) {
            this._addFloorSpan(data, vCount, spanStart, this.rayCount, clipY, clipY2, spanWorldStartX, spanWorldStartY, floorX, floorY, spanTex, shade, fog);
            vCount += 6;
          }
        }
        
        return vCount;
      }
      
      _addFloorSpan(data, vCount, x0, x1, y0, y1, wx0, wy0, wx1, wy1, tex, shade, fog) {
        const colW = 2.0 / this.rayCount;
        const clipX0 = -1 + x0 * colW;
        const clipX1 = -1 + x1 * colW;
        
        const vi = vCount * 7;
        // Triangle 1
        data[vi] = clipX0; data[vi+1] = y0; data[vi+2] = wx0; data[vi+3] = wy0; data[vi+4] = tex; data[vi+5] = shade; data[vi+6] = fog;
        data[vi+7] = clipX1; data[vi+8] = y0; data[vi+9] = wx1; data[vi+10] = wy1; data[vi+11] = tex; data[vi+12] = shade; data[vi+13] = fog;
        data[vi+14] = clipX0; data[vi+15] = y1; data[vi+16] = wx0; data[vi+17] = wy0; data[vi+18] = tex; data[vi+19] = shade; data[vi+20] = fog;
        // Triangle 2
        data[vi+21] = clipX1; data[vi+22] = y0; data[vi+23] = wx1; data[vi+24] = wy1; data[vi+25] = tex; data[vi+26] = shade; data[vi+27] = fog;
        data[vi+28] = clipX1; data[vi+29] = y1; data[vi+30] = wx1; data[vi+31] = wy1; data[vi+32] = tex; data[vi+33] = shade; data[vi+34] = fog;
        data[vi+35] = clipX0; data[vi+36] = y1; data[vi+37] = wx0; data[vi+38] = wy0; data[vi+39] = tex; data[vi+40] = shade; data[vi+41] = fog;
      }
      
      _castRay(world, vis, px, py, viewAngle, rayAngle) {
        const step = 0.02;
        const cosA = Math.cos(rayAngle), sinA = Math.sin(rayAngle);
        const cosCorr = Math.cos(rayAngle - viewAngle);
        let x = px, y = py, dist = 0;
        
        while (dist < this.maxDepth) {
          x += cosA * step; y += sinA * step; dist += step;
          const gx = Math.floor(x), gy = Math.floor(y);
          const sector = world.getSector(x, y);
          
          if (!sector.walkable) {
            const visible = vis.isVisible(gx, gy);
            const discovered = vis.isDiscovered(gx, gy);
            if (!visible && !discovered) return null;
            
            const corrDist = dist * cosCorr;
            const wallH = Math.min(2.0, 1.7 / corrDist);
            const hitX = x - gx, hitY = y - gy;
            const isNS = hitX < 0.03 || hitX > 0.97;
            
            return {
              dist: corrDist,
              top: wallH / 2,
              bottom: -wallH / 2,
              u: isNS ? hitY : hitX,
              tex: this.wallTexMap[sector.name] || 3,
              shade: (!visible && discovered) ? Math.max(0.15, 1.0 - corrDist * 0.055) * 0.5 : Math.max(0.3, 1.0 - corrDist * 0.055),
              fog: Math.max(0, Math.min(1, (corrDist - 5) * 0.08)),
              side: isNS ? 1.0 : 0.0
            };
          }
        }
        return null;
      }
    }
    
    // ============ OVERLAY ============
    class OverlayRenderer {
      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
      }
      resize() {
        const c = this.canvas.parentElement;
        this.width = c.clientWidth;
        this.height = c.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
      }
      render() {
        const ctx = this.ctx, w = this.width, h = this.height;
        ctx.clearRect(0, 0, w, h);
        const vig = ctx.createRadialGradient(w/2, h/2, h*0.2, w/2, h/2, h*0.95);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = 'rgba(51,255,51,0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w/2-14, h/2); ctx.lineTo(w/2-5, h/2);
        ctx.moveTo(w/2+5, h/2); ctx.lineTo(w/2+14, h/2);
        ctx.moveTo(w/2, h/2-14); ctx.lineTo(w/2, h/2-5);
        ctx.moveTo(w/2, h/2+5); ctx.lineTo(w/2, h/2+14);
        ctx.stroke();
        ctx.fillStyle = 'rgba(51,255,51,0.9)';
        ctx.beginPath(); ctx.arc(w/2, h/2, 2, 0, Math.PI*2); ctx.fill();
      }
    }
    
    // ============ ENGINE CORE ============
    class World {
      constructor(cfg = {}) {
        this.width = cfg.width || 32;
        this.height = cfg.height || 32;
        this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill('void'));
        this.sectorTypes = new Map();
        this.sectorTypes.set('void', { floor: -10, ceiling: -10, walkable: false, floorColor: [20,20,25], name: 'VOID' });
      }
      registerSectorTypes(t) { for (const [k,v] of Object.entries(t)) this.sectorTypes.set(k, v); }
      getSector(x, y) {
        const gx = Math.floor(x), gy = Math.floor(y);
        if (gx < 0 || gx >= this.width || gy < 0 || gy >= this.height) return this.sectorTypes.get('void');
        return this.sectorTypes.get(this.grid[gy][gx]) || this.sectorTypes.get('void');
      }
      fillRect(x1, y1, x2, y2, type) {
        for (let y = Math.min(y1,y2); y <= Math.max(y1,y2); y++)
          for (let x = Math.min(x1,x2); x <= Math.max(x1,x2); x++)
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) this.grid[y][x] = type;
      }
      countWalkable() { let c = 0; for (let y = 0; y < this.height; y++) for (let x = 0; x < this.width; x++) if (this.getSector(x,y).walkable) c++; return c; }
    }
    
    class Visibility {
      constructor(world, cfg = {}) {
        this.world = world;
        this.viewDistance = cfg.viewDistance || 16;
        this.discovered = new Set();
        this.currentlyVisible = new Set();
        this.totalWalkable = world.countWalkable();
        this.lastCell = null;
      }
      update(x, y) {
        const cell = `${Math.floor(x)},${Math.floor(y)}`;
        if (cell === this.lastCell) return false;
        this.lastCell = cell;
        profiler.start('visibility');
        this.currentlyVisible.clear();
        for (let i = 0; i < 180; i++) {
          const ang = (i / 180) * Math.PI * 2;
          let rx = x, ry = y;
          const dx = Math.cos(ang) * 0.4, dy = Math.sin(ang) * 0.4;
          for (let d = 0; d < this.viewDistance; d += 0.4) {
            rx += dx; ry += dy;
            const k = `${Math.floor(rx)},${Math.floor(ry)}`;
            this.currentlyVisible.add(k);
            const s = this.world.getSector(rx, ry);
            if (s.walkable) this.discovered.add(k);
            if (!s.walkable) break;
          }
        }
        profiler.end('visibility');
        return true;
      }
      isVisible(gx, gy) { return this.currentlyVisible.has(`${gx},${gy}`); }
      isDiscovered(gx, gy) { return this.discovered.has(`${gx},${gy}`); }
      getDiscoveryPercent() { let c = 0; for (const k of this.discovered) { const [x,y] = k.split(',').map(Number); if (this.world.getSector(x,y).walkable) c++; } return Math.round((c / this.totalWalkable) * 100); }
    }
    
    class Movement {
      constructor(world) { this.world = world; }
      move(e, dx, dy) {
        const r = e.radius || 0.2, nx = e.x + dx, ny = e.y + dy;
        if (this._can(nx, ny, r)) return { x: nx, y: ny };
        if (this._can(nx, e.y, r)) return { x: nx, y: e.y };
        if (this._can(e.x, ny, r)) return { x: e.x, y: ny };
        return { x: e.x, y: e.y };
      }
      _can(x, y, r) { for (const [px,py] of [[x,y],[x-r,y-r],[x+r,y-r],[x-r,y+r],[x+r,y+r]]) if (!this.world.getSector(px,py).walkable) return false; return true; }
    }
    
    class Input {
      constructor() { this.keys = {}; this.mouseDX = 0; this.locked = false; }
      init(target) {
        window.addEventListener('keydown', e => { this.keys[e.code] = true; if (['KeyW','KeyA','KeyS','KeyD','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        document.addEventListener('mousemove', e => { if (this.locked) this.mouseDX += e.movementX; });
        document.addEventListener('pointerlockchange', () => { this.locked = document.pointerLockElement === target; document.getElementById('click-prompt').classList.toggle('hidden', this.locked); });
        target.addEventListener('click', () => { if (!this.locked) target.requestPointerLock(); });
      }
      getMovement(dt, speed) {
        let f=0,s=0,t=0;
        if (this.keys['KeyW']||this.keys['ArrowUp']) f+=speed;
        if (this.keys['KeyS']||this.keys['ArrowDown']) f-=speed;
        if (this.keys['KeyA']) s-=speed;
        if (this.keys['KeyD']) s+=speed;
        if (this.keys['ArrowLeft']) t-=2.2*dt;
        if (this.keys['ArrowRight']) t+=2.2*dt;
        if (this.keys['ShiftLeft']||this.keys['ShiftRight']) { f*=1.7; s*=1.7; }
        t+=this.mouseDX*0.002; this.mouseDX=0;
        return { forward:f, strafe:s, turn:t };
      }
    }
    
    class Minimap {
      constructor(cfg={}) { this.fov=cfg.fov||Math.PI*0.6; this.viewDist=cfg.viewDistance||16; }
      init(canvas) { this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.resize(); window.addEventListener('resize',()=>this.resize()); }
      resize() { const c=this.canvas.parentElement; const sz=Math.min(c.clientWidth-16,c.clientHeight-26); this.canvas.width=sz; this.canvas.height=sz; }
      render(world,vis,px,py,angle) {
        profiler.start('minimap');
        const ctx=this.ctx,w=this.canvas.width,h=this.canvas.height;
        const cw=w/world.width,ch=h/world.height;
        ctx.fillStyle='#030305'; ctx.fillRect(0,0,w,h);
        for(let gy=0;gy<world.height;gy++) for(let gx=0;gx<world.width;gx++) {
          const sec=world.getSector(gx,gy),v=vis.isVisible(gx,gy),d=vis.isDiscovered(gx,gy);
          let col; if(!d&&!v) col='#050508'; else if(!sec.walkable) col=v?'#3a3a45':'#1a1a22'; else if(v) { const c=sec.floorColor; col=`rgb(${c[0]*0.75|0},${c[1]*0.75|0},${c[2]*0.75|0})`; } else col='#151518';
          ctx.fillStyle=col; ctx.fillRect(gx*cw,gy*ch,cw+0.5,ch+0.5);
        }
        const mx=px*cw,my=py*ch,cl=this.viewDist*cw;
        ctx.fillStyle='rgba(51,255,51,0.1)'; ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(angle-this.fov/2)*cl,my+Math.sin(angle-this.fov/2)*cl); ctx.arc(mx,my,cl,angle-this.fov/2,angle+this.fov/2); ctx.fill();
        ctx.fillStyle='#33ff33'; ctx.shadowColor='#33ff33'; ctx.shadowBlur=5; ctx.beginPath(); ctx.arc(mx,my,3,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
        ctx.strokeStyle='#33ff33'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(angle)*8,my+Math.sin(angle)*8); ctx.stroke();
        profiler.end('minimap');
      }
    }
    
    // ============ LEVEL ============
    const SECTOR_TYPES = {
      hangar: { floor:0, ceiling:1.4, floorColor:[80,82,88], walkable:true, name:'HANGAR' },
      hangar_platform: { floor:0.2, ceiling:1.4, floorColor:[120,110,85], walkable:true, name:'PLATFORM' },
      corridor: { floor:0, ceiling:1.1, floorColor:[75,78,85], walkable:true, name:'CORRIDOR' },
      zigzag: { floor:0.05, ceiling:1.5, floorColor:[70,90,78], walkable:true, name:'OPS CENTER' },
      computer: { floor:0.1, ceiling:1.2, floorColor:[75,80,100], walkable:true, name:'TERMINAL BAY' },
      outdoor: { floor:-0.1, ceiling:4.0, floorColor:[100,95,80], walkable:true, name:'EXTERIOR' },
      pillar: { floor:0, ceiling:1.5, floorColor:[130,125,118], walkable:false, name:'PILLAR' },
      crate: { floor:0.5, ceiling:1.2, floorColor:[130,105,70], walkable:false, name:'CRATE' }
    };
    
    const REGIONS = [
      { type:'hangar', x1:1, y1:9, x2:7, y2:15 },
      { type:'hangar_platform', x1:4, y1:11, x2:6, y2:13 },
      { type:'corridor', x1:7, y1:11, x2:11, y2:13 },
      { type:'corridor', x1:17, y1:11, x2:19, y2:13 },
      { type:'zigzag', x1:11, y1:7, x2:17, y2:17 },
      { type:'pillar', x1:13, y1:9, x2:13, y2:9 },
      { type:'pillar', x1:15, y1:9, x2:15, y2:9 },
      { type:'pillar', x1:13, y1:15, x2:13, y2:15 },
      { type:'pillar', x1:15, y1:15, x2:15, y2:15 },
      { type:'computer', x1:19, y1:9, x2:23, y2:15 },
      { type:'crate', x1:21, y1:10, x2:22, y2:10 },
      { type:'crate', x1:21, y1:14, x2:21, y2:14 },
      { type:'outdoor', x1:1, y1:1, x2:7, y2:7 },
      { type:'hangar', x1:3, y1:8, x2:5, y2:8 }
    ];
    
    // ============ SETUP ============
    const world = new World({ width:24, height:24 });
    world.registerSectorTypes(SECTOR_TYPES);
    REGIONS.forEach(r => world.fillRect(r.x1, r.y1, r.x2, r.y2, r.type));
    
    const visibility = new Visibility(world, { viewDistance:16 });
    const movement = new Movement(world);
    const input = new Input();
    const renderer = new WebGL2Renderer({ rayCount:400, maxDepth:16 });
    const overlay = new OverlayRenderer();
    const minimap = new Minimap({ viewDistance:16 });
    const player = { x:3.5, y:12.5, angle:0, radius:0.2, speed:3.0 };
    
    renderer.init(document.getElementById('game-canvas'));
    overlay.init(document.getElementById('overlay-canvas'));
    minimap.init(document.getElementById('minimap-canvas'));
    input.init(document.getElementById('viewport'));
    visibility.update(player.x, player.y);
    
    // Perf graph
    const graphCanvas = document.getElementById('graph-canvas');
    const graphCtx = graphCanvas.getContext('2d');
    function drawPerfGraph() {
      const w=graphCanvas.width=graphCanvas.parentElement.clientWidth, h=graphCanvas.height=40;
      const hist=profiler.getHistory('frame');
      graphCtx.fillStyle='#0a0a0c'; graphCtx.fillRect(0,0,w,h);
      graphCtx.strokeStyle='#1a3a1a'; graphCtx.beginPath(); graphCtx.moveTo(0,h-(16.67/40)*h); graphCtx.lineTo(w,h-(16.67/40)*h); graphCtx.stroke();
      if(hist.length<2) return;
      graphCtx.strokeStyle='#33ff33'; graphCtx.lineWidth=1; graphCtx.beginPath();
      const step=w/(hist.length-1);
      for(let i=0;i<hist.length;i++) { const x=i*step, y=h-Math.min(1,hist[i]/40)*h; if(i===0) graphCtx.moveTo(x,y); else graphCtx.lineTo(x,y); }
      graphCtx.stroke();
    }
    
    // Sliders
    document.getElementById('tune-rays').addEventListener('input', e => { renderer.setRayCount(parseInt(e.target.value)); document.getElementById('tune-rays-val').textContent=e.target.value; });
    document.getElementById('tune-viewdist').addEventListener('input', e => { renderer.setViewDist(parseInt(e.target.value)); visibility.viewDistance=parseInt(e.target.value); document.getElementById('tune-viewdist-val').textContent=e.target.value; });
    document.getElementById('tune-floordetail').addEventListener('input', e => { renderer.setFloorDetail(parseInt(e.target.value)); document.getElementById('tune-floordetail-val').textContent=e.target.value; });
    
    function showMessage(t) { const log=document.getElementById('messages'), msg=document.createElement('div'); msg.className='message'; msg.textContent=t; log.appendChild(msg); setTimeout(()=>msg.remove(),2500); }
    
    // Game loop
    let lastTime=0, uiTimer=0;
    function gameLoop(time) {
      profiler.start('frame');
      const dt=Math.min((time-lastTime)/1000,0.1); lastTime=time;
      
      const move=input.getMovement(dt,player.speed*dt);
      player.angle+=move.turn;
      while(player.angle<0) player.angle+=Math.PI*2;
      while(player.angle>=Math.PI*2) player.angle-=Math.PI*2;
      
      const fx=Math.cos(player.angle),fy=Math.sin(player.angle);
      const sx=Math.cos(player.angle+Math.PI/2),sy=Math.sin(player.angle+Math.PI/2);
      const dx=fx*move.forward+sx*move.strafe, dy=fy*move.forward+sy*move.strafe;
      if(dx!==0||dy!==0) { const res=movement.move(player,dx,dy); player.x=res.x; player.y=res.y; }
      
      visibility.update(player.x,player.y);
      renderer.render(world,visibility,player.x,player.y,player.angle);
      overlay.render();
      minimap.render(world,visibility,player.x,player.y,player.angle);
      
      profiler.end('frame');
      
      uiTimer+=dt;
      if(uiTimer>0.1) {
        uiTimer=0;
        const frame=profiler.getAvg('frame'), fps=frame>0?1000/frame:0;
        const fpsEl=document.getElementById('stat-fps');
        fpsEl.textContent=fps.toFixed(0);
        fpsEl.className='stat-value'+(fps>=55?'':fps>=30?' warn':' bad');
        document.getElementById('stat-frame').textContent=frame.toFixed(1)+'ms';
        document.getElementById('stat-draws').textContent=renderer.drawCalls;
        document.getElementById('stat-sector').textContent=world.getSector(player.x,player.y).name||'--';
        document.getElementById('perf-frame').textContent=frame.toFixed(2)+'ms';
        document.getElementById('perf-walls').textContent=profiler.getAvg('walls').toFixed(2)+'ms';
        document.getElementById('perf-floors').textContent=profiler.getAvg('floors').toFixed(2)+'ms';
        document.getElementById('perf-visibility').textContent=profiler.getAvg('visibility').toFixed(2)+'ms';
        document.getElementById('perf-minimap').textContent=profiler.getAvg('minimap').toFixed(2)+'ms';
        document.getElementById('perf-tris').textContent=renderer.triangleCount;
        const barFill=document.getElementById('bar-frame'), pct=Math.min(100,(frame/33.33)*100);
        barFill.style.width=pct+'%';
        barFill.className='perf-bar-fill'+(frame<16.67?'':frame<33.33?' warn':' bad');
        drawPerfGraph();
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    showMessage('SECTOR ENGINE - Textured Floors & Ceilings');
    showMessage('Full 2.5D rendering with horizontal surfaces');
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
