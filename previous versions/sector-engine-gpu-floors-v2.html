<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sector Engine - GPU Floors & Ceilings</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0c;
      color: #33ff33;
      font-family: 'Share Tech Mono', monospace;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    #header {
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border-bottom: 2px solid #33ff33;
      padding: 8px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      letter-spacing: 3px;
    }
    
    .tag { font-size: 0.5rem; color: #33aa33; margin-left: 8px; letter-spacing: 2px; background: rgba(51,255,51,0.1); padding: 2px 6px; border-radius: 3px; }
    
    #stats { display: flex; gap: 16px; font-size: 0.7rem; }
    .stat { display: flex; flex-direction: column; align-items: center; }
    .stat-label { color: #555; font-size: 0.55rem; letter-spacing: 1px; }
    .stat-value { color: #33ff33; }
    .stat-value.warn { color: #ffaa33; }
    .stat-value.bad { color: #ff5533; }
    
    #main { flex: 1; display: flex; padding: 8px; min-height: 0; gap: 8px; }
    
    #viewport {
      flex: 2;
      position: relative;
      border: 2px solid #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
      background: #000;
    }
    
    #game-canvas { width: 100%; height: 100%; display: block; }
    #overlay-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    
    #click-prompt {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9); border: 1px solid #33ff33;
      padding: 14px 28px; text-align: center; cursor: pointer; z-index: 10;
    }
    #click-prompt:hover { background: rgba(51,255,51,0.1); }
    #click-prompt.hidden { display: none; }
    #click-prompt h2 { font-family: 'Orbitron', sans-serif; font-size: 0.85rem; letter-spacing: 2px; }
    #click-prompt p { font-size: 0.65rem; color: #888; margin-top: 5px; }
    
    #sidebar { width: 260px; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; }
    
    .panel { background: #0f0f12; border: 1px solid #222; border-radius: 4px; padding: 8px; }
    .panel-title { font-family: 'Orbitron', sans-serif; font-size: 0.6rem; letter-spacing: 2px; color: #444; margin-bottom: 6px; }
    
    #minimap-panel { flex: 0 0 auto; height: 170px; display: flex; flex-direction: column; }
    #minimap-canvas { flex: 1; width: 100%; border: 1px solid #1a1a1a; background: #030305; }
    
    .perf-row { display: flex; justify-content: space-between; font-size: 0.65rem; color: #666; margin-bottom: 3px; }
    .perf-value { color: #33ff33; min-width: 55px; text-align: right; }
    .perf-value.warn { color: #ffaa33; }
    .perf-value.bad { color: #ff5533; }
    
    .perf-bar { height: 4px; background: #1a1a1a; margin: 2px 0 6px 0; border-radius: 2px; overflow: hidden; }
    .perf-bar-fill { height: 100%; background: #33ff33; transition: width 0.1s; }
    .perf-bar-fill.warn { background: #ffaa33; }
    .perf-bar-fill.bad { background: #ff5533; }
    
    #perf-graph { height: 40px; background: #0a0a0c; border: 1px solid #1a1a1a; margin-top: 6px; }
    #perf-graph canvas { width: 100%; height: 100%; }
    
    .slider-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.6rem; color: #888; margin-bottom: 4px; }
    .slider-row input[type="range"] { width: 70px; height: 4px; -webkit-appearance: none; background: #1a1a1a; border-radius: 2px; }
    .slider-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; background: #33ff33; border-radius: 50%; cursor: pointer; }
    .slider-value { color: #33ff33; min-width: 35px; text-align: right; }
    
    .control-row { display: flex; justify-content: space-between; font-size: 0.6rem; color: #888; margin-bottom: 3px; }
    .key { background: #1a1a1f; border: 1px solid #2a2a2a; padding: 1px 4px; border-radius: 2px; color: #33ff33; font-size: 0.55rem; }
    
    #messages { position: absolute; bottom: 10px; left: 10px; max-width: 280px; z-index: 5; }
    .message { background: rgba(0,0,0,0.85); border-left: 2px solid #33ff33; padding: 4px 8px; margin-bottom: 2px; font-size: 0.7rem; animation: msgIn 0.2s ease-out, msgOut 0.3s ease-in 2s forwards; }
    @keyframes msgIn { from { opacity: 0; transform: translateX(-10px); } }
    @keyframes msgOut { to { opacity: 0; } }
  </style>
</head>
<body>
  <div id="header">
    <h1>SECTOR ENGINE <span class="tag">GPU FLOORS v2</span></h1>
    <div id="stats">
      <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="stat-fps">--</span></div>
      <div class="stat"><span class="stat-label">FRAME</span><span class="stat-value" id="stat-frame">--</span></div>
      <div class="stat"><span class="stat-label">DRAWS</span><span class="stat-value" id="stat-draws">--</span></div>
      <div class="stat"><span class="stat-label">SECTOR</span><span class="stat-value" id="stat-sector">--</span></div>
    </div>
  </div>
  
  <div id="main">
    <div id="viewport">
      <canvas id="game-canvas"></canvas>
      <canvas id="overlay-canvas"></canvas>
      <div id="click-prompt"><h2>CLICK TO ENGAGE</h2><p>GPU Textured Floors & Ceilings</p></div>
      <div id="messages"></div>
    </div>
    
    <div id="sidebar">
      <div class="panel" id="minimap-panel">
        <div class="panel-title">TACTICAL MAP</div>
        <canvas id="minimap-canvas"></canvas>
      </div>
      
      <div class="panel">
        <div class="panel-title">‚ö° PERFORMANCE</div>
        <div class="perf-row"><span>Frame Total</span><span class="perf-value" id="perf-frame">--</span></div>
        <div class="perf-bar"><div class="perf-bar-fill" id="bar-frame"></div></div>
        <div class="perf-row"><span>‚îú CPU Raycast</span><span class="perf-value" id="perf-raycast">--</span></div>
        <div class="perf-row"><span>‚îú GPU Render</span><span class="perf-value" id="perf-gpu">--</span></div>
        <div class="perf-row"><span>‚îú Visibility</span><span class="perf-value" id="perf-visibility">--</span></div>
        <div class="perf-row"><span>‚îî Minimap</span><span class="perf-value" id="perf-minimap">--</span></div>
        <div class="perf-row" style="margin-top:4px;border-top:1px solid #1a1a1a;padding-top:4px;">
          <span>Triangles</span><span class="perf-value" id="perf-tris">--</span>
        </div>
        <div id="perf-graph"><canvas id="graph-canvas"></canvas></div>
      </div>
      
      <div class="panel">
        <div class="panel-title">üéõÔ∏è TUNING</div>
        <div class="slider-row"><span>Ray Count</span><input type="range" id="tune-rays" min="200" max="640" value="400"><span class="slider-value" id="tune-rays-val">400</span></div>
        <div class="slider-row"><span>View Dist</span><input type="range" id="tune-viewdist" min="10" max="24" value="16"><span class="slider-value" id="tune-viewdist-val">16</span></div>
      </div>
      
      <div class="panel">
        <div class="panel-title">CONTROLS</div>
        <div class="control-row"><span>Move</span><span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></span></div>
        <div class="control-row"><span>Look</span><span>Mouse / <span class="key">‚Üê</span><span class="key">‚Üí</span></span></div>
        <div class="control-row"><span>Run</span><span><span class="key">Shift</span></span></div>
      </div>
    </div>
  </div>

  <script>
    // =========================================================
    // SECTOR ENGINE - GPU FLOORS & CEILINGS v2
    // Floor/ceiling rendering done entirely in fragment shader
    // =========================================================
    
    class Profiler {
      constructor() { this.timings = {}; this.history = {}; this.maxHistory = 100; }
      start(n) { this.timings[n] = performance.now(); }
      end(n) { if (!this.timings[n]) return 0; const d = performance.now() - this.timings[n]; if (!this.history[n]) this.history[n] = []; this.history[n].push(d); if (this.history[n].length > this.maxHistory) this.history[n].shift(); return d; }
      getAvg(n) { const h = this.history[n]; return h?.length ? h.reduce((a,b)=>a+b,0)/h.length : 0; }
      getHistory(n) { return this.history[n] || []; }
    }
    const profiler = new Profiler();
    
    // ============ TEXTURE GENERATOR ============
    class TextureGenerator {
      constructor(size = 64) { this.size = size; }
      
      _noise(x, y, seed = 0) { const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453; return n - Math.floor(n); }
      _fbm(x, y, oct = 4, seed = 0) { let v = 0, a = 0.5, f = 1; for (let i = 0; i < oct; i++) { v += a * this._noise(x*f, y*f, seed+i*100); a *= 0.5; f *= 2; } return v; }
      
      generate(fn, ...args) {
        const s = this.size, data = new Uint8Array(s * s * 4);
        for (let y = 0; y < s; y++) {
          for (let x = 0; x < s; x++) {
            const [r, g, b] = fn.call(this, x, y, s, ...args);
            const i = (y * s + x) * 4;
            data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = 255;
          }
        }
        return data;
      }
      
      metalPanels(x, y, s, base, seed) {
        const grid = (x % 16 < 2) || (y % 16 < 2);
        const rivet = (x % 16 >= 6 && x % 16 <= 9) && (y % 16 <= 2 || y % 16 >= 13);
        const hl = (x % 16 >= 2 && x % 16 <= 4) && (y % 16 >= 2 && y % 16 <= 4);
        const n = this._fbm(x/6, y/6, 3, seed) * 40 - 20;
        let r = base[0]+n, g = base[1]+n, b = base[2]+n;
        if (grid) { r -= 50; g -= 50; b -= 45; } else if (hl) { r += 40; g += 40; b += 50; }
        if (rivet) { r += 55; g += 55; b += 65; }
        return [Math.max(0,Math.min(255,r)), Math.max(0,Math.min(255,g)), Math.max(0,Math.min(255,b))];
      }
      
      techWall(x, y, s, base, seed) {
        let r = base[0]*0.5, g = base[1]*0.5, b = base[2]*0.5;
        const lineH = y % 10 < 2, lineV = x % 14 < 2;
        const node = (x % 14 < 4) && (y % 10 < 4);
        const traceH = y % 10 === 5 && this._noise(Math.floor(x/7), y, seed) > 0.4;
        const traceV = x % 14 === 7 && this._noise(x, Math.floor(y/5), seed+50) > 0.4;
        if (lineH || lineV) { r += 35; g += 40; b += 55; }
        if (node) { g += 70; b += 95; }
        if (traceH || traceV) { r += 30; g += 100; b += 130; }
        const n = this._noise(x, y, seed) * 12 - 6;
        return [Math.max(0,Math.min(255,r+n)), Math.max(0,Math.min(255,g+n)), Math.max(0,Math.min(255,b+n))];
      }
      
      concrete(x, y, s, base, seed) {
        const n1 = this._fbm(x/4, y/4, 4, seed) * 70 - 35;
        const n2 = this._fbm(x/12, y/12, 2, seed+100) * 35 - 17;
        const crack = this._noise(x/3, y/3, seed+200) > 0.92 ? -45 : 0;
        const t = n1 + n2 + crack;
        return [Math.max(0,Math.min(255,base[0]+t)), Math.max(0,Math.min(255,base[1]+t)), Math.max(0,Math.min(255,base[2]+t))];
      }
      
      grating(x, y, s, base, seed) {
        const cx = x % 8, cy = y % 8;
        const diamond = Math.abs(cx - 3.5) + Math.abs(cy - 3.5) < 3;
        if (diamond) return [12, 15, 20];
        const hl = cx < 3.5 || cy < 3.5;
        const n = this._noise(x, y, seed) * 18 - 9;
        return [Math.max(0,Math.min(255,(hl?base[0]+45:base[0])+n)), Math.max(0,Math.min(255,(hl?base[1]+45:base[1])+n)), Math.max(0,Math.min(255,(hl?base[2]+55:base[2])+n))];
      }
      
      brick(x, y, s, base, seed) {
        const row = Math.floor(y / 8), ox = (row % 2) * 8;
        const bx = (x + ox) % 16, by = y % 8;
        const mortar = bx < 2 || by < 2;
        if (mortar) { const n = this._noise(x,y,seed)*18; return [55+n, 52+n, 48+n]; }
        const bid = Math.floor((x+ox)/16) + row*1000;
        const bv = (this._noise(bid, 0, seed) - 0.5) * 60;
        const sn = this._noise(x*2, y*2, seed+300) * 28 - 14;
        return [Math.max(0,Math.min(255,base[0]+bv+sn)), Math.max(0,Math.min(255,base[1]+bv*0.8+sn)), Math.max(0,Math.min(255,base[2]+bv*0.6+sn))];
      }
      
      crate(x, y, s, base, seed) {
        const grain = Math.sin(y*0.6 + this._noise(x/15, y/4, seed)*8) * 22;
        const border = x < 6 || x >= s-6 || y < 6 || y >= s-6;
        const inner = (x >= 6 && x < 10) || (x >= s-10 && x < s-6) || (y >= 6 && y < 10) || (y >= s-10 && y < s-6);
        const d1 = Math.abs((x-s/2)-(y-s/2)) < 4, d2 = Math.abs((x-s/2)+(y-s/2)) < 4;
        const cross = (d1||d2) && !border;
        let r = base[0]+grain, g = base[1]+grain*0.9, b = base[2]+grain*0.7;
        if (border) { r += 40; g += 35; b += 25; }
        if (inner && border) { r -= 30; g -= 26; b -= 20; }
        if (cross) { r += 35; g += 30; b += 22; }
        const n = this._noise(x, y, seed) * 20 - 10;
        return [Math.max(0,Math.min(255,r+n)), Math.max(0,Math.min(255,g+n*0.9)), Math.max(0,Math.min(255,b+n*0.7))];
      }
      
      pillar(x, y, s, base, seed) {
        const streak = this._noise(x/4, 0, seed) * 28 - 14;
        const n = this._fbm(x/8, y/8, 3, seed+100) * 22 - 11;
        const band = (y % 32 < 2) ? -25 : 0;
        const t = streak + n + band;
        return [Math.max(0,Math.min(255,base[0]+t)), Math.max(0,Math.min(255,base[1]+t)), Math.max(0,Math.min(255,base[2]+t))];
      }
      
      // Floor textures
      tileFloor(x, y, s, base, seed) {
        const tx = x % 16, ty = y % 16;
        const grout = tx < 1 || ty < 1;
        const n = this._noise(x, y, seed) * 20 - 10;
        if (grout) return [40+n, 42+n, 45+n];
        const tv = this._noise(Math.floor(x/16), Math.floor(y/16), seed+100) * 30 - 15;
        return [Math.max(0,Math.min(255,base[0]+tv+n)), Math.max(0,Math.min(255,base[1]+tv+n)), Math.max(0,Math.min(255,base[2]+tv+n))];
      }
      
      metalFloor(x, y, s, base, seed) {
        const px = x % 8, py = y % 8;
        const diamond = (px + py) % 8 < 2 || Math.abs(px - py) % 8 < 2;
        const n = this._noise(x, y, seed) * 15 - 7;
        let r = base[0], g = base[1], b = base[2];
        if (diamond) { r += 25; g += 25; b += 30; }
        return [Math.max(0,Math.min(255,r+n)), Math.max(0,Math.min(255,g+n)), Math.max(0,Math.min(255,b+n))];
      }
      
      dirtFloor(x, y, s, base, seed) {
        const n1 = this._fbm(x/3, y/3, 4, seed) * 50 - 25;
        const n2 = this._fbm(x/8, y/8, 2, seed+50) * 25 - 12;
        const pebble = this._noise(x*3, y*3, seed+100) > 0.9 ? 20 : 0;
        const t = n1 + n2 + pebble;
        return [Math.max(0,Math.min(255,base[0]+t)), Math.max(0,Math.min(255,base[1]+t*0.9)), Math.max(0,Math.min(255,base[2]+t*0.7))];
      }
      
      // Ceiling textures
      ceilingPanels(x, y, s, base, seed) {
        const px = x % 32, py = y % 32;
        const frame = px < 2 || py < 2 || px > 29 || py > 29;
        const n = this._noise(x, y, seed) * 12 - 6;
        if (frame) return [Math.max(0,base[0]-30+n), Math.max(0,base[1]-30+n), Math.max(0,base[2]-25+n)];
        const pn = this._fbm(x/6, y/6, 2, seed+100) * 20 - 10;
        return [Math.max(0,Math.min(255,base[0]+pn+n)), Math.max(0,Math.min(255,base[1]+pn+n)), Math.max(0,Math.min(255,base[2]+pn+n))];
      }
      
      techCeiling(x, y, s, base, seed) {
        const beam = (x % 24 < 3) || (y % 24 < 3);
        const light = (x % 24 > 8 && x % 24 < 16) && (y % 24 > 8 && y % 24 < 16);
        const n = this._noise(x, y, seed) * 10 - 5;
        let r = base[0], g = base[1], b = base[2];
        if (beam) { r -= 20; g -= 20; b -= 15; }
        if (light) { r += 50; g += 60; b += 80; }
        return [Math.max(0,Math.min(255,r+n)), Math.max(0,Math.min(255,g+n)), Math.max(0,Math.min(255,b+n))];
      }
      
      skyCeiling(x, y, s, base, seed) {
        const star = this._noise(x*5, y*5, seed) > 0.97;
        const n = this._noise(x, y, seed+50) * 8 - 4;
        if (star) { const b = this._noise(x, y, seed+100) * 155 + 100; return [b, b, b+20]; }
        return [Math.max(0,base[0]+n), Math.max(0,base[1]+n), Math.max(0,base[2]+n)];
      }
    }
    
    // ============ WEBGL2 RENDERER ============
    class WebGL2Renderer {
      constructor(config = {}) {
        this.rayCount = config.rayCount || 400;
        this.fov = config.fov || Math.PI * 0.6;
        this.maxDepth = config.maxDepth || 16;
        this.texGen = new TextureGenerator(64);
        this.drawCalls = 0;
        this.triangleCount = 0;
      }
      
      init(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl2', { antialias: false, alpha: false });
        if (!this.gl) { console.error('WebGL2 not supported'); return false; }
        
        this._initWallProgram();
        this._initFloorProgram();
        this._initBuffers();
        this._initTextures();
        this._initWorldTexture();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        return true;
      }
      
      resize() {
        const c = this.canvas.parentElement;
        this.width = c.clientWidth;
        this.height = c.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.gl.viewport(0, 0, this.width, this.height);
      }
      
      _compile(type, src) {
        const gl = this.gl, s = gl.createShader(type);
        gl.shaderSource(s, src); gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
        return s;
      }
      
      _program(vs, fs) {
        const gl = this.gl, p = gl.createProgram();
        gl.attachShader(p, this._compile(gl.VERTEX_SHADER, vs));
        gl.attachShader(p, this._compile(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
        return p;
      }
      
      _initWallProgram() {
        const vs = `#version 300 es
          in vec2 aPos; in vec2 aUV; in float aTex; in float aShade; in float aFog; in float aSide;
          out vec2 vUV; flat out int vTex; out float vShade; out float vFog; out float vSide;
          void main() { gl_Position = vec4(aPos, 0.0, 1.0); vUV = aUV; vTex = int(aTex); vShade = aShade; vFog = aFog; vSide = aSide; }
        `;
        const fs = `#version 300 es
          precision highp float; precision highp sampler2DArray;
          in vec2 vUV; flat in int vTex; in float vShade; in float vFog; in float vSide;
          uniform sampler2DArray uTex;
          out vec4 fragColor;
          void main() {
            vec3 c = texture(uTex, vec3(fract(vUV), float(vTex))).rgb;
            c *= mix(1.0, 0.75, vSide) * vShade;
            c = mix(c, vec3(0.07, 0.085, 0.11), vFog);
            fragColor = vec4(c, 1.0);
          }
        `;
        this.wallProg = this._program(vs, fs);
        const gl = this.gl;
        this.wallAttr = { pos: gl.getAttribLocation(this.wallProg, 'aPos'), uv: gl.getAttribLocation(this.wallProg, 'aUV'), tex: gl.getAttribLocation(this.wallProg, 'aTex'), shade: gl.getAttribLocation(this.wallProg, 'aShade'), fog: gl.getAttribLocation(this.wallProg, 'aFog'), side: gl.getAttribLocation(this.wallProg, 'aSide') };
        this.wallUni = { tex: gl.getUniformLocation(this.wallProg, 'uTex') };
      }
      
      _initFloorProgram() {
        // Floor/ceiling rendered via fullscreen quad, raycasting in shader
        const vs = `#version 300 es
          in vec2 aPos;
          out vec2 vScreenPos;
          void main() { gl_Position = vec4(aPos, 0.0, 1.0); vScreenPos = aPos; }
        `;
        const fs = `#version 300 es
          precision highp float;
          precision highp sampler2DArray;
          precision highp sampler2D;
          
          in vec2 vScreenPos;
          
          uniform sampler2DArray uTex;
          uniform sampler2D uWallDist;     // Wall distances per column
          uniform sampler2D uWorldMap;     // World grid (sector indices)
          uniform vec2 uPlayerPos;
          uniform float uPlayerAngle;
          uniform float uFov;
          uniform float uMaxDist;
          uniform vec2 uResolution;
          uniform int uRayCount;
          
          out vec4 fragColor;
          
          // Floor texture indices per sector type
          int getFloorTex(int sectorType) {
            if (sectorType == 1) return 10; // HANGAR - metal floor
            if (sectorType == 2) return 10; // PLATFORM - metal floor
            if (sectorType == 3) return 11; // CORRIDOR - grating
            if (sectorType == 4) return 9;  // OPS CENTER - tile
            if (sectorType == 5) return 15; // TERMINAL BAY - tech
            if (sectorType == 6) return 12; // EXTERIOR - dirt
            return 13; // default concrete
          }
          
          // Ceiling texture indices per sector type
          int getCeilTex(int sectorType) {
            if (sectorType == 1) return 14; // HANGAR - panels
            if (sectorType == 2) return 14; // PLATFORM - panels
            if (sectorType == 3) return 15; // CORRIDOR - tech
            if (sectorType == 4) return 14; // OPS CENTER - panels
            if (sectorType == 5) return 15; // TERMINAL BAY - tech
            if (sectorType == 6) return 16; // EXTERIOR - sky
            return 17; // default concrete
          }
          
          void main() {
            vec2 screenUV = vScreenPos * 0.5 + 0.5;
            float screenY = screenUV.y;
            float screenX = screenUV.x;
            
            bool isFloor = screenY < 0.5;
            float p = isFloor ? (0.5 - screenY) : (screenY - 0.5);
            
            if (p < 0.001) {
              fragColor = vec4(0.07, 0.085, 0.11, 1.0);
              return;
            }
            
            // Distance to this row
            float rowDist = 0.5 / p;
            if (rowDist > uMaxDist) {
              fragColor = vec4(0.07, 0.085, 0.11, 1.0);
              return;
            }
            
            // Get wall distance for this column
            // Wall distance texture is sized to rayCount, sample at correct position
            float wallDistU = screenX * float(uRayCount) / 1024.0;
            float wallDist = texture(uWallDist, vec2(wallDistU, 0.5)).r;
            
            // Check if floor/ceiling is behind wall
            if (rowDist > wallDist) {
              discard;
            }
            
            // Calculate world position using proper ray angle for this screen column
            float rayAngle = uPlayerAngle + (screenX - 0.5) * uFov;
            float worldX = uPlayerPos.x + rowDist * cos(rayAngle);
            float worldY = uPlayerPos.y + rowDist * sin(rayAngle);
            
            // Sample world map to get sector type
            vec2 mapUV = vec2(worldX / 24.0, worldY / 24.0);
            if (mapUV.x < 0.0 || mapUV.x > 1.0 || mapUV.y < 0.0 || mapUV.y > 1.0) {
              fragColor = vec4(0.07, 0.085, 0.11, 1.0);
              return;
            }
            
            float sectorVal = texture(uWorldMap, mapUV).r * 255.0;
            int sectorType = int(sectorVal + 0.5);
            
            // Non-walkable sectors (0 = void, 7+ = walls)
            if (sectorType == 0 || sectorType >= 7) {
              fragColor = vec4(0.07, 0.085, 0.11, 1.0);
              return;
            }
            
            // Get texture index
            int texIdx = isFloor ? getFloorTex(sectorType) : getCeilTex(sectorType);
            
            // Sample texture
            vec2 texUV = fract(vec2(worldX, worldY));
            vec3 color = texture(uTex, vec3(texUV, float(texIdx))).rgb;
            
            // Distance shading
            float shade = max(0.25, 1.0 - rowDist * 0.055);
            color *= shade;
            
            // Fog
            float fog = clamp((rowDist - 5.0) * 0.1, 0.0, 1.0);
            color = mix(color, vec3(0.07, 0.085, 0.11), fog);
            
            fragColor = vec4(color, 1.0);
          }
        `;
        this.floorProg = this._program(vs, fs);
        const gl = this.gl;
        this.floorAttr = { pos: gl.getAttribLocation(this.floorProg, 'aPos') };
        this.floorUni = {
          tex: gl.getUniformLocation(this.floorProg, 'uTex'),
          wallDist: gl.getUniformLocation(this.floorProg, 'uWallDist'),
          worldMap: gl.getUniformLocation(this.floorProg, 'uWorldMap'),
          playerPos: gl.getUniformLocation(this.floorProg, 'uPlayerPos'),
          playerAngle: gl.getUniformLocation(this.floorProg, 'uPlayerAngle'),
          fov: gl.getUniformLocation(this.floorProg, 'uFov'),
          maxDist: gl.getUniformLocation(this.floorProg, 'uMaxDist'),
          resolution: gl.getUniformLocation(this.floorProg, 'uResolution'),
          rayCount: gl.getUniformLocation(this.floorProg, 'uRayCount')
        };
      }
      
      _initBuffers() {
        const gl = this.gl;
        
        // Wall VAO
        this.wallVAO = gl.createVertexArray();
        gl.bindVertexArray(this.wallVAO);
        this.wallBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.wallBuf);
        const stride = 8 * 4;
        gl.enableVertexAttribArray(this.wallAttr.pos); gl.vertexAttribPointer(this.wallAttr.pos, 2, gl.FLOAT, false, stride, 0);
        gl.enableVertexAttribArray(this.wallAttr.uv); gl.vertexAttribPointer(this.wallAttr.uv, 2, gl.FLOAT, false, stride, 8);
        gl.enableVertexAttribArray(this.wallAttr.tex); gl.vertexAttribPointer(this.wallAttr.tex, 1, gl.FLOAT, false, stride, 16);
        gl.enableVertexAttribArray(this.wallAttr.shade); gl.vertexAttribPointer(this.wallAttr.shade, 1, gl.FLOAT, false, stride, 20);
        gl.enableVertexAttribArray(this.wallAttr.fog); gl.vertexAttribPointer(this.wallAttr.fog, 1, gl.FLOAT, false, stride, 24);
        gl.enableVertexAttribArray(this.wallAttr.side); gl.vertexAttribPointer(this.wallAttr.side, 1, gl.FLOAT, false, stride, 28);
        
        // Floor VAO (fullscreen quad)
        this.floorVAO = gl.createVertexArray();
        gl.bindVertexArray(this.floorVAO);
        this.floorBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.floorBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(this.floorAttr.pos);
        gl.vertexAttribPointer(this.floorAttr.pos, 2, gl.FLOAT, false, 0, 0);
        
        gl.bindVertexArray(null);
        
        this.wallData = new Float32Array(800 * 6 * 8);
        this.wallDistData = new Float32Array(1024); // Store wall distances for floor shader
      }
      
      _initTextures() {
        const gl = this.gl, tg = this.texGen, s = 64;
        
        const textures = [
          tg.generate(tg.metalPanels, [120,125,135], 42),   // 0
          tg.generate(tg.metalPanels, [150,135,95], 43),    // 1
          tg.generate(tg.techWall, [70,85,110], 44),        // 2
          tg.generate(tg.concrete, [100,100,105], 45),      // 3
          tg.generate(tg.concrete, [85,110,90], 46),        // 4
          tg.generate(tg.brick, [145,95,75], 47),           // 5
          tg.generate(tg.grating, [110,115,125], 48),       // 6
          tg.generate(tg.crate, [160,130,85], 49),          // 7
          tg.generate(tg.pillar, [150,148,145], 50),        // 8
          // Floors
          tg.generate(tg.tileFloor, [70,72,78], 60),        // 9
          tg.generate(tg.metalFloor, [85,88,95], 61),       // 10
          tg.generate(tg.grating, [90,95,105], 62),         // 11
          tg.generate(tg.dirtFloor, [110,95,70], 63),       // 12
          tg.generate(tg.concrete, [75,78,82], 64),         // 13
          // Ceilings
          tg.generate(tg.ceilingPanels, [55,58,65], 70),    // 14
          tg.generate(tg.techCeiling, [50,55,65], 71),      // 15
          tg.generate(tg.skyCeiling, [15,18,28], 72),       // 16
          tg.generate(tg.concrete, [60,62,68], 73),         // 17
        ];
        
        this.texAtlas = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texAtlas);
        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, gl.RGBA, s, s, textures.length, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        for (let i = 0; i < textures.length; i++) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, s, s, 1, gl.RGBA, gl.UNSIGNED_BYTE, textures[i]);
        }
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
        
        // Wall distance texture (1D, stores distance per column)
        this.wallDistTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.wallDistTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, 1024, 1, 0, gl.RED, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        
        this.wallTexMap = { 'HANGAR': 0, 'PLATFORM': 1, 'TERMINAL BAY': 2, 'VOID': 3, 'OPS CENTER': 4, 'EXTERIOR': 5, 'CORRIDOR': 6, 'CRATE': 7, 'PILLAR': 8 };
      }
      
      _initWorldTexture() {
        // Create world map texture - stores sector type per cell
        const gl = this.gl;
        this.worldMapTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.worldMapTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, 24, 24, 0, gl.RED, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }
      
      updateWorldMap(world) {
        // Upload world grid to GPU
        const gl = this.gl;
        const data = new Uint8Array(24 * 24);
        const typeMap = { 'void': 0, 'hangar': 1, 'hangar_platform': 2, 'corridor': 3, 'zigzag': 4, 'computer': 5, 'outdoor': 6, 'pillar': 7, 'crate': 8 };
        for (let y = 0; y < 24; y++) {
          for (let x = 0; x < 24; x++) {
            const type = world.grid[y][x];
            data[y * 24 + x] = typeMap[type] || 0;
          }
        }
        gl.bindTexture(gl.TEXTURE_2D, this.worldMapTex);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 24, 24, gl.RED, gl.UNSIGNED_BYTE, data);
      }
      
      setRayCount(n) { this.rayCount = n; }
      setViewDist(d) { this.maxDepth = d; }
      
      render(world, vis, px, py, angle) {
        profiler.start('raycast');
        
        const gl = this.gl;
        gl.clearColor(0.07, 0.085, 0.11, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Build wall geometry and collect distances
        const colW = 2.0 / this.rayCount;
        let wallVerts = 0;
        const data = this.wallData;
        
        for (let i = 0; i < this.rayCount; i++) {
          const rayAngle = angle + ((i / this.rayCount) - 0.5) * this.fov;
          const hit = this._castRay(world, vis, px, py, angle, rayAngle);
          
          // Store wall distance for floor shader
          this.wallDistData[i] = hit ? hit.dist : this.maxDepth;
          
          if (hit) {
            const x0 = -1 + i * colW, x1 = x0 + colW;
            const vi = wallVerts * 8;
            data[vi] = x0; data[vi+1] = hit.top; data[vi+2] = hit.u; data[vi+3] = 0; data[vi+4] = hit.tex; data[vi+5] = hit.shade; data[vi+6] = hit.fog; data[vi+7] = hit.side;
            data[vi+8] = x1; data[vi+9] = hit.top; data[vi+10] = hit.u; data[vi+11] = 0; data[vi+12] = hit.tex; data[vi+13] = hit.shade; data[vi+14] = hit.fog; data[vi+15] = hit.side;
            data[vi+16] = x0; data[vi+17] = hit.bottom; data[vi+18] = hit.u; data[vi+19] = 1; data[vi+20] = hit.tex; data[vi+21] = hit.shade; data[vi+22] = hit.fog; data[vi+23] = hit.side;
            data[vi+24] = x1; data[vi+25] = hit.top; data[vi+26] = hit.u; data[vi+27] = 0; data[vi+28] = hit.tex; data[vi+29] = hit.shade; data[vi+30] = hit.fog; data[vi+31] = hit.side;
            data[vi+32] = x1; data[vi+33] = hit.bottom; data[vi+34] = hit.u; data[vi+35] = 1; data[vi+36] = hit.tex; data[vi+37] = hit.shade; data[vi+38] = hit.fog; data[vi+39] = hit.side;
            data[vi+40] = x0; data[vi+41] = hit.bottom; data[vi+42] = hit.u; data[vi+43] = 1; data[vi+44] = hit.tex; data[vi+45] = hit.shade; data[vi+46] = hit.fog; data[vi+47] = hit.side;
            wallVerts += 6;
          }
        }
        
        // Upload wall distances to texture
        gl.bindTexture(gl.TEXTURE_2D, this.wallDistTex);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.rayCount, 1, gl.RED, gl.FLOAT, this.wallDistData.subarray(0, this.rayCount));
        
        profiler.end('raycast');
        profiler.start('gpu');
        
        this.drawCalls = 0;
        this.triangleCount = 0;
        
        // Draw floors/ceilings first (fullscreen quad with shader raycasting)
        gl.useProgram(this.floorProg);
        gl.bindVertexArray(this.floorVAO);
        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texAtlas);
        gl.uniform1i(this.floorUni.tex, 0);
        
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.wallDistTex);
        gl.uniform1i(this.floorUni.wallDist, 1);
        
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, this.worldMapTex);
        gl.uniform1i(this.floorUni.worldMap, 2);
        
        gl.uniform2f(this.floorUni.playerPos, px, py);
        gl.uniform1f(this.floorUni.playerAngle, angle);
        gl.uniform1f(this.floorUni.fov, this.fov);
        gl.uniform1f(this.floorUni.maxDist, this.maxDepth);
        gl.uniform2f(this.floorUni.resolution, this.width, this.height);
        gl.uniform1i(this.floorUni.rayCount, this.rayCount);
        
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        this.drawCalls++;
        this.triangleCount += 2;
        
        // Draw walls on top
        if (wallVerts > 0) {
          gl.useProgram(this.wallProg);
          gl.bindVertexArray(this.wallVAO);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.wallBuf);
          gl.bufferData(gl.ARRAY_BUFFER, data.subarray(0, wallVerts * 8), gl.DYNAMIC_DRAW);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texAtlas);
          gl.uniform1i(this.wallUni.tex, 0);
          gl.drawArrays(gl.TRIANGLES, 0, wallVerts);
          this.drawCalls++;
          this.triangleCount += wallVerts / 3;
        }
        
        profiler.end('gpu');
      }
      
      _castRay(world, vis, px, py, viewAngle, rayAngle) {
        const step = 0.02, cosA = Math.cos(rayAngle), sinA = Math.sin(rayAngle), cosCorr = Math.cos(rayAngle - viewAngle);
        let x = px, y = py, dist = 0;
        while (dist < this.maxDepth) {
          x += cosA * step; y += sinA * step; dist += step;
          const gx = Math.floor(x), gy = Math.floor(y);
          const sector = world.getSector(x, y);
          if (!sector.walkable) {
            const visible = vis.isVisible(gx, gy), discovered = vis.isDiscovered(gx, gy);
            if (!visible && !discovered) return null;
            const corrDist = dist * cosCorr, wallH = Math.min(2.0, 1.7 / corrDist);
            const hitX = x - gx, hitY = y - gy, isNS = hitX < 0.03 || hitX > 0.97;
            return {
              dist: corrDist, top: wallH/2, bottom: -wallH/2,
              u: isNS ? hitY : hitX, tex: this.wallTexMap[sector.name] || 3,
              shade: (!visible && discovered) ? Math.max(0.15, 1.0 - corrDist * 0.055) * 0.5 : Math.max(0.3, 1.0 - corrDist * 0.055),
              fog: Math.max(0, Math.min(1, (corrDist - 5) * 0.08)), side: isNS ? 1.0 : 0.0
            };
          }
        }
        return null;
      }
    }
    
    // ============ OVERLAY ============
    class OverlayRenderer {
      init(canvas) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.resize(); window.addEventListener('resize', () => this.resize()); }
      resize() { const c = this.canvas.parentElement; this.width = c.clientWidth; this.height = c.clientHeight; this.canvas.width = this.width; this.canvas.height = this.height; }
      render() {
        const ctx = this.ctx, w = this.width, h = this.height;
        ctx.clearRect(0, 0, w, h);
        const vig = ctx.createRadialGradient(w/2, h/2, h*0.2, w/2, h/2, h*0.95);
        vig.addColorStop(0, 'rgba(0,0,0,0)'); vig.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.fillStyle = vig; ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = 'rgba(51,255,51,0.8)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(w/2-14, h/2); ctx.lineTo(w/2-5, h/2); ctx.moveTo(w/2+5, h/2); ctx.lineTo(w/2+14, h/2);
        ctx.moveTo(w/2, h/2-14); ctx.lineTo(w/2, h/2-5); ctx.moveTo(w/2, h/2+5); ctx.lineTo(w/2, h/2+14); ctx.stroke();
        ctx.fillStyle = 'rgba(51,255,51,0.9)'; ctx.beginPath(); ctx.arc(w/2, h/2, 2, 0, Math.PI*2); ctx.fill();
      }
    }
    
    // ============ ENGINE CORE ============
    class World {
      constructor(cfg = {}) { this.width = cfg.width || 32; this.height = cfg.height || 32; this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill('void')); this.sectorTypes = new Map(); this.sectorTypes.set('void', { walkable: false, floorColor: [20,20,25], name: 'VOID' }); }
      registerSectorTypes(t) { for (const [k,v] of Object.entries(t)) this.sectorTypes.set(k, v); }
      getSector(x, y) { const gx = Math.floor(x), gy = Math.floor(y); if (gx < 0 || gx >= this.width || gy < 0 || gy >= this.height) return this.sectorTypes.get('void'); return this.sectorTypes.get(this.grid[gy][gx]) || this.sectorTypes.get('void'); }
      fillRect(x1, y1, x2, y2, type) { for (let y = Math.min(y1,y2); y <= Math.max(y1,y2); y++) for (let x = Math.min(x1,x2); x <= Math.max(x1,x2); x++) if (x >= 0 && x < this.width && y >= 0 && y < this.height) this.grid[y][x] = type; }
      countWalkable() { let c = 0; for (let y = 0; y < this.height; y++) for (let x = 0; x < this.width; x++) if (this.getSector(x,y).walkable) c++; return c; }
    }
    
    class Visibility {
      constructor(world, cfg = {}) { this.world = world; this.viewDistance = cfg.viewDistance || 16; this.discovered = new Set(); this.currentlyVisible = new Set(); this.totalWalkable = world.countWalkable(); this.lastCell = null; }
      update(x, y) {
        const cell = `${Math.floor(x)},${Math.floor(y)}`; if (cell === this.lastCell) return false; this.lastCell = cell;
        profiler.start('visibility'); this.currentlyVisible.clear();
        for (let i = 0; i < 180; i++) { const ang = (i/180)*Math.PI*2; let rx = x, ry = y; const dx = Math.cos(ang)*0.4, dy = Math.sin(ang)*0.4;
          for (let d = 0; d < this.viewDistance; d += 0.4) { rx += dx; ry += dy; const k = `${Math.floor(rx)},${Math.floor(ry)}`; this.currentlyVisible.add(k); const s = this.world.getSector(rx, ry); if (s.walkable) this.discovered.add(k); if (!s.walkable) break; }
        } profiler.end('visibility'); return true;
      }
      isVisible(gx, gy) { return this.currentlyVisible.has(`${gx},${gy}`); }
      isDiscovered(gx, gy) { return this.discovered.has(`${gx},${gy}`); }
      getDiscoveryPercent() { let c = 0; for (const k of this.discovered) { const [x,y] = k.split(',').map(Number); if (this.world.getSector(x,y).walkable) c++; } return Math.round((c / this.totalWalkable) * 100); }
    }
    
    class Movement {
      constructor(world) { this.world = world; }
      move(e, dx, dy) { const r = e.radius || 0.2, nx = e.x + dx, ny = e.y + dy; if (this._can(nx, ny, r)) return { x: nx, y: ny }; if (this._can(nx, e.y, r)) return { x: nx, y: e.y }; if (this._can(e.x, ny, r)) return { x: e.x, y: ny }; return { x: e.x, y: e.y }; }
      _can(x, y, r) { for (const [px,py] of [[x,y],[x-r,y-r],[x+r,y-r],[x-r,y+r],[x+r,y+r]]) if (!this.world.getSector(px,py).walkable) return false; return true; }
    }
    
    class Input {
      constructor() { this.keys = {}; this.mouseDX = 0; this.locked = false; }
      init(target) {
        window.addEventListener('keydown', e => { this.keys[e.code] = true; if (['KeyW','KeyA','KeyS','KeyD','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        document.addEventListener('mousemove', e => { if (this.locked) this.mouseDX += e.movementX; });
        document.addEventListener('pointerlockchange', () => { this.locked = document.pointerLockElement === target; document.getElementById('click-prompt').classList.toggle('hidden', this.locked); });
        target.addEventListener('click', () => { if (!this.locked) target.requestPointerLock(); });
      }
      getMovement(dt, speed) { let f=0,s=0,t=0; if (this.keys['KeyW']||this.keys['ArrowUp']) f+=speed; if (this.keys['KeyS']||this.keys['ArrowDown']) f-=speed; if (this.keys['KeyA']) s-=speed; if (this.keys['KeyD']) s+=speed; if (this.keys['ArrowLeft']) t-=2.2*dt; if (this.keys['ArrowRight']) t+=2.2*dt; if (this.keys['ShiftLeft']||this.keys['ShiftRight']) { f*=1.7; s*=1.7; } t+=this.mouseDX*0.002; this.mouseDX=0; return { forward:f, strafe:s, turn:t }; }
    }
    
    class Minimap {
      constructor(cfg={}) { this.fov=cfg.fov||Math.PI*0.6; this.viewDist=cfg.viewDistance||16; }
      init(canvas) { this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.resize(); window.addEventListener('resize',()=>this.resize()); }
      resize() { const c=this.canvas.parentElement; const sz=Math.min(c.clientWidth-16,c.clientHeight-26); this.canvas.width=sz; this.canvas.height=sz; }
      render(world,vis,px,py,angle) {
        profiler.start('minimap');
        const ctx=this.ctx,w=this.canvas.width,h=this.canvas.height,cw=w/world.width,ch=h/world.height;
        ctx.fillStyle='#030305'; ctx.fillRect(0,0,w,h);
        for(let gy=0;gy<world.height;gy++) for(let gx=0;gx<world.width;gx++) {
          const sec=world.getSector(gx,gy),v=vis.isVisible(gx,gy),d=vis.isDiscovered(gx,gy);
          let col; if(!d&&!v) col='#050508'; else if(!sec.walkable) col=v?'#3a3a45':'#1a1a22'; else if(v) { const c=sec.floorColor; col=`rgb(${c[0]*0.75|0},${c[1]*0.75|0},${c[2]*0.75|0})`; } else col='#151518';
          ctx.fillStyle=col; ctx.fillRect(gx*cw,gy*ch,cw+0.5,ch+0.5);
        }
        const mx=px*cw,my=py*ch,cl=this.viewDist*cw;
        ctx.fillStyle='rgba(51,255,51,0.1)'; ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(angle-this.fov/2)*cl,my+Math.sin(angle-this.fov/2)*cl); ctx.arc(mx,my,cl,angle-this.fov/2,angle+this.fov/2); ctx.fill();
        ctx.fillStyle='#33ff33'; ctx.shadowColor='#33ff33'; ctx.shadowBlur=5; ctx.beginPath(); ctx.arc(mx,my,3,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
        ctx.strokeStyle='#33ff33'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(angle)*8,my+Math.sin(angle)*8); ctx.stroke();
        profiler.end('minimap');
      }
    }
    
    // ============ LEVEL ============
    const SECTOR_TYPES = {
      hangar: { walkable:true, floorColor:[80,82,88], name:'HANGAR' },
      hangar_platform: { walkable:true, floorColor:[120,110,85], name:'PLATFORM' },
      corridor: { walkable:true, floorColor:[75,78,85], name:'CORRIDOR' },
      zigzag: { walkable:true, floorColor:[70,90,78], name:'OPS CENTER' },
      computer: { walkable:true, floorColor:[75,80,100], name:'TERMINAL BAY' },
      outdoor: { walkable:true, floorColor:[100,95,80], name:'EXTERIOR' },
      pillar: { walkable:false, floorColor:[130,125,118], name:'PILLAR' },
      crate: { walkable:false, floorColor:[130,105,70], name:'CRATE' }
    };
    
    const REGIONS = [
      { type:'hangar', x1:1, y1:9, x2:7, y2:15 }, { type:'hangar_platform', x1:4, y1:11, x2:6, y2:13 },
      { type:'corridor', x1:7, y1:11, x2:11, y2:13 }, { type:'corridor', x1:17, y1:11, x2:19, y2:13 },
      { type:'zigzag', x1:11, y1:7, x2:17, y2:17 },
      { type:'pillar', x1:13, y1:9, x2:13, y2:9 }, { type:'pillar', x1:15, y1:9, x2:15, y2:9 },
      { type:'pillar', x1:13, y1:15, x2:13, y2:15 }, { type:'pillar', x1:15, y1:15, x2:15, y2:15 },
      { type:'computer', x1:19, y1:9, x2:23, y2:15 },
      { type:'crate', x1:21, y1:10, x2:22, y2:10 }, { type:'crate', x1:21, y1:14, x2:21, y2:14 },
      { type:'outdoor', x1:1, y1:1, x2:7, y2:7 }, { type:'hangar', x1:3, y1:8, x2:5, y2:8 }
    ];
    
    // ============ SETUP ============
    const world = new World({ width:24, height:24 });
    world.registerSectorTypes(SECTOR_TYPES);
    REGIONS.forEach(r => world.fillRect(r.x1, r.y1, r.x2, r.y2, r.type));
    
    const visibility = new Visibility(world, { viewDistance:16 });
    const movement = new Movement(world);
    const input = new Input();
    const renderer = new WebGL2Renderer({ rayCount:400, maxDepth:16 });
    const overlay = new OverlayRenderer();
    const minimap = new Minimap({ viewDistance:16 });
    const player = { x:3.5, y:12.5, angle:0, radius:0.2, speed:3.0 };
    
    renderer.init(document.getElementById('game-canvas'));
    renderer.updateWorldMap(world); // Upload world to GPU
    overlay.init(document.getElementById('overlay-canvas'));
    minimap.init(document.getElementById('minimap-canvas'));
    input.init(document.getElementById('viewport'));
    visibility.update(player.x, player.y);
    
    // Perf graph
    const graphCanvas = document.getElementById('graph-canvas'), graphCtx = graphCanvas.getContext('2d');
    function drawPerfGraph() {
      const w=graphCanvas.width=graphCanvas.parentElement.clientWidth, h=graphCanvas.height=40, hist=profiler.getHistory('frame');
      graphCtx.fillStyle='#0a0a0c'; graphCtx.fillRect(0,0,w,h);
      graphCtx.strokeStyle='#1a3a1a'; graphCtx.beginPath(); graphCtx.moveTo(0,h-(16.67/40)*h); graphCtx.lineTo(w,h-(16.67/40)*h); graphCtx.stroke();
      if(hist.length<2) return;
      graphCtx.strokeStyle='#33ff33'; graphCtx.lineWidth=1; graphCtx.beginPath();
      const step=w/(hist.length-1); for(let i=0;i<hist.length;i++) { const x=i*step, y=h-Math.min(1,hist[i]/40)*h; if(i===0) graphCtx.moveTo(x,y); else graphCtx.lineTo(x,y); } graphCtx.stroke();
    }
    
    // Sliders
    document.getElementById('tune-rays').addEventListener('input', e => { renderer.setRayCount(parseInt(e.target.value)); document.getElementById('tune-rays-val').textContent=e.target.value; });
    document.getElementById('tune-viewdist').addEventListener('input', e => { renderer.setViewDist(parseInt(e.target.value)); visibility.viewDistance=parseInt(e.target.value); document.getElementById('tune-viewdist-val').textContent=e.target.value; });
    
    function showMessage(t) { const log=document.getElementById('messages'), msg=document.createElement('div'); msg.className='message'; msg.textContent=t; log.appendChild(msg); setTimeout(()=>msg.remove(),2500); }
    
    // Game loop
    let lastTime=0, uiTimer=0;
    function gameLoop(time) {
      profiler.start('frame');
      const dt=Math.min((time-lastTime)/1000,0.1); lastTime=time;
      
      const move=input.getMovement(dt,player.speed*dt);
      player.angle+=move.turn; while(player.angle<0) player.angle+=Math.PI*2; while(player.angle>=Math.PI*2) player.angle-=Math.PI*2;
      const fx=Math.cos(player.angle),fy=Math.sin(player.angle),sx=Math.cos(player.angle+Math.PI/2),sy=Math.sin(player.angle+Math.PI/2);
      const dx=fx*move.forward+sx*move.strafe, dy=fy*move.forward+sy*move.strafe;
      if(dx!==0||dy!==0) { const res=movement.move(player,dx,dy); player.x=res.x; player.y=res.y; }
      
      visibility.update(player.x,player.y);
      renderer.render(world,visibility,player.x,player.y,player.angle);
      overlay.render();
      minimap.render(world,visibility,player.x,player.y,player.angle);
      
      profiler.end('frame');
      
      uiTimer+=dt;
      if(uiTimer>0.1) {
        uiTimer=0;
        const frame=profiler.getAvg('frame'), fps=frame>0?1000/frame:0;
        const fpsEl=document.getElementById('stat-fps'); fpsEl.textContent=fps.toFixed(0); fpsEl.className='stat-value'+(fps>=55?'':fps>=30?' warn':' bad');
        document.getElementById('stat-frame').textContent=frame.toFixed(1)+'ms';
        document.getElementById('stat-draws').textContent=renderer.drawCalls;
        document.getElementById('stat-sector').textContent=world.getSector(player.x,player.y).name||'--';
        document.getElementById('perf-frame').textContent=frame.toFixed(2)+'ms';
        document.getElementById('perf-raycast').textContent=profiler.getAvg('raycast').toFixed(2)+'ms';
        document.getElementById('perf-gpu').textContent=profiler.getAvg('gpu').toFixed(2)+'ms';
        document.getElementById('perf-visibility').textContent=profiler.getAvg('visibility').toFixed(2)+'ms';
        document.getElementById('perf-minimap').textContent=profiler.getAvg('minimap').toFixed(2)+'ms';
        document.getElementById('perf-tris').textContent=renderer.triangleCount;
        const barFill=document.getElementById('bar-frame'), pct=Math.min(100,(frame/33.33)*100);
        barFill.style.width=pct+'%'; barFill.className='perf-bar-fill'+(frame<16.67?'':frame<33.33?' warn':' bad');
        drawPerfGraph();
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    showMessage('SECTOR ENGINE - GPU Floors v2');
    showMessage('Floor/ceiling raycasting in fragment shader');
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
