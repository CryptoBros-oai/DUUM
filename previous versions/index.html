<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Installation Alpha - E1M1 Homage</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #0a0a0c;
      color: #33ff33;
      font-family: 'Share Tech Mono', monospace;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    #header {
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border-bottom: 2px solid #33ff33;
      padding: 12px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 4px 20px rgba(51, 255, 51, 0.1);
    }
    
    #header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.4rem;
      letter-spacing: 4px;
      text-shadow: 0 0 10px rgba(51, 255, 51, 0.5);
    }
    
    #stats {
      display: flex;
      gap: 32px;
      font-size: 0.85rem;
    }
    
    .stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .stat-label {
      color: #666;
      font-size: 0.7rem;
      letter-spacing: 2px;
    }
    
    .stat-value {
      color: #33ff33;
      text-shadow: 0 0 8px rgba(51, 255, 51, 0.4);
    }
    
    #main-container {
      flex: 1;
      display: flex;
      gap: 0;
      padding: 16px;
      min-height: 0;
    }
    
    #viewport-container {
      flex: 2;
      position: relative;
      border: 2px solid #222;
      border-radius: 4px;
      overflow: hidden;
      background: #000;
    }
    
    #viewport-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
      z-index: 10;
    }
    
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    #scanlines {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.1) 0px,
        rgba(0, 0, 0, 0.1) 1px,
        transparent 1px,
        transparent 3px
      );
      pointer-events: none;
      z-index: 11;
    }
    
    #minimap-container {
      flex: 1;
      max-width: 350px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding-left: 16px;
    }
    
    #minimap-wrapper {
      background: linear-gradient(135deg, #0f0f12 0%, #1a1a1f 100%);
      border: 2px solid #333;
      border-radius: 4px;
      padding: 16px;
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    #minimap-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      letter-spacing: 3px;
      color: #666;
      margin-bottom: 12px;
      text-align: center;
    }
    
    #minimap-canvas {
      flex: 1;
      width: 100%;
      border: 1px solid #2a2a2a;
      background: #050508;
    }
    
    #controls-panel {
      background: linear-gradient(135deg, #0f0f12 0%, #1a1a1f 100%);
      border: 2px solid #333;
      border-radius: 4px;
      padding: 16px;
    }
    
    #controls-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.75rem;
      letter-spacing: 3px;
      color: #666;
      margin-bottom: 12px;
    }
    
    .control-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 0.8rem;
    }
    
    .key {
      background: #1a1a1f;
      border: 1px solid #333;
      padding: 2px 8px;
      border-radius: 3px;
      color: #33ff33;
      font-size: 0.75rem;
    }
    
    #message-log {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 20;
      max-width: 400px;
    }
    
    .log-message {
      background: rgba(0, 0, 0, 0.8);
      border-left: 3px solid #33ff33;
      padding: 8px 12px;
      margin-bottom: 4px;
      font-size: 0.85rem;
      animation: fadeIn 0.3s ease-out, fadeOut 0.5s ease-in 3s forwards;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="header">
    <h1>INSTALLATION ALPHA</h1>
    <div id="stats">
      <div class="stat">
        <span class="stat-label">SECTORS</span>
        <span class="stat-value" id="sectors-discovered">0 / 0</span>
      </div>
      <div class="stat">
        <span class="stat-label">POSITION</span>
        <span class="stat-value" id="player-position">0, 0</span>
      </div>
      <div class="stat">
        <span class="stat-label">FACING</span>
        <span class="stat-value" id="player-facing">N</span>
      </div>
    </div>
  </div>
  
  <div id="main-container">
    <div id="viewport-container">
      <canvas id="game-canvas"></canvas>
      <div id="scanlines"></div>
      <div id="message-log"></div>
    </div>
    
    <div id="minimap-container">
      <div id="minimap-wrapper">
        <div id="minimap-title">TACTICAL MAP</div>
        <canvas id="minimap-canvas"></canvas>
      </div>
      
      <div id="controls-panel">
        <div id="controls-title">CONTROLS</div>
        <div class="control-row">
          <span>Move</span>
          <span><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span></span>
        </div>
        <div class="control-row">
          <span>Turn</span>
          <span><span class="key">←</span> <span class="key">→</span></span>
        </div>
        <div class="control-row">
          <span>Run</span>
          <span><span class="key">Shift</span></span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // INSTALLATION ALPHA - E1M1 HOMAGE PROTOTYPE
    // 2.5D Rendering with Fog of War
    // ============================================

    // --- CONFIGURATION ---
    const CONFIG = {
      SECTOR_SIZE: 64,
      PLAYER_HEIGHT: 0.5,
      EYE_HEIGHT: 0.4,
      MOVE_SPEED: 2.5,
      RUN_MULTIPLIER: 1.8,
      TURN_SPEED: 2.5,
      FOV: Math.PI * 0.55,
      VIEW_DISTANCE: 12,
      RAY_COUNT: 320
    };

    // --- LEVEL DEFINITION ---
    // E1M1-inspired layout: Hangar -> Corridor -> Zigzag Room -> Computer Room
    // Plus secret outdoor area
    const LEVEL = {
      width: 24,
      height: 24,
      playerStart: { x: 3, y: 12, angle: 0 },
      
      // Sector types define floor/ceiling heights and textures
      sectorTypes: {
        void: { floor: -10, ceiling: -10, floorColor: [0, 0, 0], ceilingColor: [0, 0, 0], walkable: false },
        hangar: { floor: 0, ceiling: 1.2, floorColor: [0.25, 0.25, 0.28], ceilingColor: [0.15, 0.15, 0.18], walkable: true },
        hangar_platform: { floor: 0.25, ceiling: 1.2, floorColor: [0.35, 0.32, 0.25], ceilingColor: [0.15, 0.15, 0.18], walkable: true },
        corridor: { floor: 0, ceiling: 1.0, floorColor: [0.22, 0.22, 0.25], ceilingColor: [0.12, 0.12, 0.15], walkable: true },
        zigzag: { floor: 0.1, ceiling: 1.3, floorColor: [0.2, 0.25, 0.2], ceilingColor: [0.1, 0.15, 0.1], walkable: true },
        computer: { floor: 0.15, ceiling: 1.1, floorColor: [0.2, 0.22, 0.28], ceilingColor: [0.08, 0.1, 0.15], walkable: true },
        outdoor: { floor: -0.15, ceiling: 3.0, floorColor: [0.3, 0.28, 0.22], ceilingColor: [0.1, 0.12, 0.18], walkable: true },
        pillar: { floor: 0, ceiling: 1.2, floorColor: [0.4, 0.38, 0.35], ceilingColor: [0.15, 0.15, 0.18], walkable: false },
        crate: { floor: 0.4, ceiling: 1.2, floorColor: [0.35, 0.28, 0.18], ceilingColor: [0.15, 0.15, 0.18], walkable: false }
      },
      
      // Level layout - each cell references a sector type
      grid: null,
      
      init() {
        // Initialize with void
        this.grid = Array(this.height).fill(null).map(() => 
          Array(this.width).fill('void')
        );
        
        // Define regions
        const regions = [
          // Entry hangar (larger open space)
          { type: 'hangar', x1: 1, y1: 9, x2: 7, y2: 15 },
          
          // Raised platform in hangar
          { type: 'hangar_platform', x1: 4, y1: 11, x2: 6, y2: 13 },
          
          // Main corridor east
          { type: 'corridor', x1: 7, y1: 11, x2: 11, y2: 13 },
          
          // Zigzag room (larger combat space)
          { type: 'zigzag', x1: 11, y1: 7, x2: 17, y2: 17 },
          
          // Pillars in zigzag room
          { type: 'pillar', x1: 13, y1: 9, x2: 13, y2: 9 },
          { type: 'pillar', x1: 15, y1: 9, x2: 15, y2: 9 },
          { type: 'pillar', x1: 13, y1: 15, x2: 13, y2: 15 },
          { type: 'pillar', x1: 15, y1: 15, x2: 15, y2: 15 },
          
          // Corridor to computer room
          { type: 'corridor', x1: 17, y1: 11, x2: 19, y2: 13 },
          
          // Computer room (terminal area)
          { type: 'computer', x1: 19, y1: 9, x2: 23, y2: 15 },
          
          // Crates in computer room
          { type: 'crate', x1: 21, y1: 10, x2: 22, y2: 10 },
          { type: 'crate', x1: 21, y1: 14, x2: 21, y2: 14 },
          
          // Secret outdoor area (accessible from hangar north side)
          { type: 'outdoor', x1: 1, y1: 1, x2: 7, y2: 7 },
          
          // Connection from hangar to outdoor
          { type: 'hangar', x1: 3, y1: 8, x2: 5, y2: 8 }
        ];
        
        // Fill regions
        for (const region of regions) {
          for (let y = region.y1; y <= region.y2; y++) {
            for (let x = region.x1; x <= region.x2; x++) {
              if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                this.grid[y][x] = region.type;
              }
            }
          }
        }
      },
      
      getSector(x, y) {
        const gx = Math.floor(x);
        const gy = Math.floor(y);
        if (gx < 0 || gx >= this.width || gy < 0 || gy >= this.height) {
          return this.sectorTypes.void;
        }
        const type = this.grid[gy][gx];
        return this.sectorTypes[type] || this.sectorTypes.void;
      },
      
      getSectorType(x, y) {
        const gx = Math.floor(x);
        const gy = Math.floor(y);
        if (gx < 0 || gx >= this.width || gy < 0 || gy >= this.height) {
          return 'void';
        }
        return this.grid[gy][gx];
      }
    };

    // --- PLAYER STATE ---
    const player = {
      x: 0,
      y: 0,
      angle: 0,
      
      init() {
        this.x = LEVEL.playerStart.x + 0.5;
        this.y = LEVEL.playerStart.y + 0.5;
        this.angle = LEVEL.playerStart.angle;
      },
      
      move(dx, dy) {
        const newX = this.x + dx;
        const newY = this.y + dy;
        
        // Collision detection with padding
        const padding = 0.2;
        const testPoints = [
          [newX - padding, newY - padding],
          [newX + padding, newY - padding],
          [newX - padding, newY + padding],
          [newX + padding, newY + padding]
        ];
        
        let canMoveX = true;
        let canMoveY = true;
        
        for (const [tx, ty] of testPoints) {
          const sector = LEVEL.getSector(this.x + dx, this.y);
          if (!sector.walkable) canMoveX = false;
          
          const sector2 = LEVEL.getSector(this.x, this.y + dy);
          if (!sector2.walkable) canMoveY = false;
        }
        
        // Allow sliding along walls
        if (canMoveX) this.x = newX;
        else if (canMoveY) this.y = newY;
        else {
          // Try each axis separately
          if (LEVEL.getSector(newX, this.y).walkable) this.x = newX;
          if (LEVEL.getSector(this.x, newY).walkable) this.y = newY;
        }
      }
    };

    // --- FOG OF WAR ---
    const fogOfWar = {
      discovered: new Set(),
      currentlyVisible: new Set(),
      totalSectors: 0,
      
      init() {
        // Count walkable sectors
        this.totalSectors = 0;
        for (let y = 0; y < LEVEL.height; y++) {
          for (let x = 0; x < LEVEL.width; x++) {
            if (LEVEL.getSector(x, y).walkable) {
              this.totalSectors++;
            }
          }
        }
      },
      
      update() {
        this.currentlyVisible.clear();
        
        // Cast rays for visibility
        const rayCount = 360;
        for (let i = 0; i < rayCount; i++) {
          const angle = (i / rayCount) * Math.PI * 2;
          this.castVisibilityRay(angle);
        }
      },
      
      castVisibilityRay(angle) {
        const maxDist = CONFIG.VIEW_DISTANCE;
        const step = 0.3;
        
        let x = player.x;
        let y = player.y;
        const playerFloor = LEVEL.getSector(player.x, player.y).floor;
        const eyeHeight = playerFloor + CONFIG.EYE_HEIGHT;
        
        for (let d = 0; d < maxDist; d += step) {
          x += Math.cos(angle) * step;
          y += Math.sin(angle) * step;
          
          const gx = Math.floor(x);
          const gy = Math.floor(y);
          
          if (gx < 0 || gx >= LEVEL.width || gy < 0 || gy >= LEVEL.height) break;
          
          const key = `${gx},${gy}`;
          const sector = LEVEL.getSector(x, y);
          
          // Mark as visible
          this.currentlyVisible.add(key);
          if (!this.discovered.has(key) && sector.walkable) {
            this.discovered.add(key);
          }
          
          // Check if blocked by wall (non-walkable sector) or height difference
          if (!sector.walkable) {
            break;
          }
          
          // Check ceiling height for visibility blocking
          if (sector.ceiling < eyeHeight - 0.1) {
            break;
          }
        }
      },
      
      isVisible(x, y) {
        return this.currentlyVisible.has(`${Math.floor(x)},${Math.floor(y)}`);
      },
      
      isDiscovered(x, y) {
        return this.discovered.has(`${Math.floor(x)},${Math.floor(y)}`);
      }
    };

    // --- INPUT HANDLING ---
    const input = {
      keys: {},
      
      init() {
        window.addEventListener('keydown', (e) => {
          this.keys[e.code] = true;
          e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
          this.keys[e.code] = false;
        });
      },
      
      isPressed(code) {
        return this.keys[code] === true;
      }
    };

    // --- RAYCASTER RENDERER ---
    const renderer = {
      canvas: null,
      ctx: null,
      width: 0,
      height: 0,
      
      init() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
      },
      
      resize() {
        const container = this.canvas.parentElement;
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
      },
      
      render() {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        
        // Clear with dark background
        ctx.fillStyle = '#0a0a0c';
        ctx.fillRect(0, 0, w, h);
        
        // Draw ceiling gradient
        const ceilGrad = ctx.createLinearGradient(0, 0, 0, h/2);
        ceilGrad.addColorStop(0, '#0a0a0f');
        ceilGrad.addColorStop(1, '#151520');
        ctx.fillStyle = ceilGrad;
        ctx.fillRect(0, 0, w, h/2);
        
        // Draw floor gradient
        const floorGrad = ctx.createLinearGradient(0, h/2, 0, h);
        floorGrad.addColorStop(0, '#151518');
        floorGrad.addColorStop(1, '#0a0a0c');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, h/2, w, h/2);
        
        // Cast rays
        const rayCount = CONFIG.RAY_COUNT;
        const columnWidth = w / rayCount;
        
        for (let i = 0; i < rayCount; i++) {
          const rayAngle = player.angle - CONFIG.FOV/2 + (i / rayCount) * CONFIG.FOV;
          this.castRay(i, rayAngle, columnWidth);
        }
        
        // Draw crosshair
        ctx.strokeStyle = 'rgba(51, 255, 51, 0.5)';
        ctx.lineWidth = 1;
        const cx = w/2, cy = h/2;
        ctx.beginPath();
        ctx.moveTo(cx - 10, cy);
        ctx.lineTo(cx - 4, cy);
        ctx.moveTo(cx + 4, cy);
        ctx.lineTo(cx + 10, cy);
        ctx.moveTo(cx, cy - 10);
        ctx.lineTo(cx, cy - 4);
        ctx.moveTo(cx, cy + 4);
        ctx.lineTo(cx, cy + 10);
        ctx.stroke();
      },
      
      castRay(column, angle, columnWidth) {
        const ctx = this.ctx;
        const w = this.width;
        const h = this.height;
        
        const step = 0.02;
        const maxDist = 20;
        
        let x = player.x;
        let y = player.y;
        let dist = 0;
        let hitSector = null;
        let hitX = 0, hitY = 0;
        
        const dx = Math.cos(angle) * step;
        const dy = Math.sin(angle) * step;
        
        const playerSector = LEVEL.getSector(player.x, player.y);
        const eyeHeight = playerSector.floor + CONFIG.EYE_HEIGHT;
        
        while (dist < maxDist) {
          x += dx;
          y += dy;
          dist += step;
          
          const sector = LEVEL.getSector(x, y);
          
          // Check if we hit a wall (non-walkable or significant height change)
          if (!sector.walkable || sector.floor > eyeHeight + 0.3) {
            hitSector = sector;
            hitX = x;
            hitY = y;
            break;
          }
        }
        
        if (!hitSector) return;
        
        // Fish-eye correction
        const correctedDist = dist * Math.cos(angle - player.angle);
        
        // Calculate wall height
        const wallHeight = (1.0 / correctedDist) * h * 0.8;
        const wallTop = (h - wallHeight) / 2;
        
        // Check visibility for fog
        const visible = fogOfWar.isVisible(hitX, hitY);
        const discovered = fogOfWar.isDiscovered(hitX, hitY);
        
        // Determine wall color based on sector and lighting
        let color = hitSector.floorColor;
        
        // Add some variation based on which side was hit
        const fractX = hitX - Math.floor(hitX);
        const fractY = hitY - Math.floor(hitY);
        const isVerticalWall = (fractX < 0.05 || fractX > 0.95);
        
        // Distance-based shading
        const shade = Math.max(0.15, 1 - correctedDist / 15);
        
        let r = color[0] * shade;
        let g = color[1] * shade;
        let b = color[2] * shade;
        
        // Vertical walls slightly darker
        if (isVerticalWall) {
          r *= 0.8;
          g *= 0.8;
          b *= 0.8;
        }
        
        // Apply fog of war
        if (!visible) {
          if (discovered) {
            // Seen before but not visible now - grayscale, dimmed
            const lum = (r + g + b) / 3;
            r = lum * 0.4;
            g = lum * 0.4;
            b = lum * 0.45; // Slight blue tint
          } else {
            // Never seen - don't render
            return;
          }
        }
        
        // Draw wall column
        ctx.fillStyle = `rgb(${Math.floor(r*255)}, ${Math.floor(g*255)}, ${Math.floor(b*255)})`;
        ctx.fillRect(column * columnWidth, wallTop, columnWidth + 1, wallHeight);
        
        // Add edge highlight on visible walls
        if (visible && isVerticalWall) {
          ctx.fillStyle = `rgba(255, 255, 255, ${0.05 * shade})`;
          ctx.fillRect(column * columnWidth, wallTop, 1, wallHeight);
        }
      }
    };

    // --- MINIMAP RENDERER ---
    const minimap = {
      canvas: null,
      ctx: null,
      
      init() {
        this.canvas = document.getElementById('minimap-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
      },
      
      resize() {
        const wrapper = this.canvas.parentElement;
        const size = Math.min(wrapper.clientWidth - 32, wrapper.clientHeight - 50);
        this.canvas.width = size;
        this.canvas.height = size;
      },
      
      render() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        
        const cellW = w / LEVEL.width;
        const cellH = h / LEVEL.height;
        
        // Clear
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, w, h);
        
        // Draw grid
        for (let y = 0; y < LEVEL.height; y++) {
          for (let x = 0; x < LEVEL.width; x++) {
            const sector = LEVEL.getSector(x, y);
            const visible = fogOfWar.isVisible(x, y);
            const discovered = fogOfWar.isDiscovered(x, y);
            
            if (!discovered && !visible) {
              // Unknown - very dark
              ctx.fillStyle = '#08080a';
            } else if (!sector.walkable) {
              // Wall
              if (visible) {
                ctx.fillStyle = '#3a3a40';
              } else {
                ctx.fillStyle = '#1a1a1f';
              }
            } else {
              // Floor
              if (visible) {
                const c = sector.floorColor;
                ctx.fillStyle = `rgb(${Math.floor(c[0]*200)}, ${Math.floor(c[1]*200)}, ${Math.floor(c[2]*200)})`;
              } else {
                ctx.fillStyle = '#15151a';
              }
            }
            
            ctx.fillRect(x * cellW, y * cellH, cellW + 0.5, cellH + 0.5);
          }
        }
        
        // Draw grid lines (subtle)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
        ctx.lineWidth = 0.5;
        for (let x = 0; x <= LEVEL.width; x++) {
          ctx.beginPath();
          ctx.moveTo(x * cellW, 0);
          ctx.lineTo(x * cellW, h);
          ctx.stroke();
        }
        for (let y = 0; y <= LEVEL.height; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * cellH);
          ctx.lineTo(w, y * cellH);
          ctx.stroke();
        }
        
        // Draw player
        const px = player.x * cellW;
        const py = player.y * cellH;
        
        // Player direction cone
        ctx.fillStyle = 'rgba(51, 255, 51, 0.15)';
        ctx.beginPath();
        ctx.moveTo(px, py);
        const coneLength = CONFIG.VIEW_DISTANCE * cellW;
        const coneAngle = CONFIG.FOV / 2;
        ctx.lineTo(
          px + Math.cos(player.angle - coneAngle) * coneLength,
          py + Math.sin(player.angle - coneAngle) * coneLength
        );
        ctx.lineTo(
          px + Math.cos(player.angle + coneAngle) * coneLength,
          py + Math.sin(player.angle + coneAngle) * coneLength
        );
        ctx.closePath();
        ctx.fill();
        
        // Player dot
        ctx.fillStyle = '#33ff33';
        ctx.shadowColor = '#33ff33';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Player direction line
        ctx.strokeStyle = '#33ff33';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(
          px + Math.cos(player.angle) * 12,
          py + Math.sin(player.angle) * 12
        );
        ctx.stroke();
      }
    };

    // --- UI UPDATES ---
    function updateUI() {
      document.getElementById('sectors-discovered').textContent = 
        `${fogOfWar.discovered.size} / ${fogOfWar.totalSectors}`;
      
      document.getElementById('player-position').textContent = 
        `${player.x.toFixed(1)}, ${player.y.toFixed(1)}`;
      
      // Convert angle to cardinal direction
      const dirs = ['E', 'SE', 'S', 'SW', 'W', 'NW', 'N', 'NE'];
      let a = player.angle;
      while (a < 0) a += Math.PI * 2;
      const idx = Math.round(a / (Math.PI / 4)) % 8;
      document.getElementById('player-facing').textContent = dirs[idx];
    }

    // --- MESSAGE LOG ---
    function showMessage(text) {
      const log = document.getElementById('message-log');
      const msg = document.createElement('div');
      msg.className = 'log-message';
      msg.textContent = text;
      log.appendChild(msg);
      
      // Remove after animation
      setTimeout(() => msg.remove(), 3500);
    }

    // --- GAME LOOP ---
    let lastTime = 0;
    let discoveryCheckTimer = 0;
    let lastDiscoveredCount = 0;

    function gameLoop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.1);
      lastTime = time;
      
      // Handle input
      let speed = CONFIG.MOVE_SPEED;
      if (input.isPressed('ShiftLeft') || input.isPressed('ShiftRight')) {
        speed *= CONFIG.RUN_MULTIPLIER;
      }
      
      // Movement
      let dx = 0, dy = 0;
      if (input.isPressed('KeyW') || input.isPressed('ArrowUp')) {
        dx += Math.cos(player.angle) * speed * dt;
        dy += Math.sin(player.angle) * speed * dt;
      }
      if (input.isPressed('KeyS') || input.isPressed('ArrowDown')) {
        dx -= Math.cos(player.angle) * speed * dt;
        dy -= Math.sin(player.angle) * speed * dt;
      }
      if (input.isPressed('KeyA')) {
        dx += Math.cos(player.angle - Math.PI/2) * speed * dt;
        dy += Math.sin(player.angle - Math.PI/2) * speed * dt;
      }
      if (input.isPressed('KeyD')) {
        dx += Math.cos(player.angle + Math.PI/2) * speed * dt;
        dy += Math.sin(player.angle + Math.PI/2) * speed * dt;
      }
      
      if (dx !== 0 || dy !== 0) {
        player.move(dx, dy);
      }
      
      // Turning
      if (input.isPressed('ArrowLeft')) {
        player.angle -= CONFIG.TURN_SPEED * dt;
      }
      if (input.isPressed('ArrowRight')) {
        player.angle += CONFIG.TURN_SPEED * dt;
      }
      
      // Normalize angle
      while (player.angle < 0) player.angle += Math.PI * 2;
      while (player.angle >= Math.PI * 2) player.angle -= Math.PI * 2;
      
      // Update fog of war
      fogOfWar.update();
      
      // Check for new discoveries
      discoveryCheckTimer += dt;
      if (discoveryCheckTimer > 0.5) {
        discoveryCheckTimer = 0;
        if (fogOfWar.discovered.size > lastDiscoveredCount) {
          const newCount = fogOfWar.discovered.size - lastDiscoveredCount;
          if (newCount >= 3) {
            showMessage(`Discovered ${newCount} new sectors`);
          }
          lastDiscoveredCount = fogOfWar.discovered.size;
        }
      }
      
      // Render
      renderer.render();
      minimap.render();
      updateUI();
      
      requestAnimationFrame(gameLoop);
    }

    // --- INITIALIZATION ---
    function init() {
      LEVEL.init();
      player.init();
      input.init();
      renderer.init();
      minimap.init();
      fogOfWar.init();
      
      // Initial fog update
      fogOfWar.update();
      lastDiscoveredCount = fogOfWar.discovered.size;
      
      showMessage('INSTALLATION ALPHA - Explore the facility');
      showMessage('Use WASD to move, Arrow keys to turn');
      
      requestAnimationFrame(gameLoop);
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
