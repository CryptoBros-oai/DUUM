<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sector Engine - Textured Edition</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0c;
      color: #33ff33;
      font-family: 'Share Tech Mono', monospace;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    #header {
      background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%);
      border-bottom: 2px solid #33ff33;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #header h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.1rem;
      letter-spacing: 3px;
      text-shadow: 0 0 10px rgba(51, 255, 51, 0.5);
    }
    
    .tag { font-size: 0.55rem; color: #aa8844; margin-left: 10px; letter-spacing: 2px; }
    
    #stats { display: flex; gap: 20px; font-size: 0.75rem; }
    .stat { display: flex; flex-direction: column; align-items: center; }
    .stat-label { color: #555; font-size: 0.6rem; letter-spacing: 2px; }
    .stat-value { color: #33ff33; }
    
    #main { flex: 1; display: flex; padding: 10px; min-height: 0; }
    
    #viewport {
      flex: 2;
      position: relative;
      border: 2px solid #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
      background: #000;
    }
    
    #game-canvas { width: 100%; height: 100%; display: block; }
    
    #click-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #33ff33;
      padding: 16px 32px;
      text-align: center;
      cursor: pointer;
    }
    #click-prompt:hover { background: rgba(51, 255, 51, 0.1); }
    #click-prompt.hidden { display: none; }
    #click-prompt h2 { font-family: 'Orbitron', sans-serif; font-size: 0.9rem; letter-spacing: 2px; }
    #click-prompt p { font-size: 0.7rem; color: #888; margin-top: 6px; }
    
    #sidebar {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding-left: 10px;
    }
    
    .panel {
      background: #0f0f12;
      border: 1px solid #222;
      border-radius: 4px;
      padding: 10px;
    }
    
    .panel-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 0.65rem;
      letter-spacing: 2px;
      color: #444;
      margin-bottom: 8px;
      text-align: center;
    }
    
    #minimap-panel { flex: 1; display: flex; flex-direction: column; }
    #minimap-canvas { flex: 1; width: 100%; border: 1px solid #1a1a1a; background: #030305; }
    
    .info-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      color: #888;
      margin-bottom: 4px;
    }
    .info-value { color: #33ff33; }
    
    .key {
      background: #1a1a1f;
      border: 1px solid #2a2a2a;
      padding: 1px 5px;
      border-radius: 2px;
      color: #33ff33;
      font-size: 0.65rem;
    }
    
    #messages {
      position: absolute;
      bottom: 12px;
      left: 12px;
      max-width: 300px;
    }
    
    .message {
      background: rgba(0,0,0,0.85);
      border-left: 2px solid #33ff33;
      padding: 5px 8px;
      margin-bottom: 2px;
      font-size: 0.75rem;
      animation: msgIn 0.2s ease-out, msgOut 0.3s ease-in 2s forwards;
    }
    
    @keyframes msgIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
    @keyframes msgOut { from { opacity: 1; } to { opacity: 0; } }
  </style>
</head>
<body>
  <div id="header">
    <h1>INSTALLATION ALPHA <span class="tag">TEXTURED</span></h1>
    <div id="stats">
      <div class="stat">
        <span class="stat-label">EXPLORED</span>
        <span class="stat-value" id="stat-explored">0%</span>
      </div>
      <div class="stat">
        <span class="stat-label">SECTOR</span>
        <span class="stat-value" id="stat-sector">--</span>
      </div>
      <div class="stat">
        <span class="stat-label">FPS</span>
        <span class="stat-value" id="stat-fps">--</span>
      </div>
    </div>
  </div>
  
  <div id="main">
    <div id="viewport">
      <canvas id="game-canvas"></canvas>
      <div id="click-prompt">
        <h2>CLICK TO ENGAGE</h2>
        <p>Mouse + WASD</p>
      </div>
      <div id="messages"></div>
    </div>
    
    <div id="sidebar">
      <div class="panel" id="minimap-panel">
        <div class="panel-title">TACTICAL MAP</div>
        <canvas id="minimap-canvas"></canvas>
      </div>
      
      <div class="panel">
        <div class="panel-title">CONTROLS</div>
        <div class="info-row">
          <span>Move</span>
          <span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></span>
        </div>
        <div class="info-row">
          <span>Look</span>
          <span>Mouse / <span class="key">←</span><span class="key">→</span></span>
        </div>
        <div class="info-row">
          <span>Run</span>
          <span><span class="key">Shift</span></span>
        </div>
      </div>
      
      <div class="panel">
        <div class="panel-title">TEXTURES</div>
        <div class="info-row">
          <span>Mode</span>
          <span class="info-value">Procedural</span>
        </div>
        <div class="info-row">
          <span>Resolution</span>
          <span class="info-value">64x64</span>
        </div>
        <div class="info-row">
          <span>Materials</span>
          <span class="info-value" id="stat-materials">0</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================================================
    // SECTOR ENGINE - TEXTURED EDITION
    // Procedural textures generated at runtime - zero assets
    // =========================================================
    
    // ============ PROCEDURAL TEXTURE GENERATOR ============
    class TextureGenerator {
      constructor(size = 64) {
        this.size = size;
        this.textures = new Map();
        this.canvas = document.createElement('canvas');
        this.canvas.width = size;
        this.canvas.height = size;
        this.ctx = this.canvas.getContext('2d');
      }
      
      // Seeded random for reproducible textures
      _seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      }
      
      // Simple noise function
      _noise(x, y, seed = 0) {
        const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
        return n - Math.floor(n);
      }
      
      // Fractal brownian motion for natural-looking noise
      _fbm(x, y, octaves = 4, seed = 0) {
        let value = 0;
        let amplitude = 0.5;
        let frequency = 1;
        
        for (let i = 0; i < octaves; i++) {
          value += amplitude * this._noise(x * frequency, y * frequency, seed + i * 100);
          amplitude *= 0.5;
          frequency *= 2;
        }
        
        return value;
      }
      
      // Generate metal panel texture
      generateMetalPanels(baseColor, seed = 0) {
        const ctx = this.ctx;
        const size = this.size;
        const [br, bg, bb] = baseColor;
        
        // Fill base
        ctx.fillStyle = `rgb(${br}, ${bg}, ${bb})`;
        ctx.fillRect(0, 0, size, size);
        
        // Add noise variation
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 4;
            
            // Noise for surface variation
            const noise = this._fbm(x / 8, y / 8, 3, seed) * 30 - 15;
            
            // Panel grid lines
            const gridX = x % 16 < 1;
            const gridY = y % 16 < 1;
            const isGrid = gridX || gridY;
            
            // Rivet spots
            const rivetX = (x % 16 === 8);
            const rivetY = (y % 16 === 2 || y % 16 === 14);
            const isRivet = rivetX && rivetY;
            
            let r = data[i] + noise;
            let g = data[i + 1] + noise;
            let b = data[i + 2] + noise;
            
            if (isGrid) {
              r -= 25; g -= 25; b -= 25;
            }
            
            if (isRivet) {
              r += 30; g += 30; b += 35;
            }
            
            data[i] = Math.max(0, Math.min(255, r));
            data[i + 1] = Math.max(0, Math.min(255, g));
            data[i + 2] = Math.max(0, Math.min(255, b));
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return ctx.getImageData(0, 0, size, size);
      }
      
      // Generate tech/circuit wall texture
      generateTechWall(baseColor, seed = 0) {
        const ctx = this.ctx;
        const size = this.size;
        const [br, bg, bb] = baseColor;
        
        ctx.fillStyle = `rgb(${br * 0.7}, ${bg * 0.7}, ${bb * 0.7})`;
        ctx.fillRect(0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 4;
            
            // Circuit-like patterns
            const lineH = y % 8 === 0;
            const lineV = x % 12 === 0;
            const node = (x % 12 < 3) && (y % 8 < 3) && (this._noise(x, y, seed) > 0.7);
            
            // Glow traces
            const glowH = y % 8 === 1 && this._noise(x / 4, y, seed) > 0.5;
            const glowV = x % 12 === 1 && this._noise(x, y / 4, seed + 50) > 0.5;
            
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            if (lineH || lineV) {
              r += 15; g += 15; b += 20;
            }
            
            if (node) {
              r += 20; g += 40; b += 50;
            }
            
            if (glowH || glowV) {
              g += 30; b += 40;
            }
            
            // Subtle noise
            const noise = this._noise(x, y, seed) * 10 - 5;
            r += noise; g += noise; b += noise;
            
            data[i] = Math.max(0, Math.min(255, r));
            data[i + 1] = Math.max(0, Math.min(255, g));
            data[i + 2] = Math.max(0, Math.min(255, b));
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return ctx.getImageData(0, 0, size, size);
      }
      
      // Generate concrete/stone texture
      generateConcrete(baseColor, seed = 0) {
        const ctx = this.ctx;
        const size = this.size;
        const [br, bg, bb] = baseColor;
        
        ctx.fillStyle = `rgb(${br}, ${bg}, ${bb})`;
        ctx.fillRect(0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 4;
            
            // Multi-octave noise for concrete look
            const noise1 = this._fbm(x / 4, y / 4, 4, seed) * 40 - 20;
            const noise2 = this._fbm(x / 16, y / 16, 2, seed + 100) * 20 - 10;
            
            // Occasional dark spots (stains)
            const stain = this._noise(x / 8, y / 8, seed + 200) > 0.85 ? -20 : 0;
            
            const total = noise1 + noise2 + stain;
            
            data[i] = Math.max(0, Math.min(255, data[i] + total));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + total));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + total));
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return ctx.getImageData(0, 0, size, size);
      }
      
      // Generate grating/floor texture
      generateGrating(baseColor, seed = 0) {
        const ctx = this.ctx;
        const size = this.size;
        const [br, bg, bb] = baseColor;
        
        // Dark base (holes)
        ctx.fillStyle = `rgb(${br * 0.3}, ${bg * 0.3}, ${bb * 0.3})`;
        ctx.fillRect(0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 4;
            
            // Diamond grating pattern
            const cellX = x % 8;
            const cellY = y % 8;
            const diamond = Math.abs(cellX - 4) + Math.abs(cellY - 4) < 4;
            
            if (!diamond) {
              // Metal bars
              data[i] = br;
              data[i + 1] = bg;
              data[i + 2] = bb;
              
              // Edge highlight
              const edgeDist = Math.min(
                Math.abs(cellX - 4) + Math.abs(cellY - 4) - 3,
                2
              );
              if (edgeDist <= 1) {
                data[i] += 20;
                data[i + 1] += 20;
                data[i + 2] += 25;
              }
            }
            
            // Add noise
            const noise = this._noise(x, y, seed) * 15 - 7;
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return ctx.getImageData(0, 0, size, size);
      }
      
      // Generate brick/tile texture
      generateBrick(baseColor, seed = 0) {
        const ctx = this.ctx;
        const size = this.size;
        const [br, bg, bb] = baseColor;
        
        ctx.fillStyle = `rgb(${br}, ${bg}, ${bb})`;
        ctx.fillRect(0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        const brickH = 8;
        const brickW = 16;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 4;
            
            // Offset every other row
            const row = Math.floor(y / brickH);
            const offsetX = (row % 2) * (brickW / 2);
            const brickX = (x + offsetX) % brickW;
            const brickY = y % brickH;
            
            // Mortar lines
            const isMortar = brickX < 1 || brickY < 1;
            
            // Brick variation based on position
            const brickSeed = Math.floor((x + offsetX) / brickW) + row * 100;
            const brickVar = this._seededRandom(brickSeed + seed) * 30 - 15;
            
            // Surface noise
            const noise = this._noise(x, y, seed) * 20 - 10;
            
            if (isMortar) {
              data[i] = Math.max(0, Math.min(255, br * 0.5 + noise));
              data[i + 1] = Math.max(0, Math.min(255, bg * 0.5 + noise));
              data[i + 2] = Math.max(0, Math.min(255, bb * 0.5 + noise));
            } else {
              data[i] = Math.max(0, Math.min(255, data[i] + brickVar + noise));
              data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + brickVar + noise));
              data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + brickVar + noise));
            }
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return ctx.getImageData(0, 0, size, size);
      }
      
      // Generate crate/wood texture
      generateCrate(baseColor, seed = 0) {
        const ctx = this.ctx;
        const size = this.size;
        const [br, bg, bb] = baseColor;
        
        ctx.fillStyle = `rgb(${br}, ${bg}, ${bb})`;
        ctx.fillRect(0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const i = (y * size + x) * 4;
            
            // Wood grain (horizontal lines)
            const grain = Math.sin(y * 0.8 + this._noise(x / 20, y / 5, seed) * 5) * 15;
            
            // Plank edges
            const plankY = y % 16;
            const isEdge = plankY < 1 || plankY > 14;
            
            // Border frame
            const border = x < 4 || x > size - 5 || y < 4 || y > size - 5;
            const innerBorder = x >= 4 && x <= 7 || x >= size - 8 && x <= size - 5 ||
                               y >= 4 && y <= 7 || y >= size - 8 && y <= size - 5;
            
            // Cross braces
            const crossBrace = Math.abs(x - y) < 3 || Math.abs(x - (size - y)) < 3;
            
            let mod = grain;
            
            if (isEdge) mod -= 20;
            if (border) mod += 25;
            if (innerBorder && border) mod -= 15;
            if (crossBrace && !border) mod += 20;
            
            // Noise
            mod += this._noise(x, y, seed) * 15 - 7;
            
            data[i] = Math.max(0, Math.min(255, data[i] + mod));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + mod * 0.9));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + mod * 0.7));
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return ctx.getImageData(0, 0, size, size);
      }
      
      // Get or generate texture
      getTexture(name, generator, baseColor, seed = 0) {
        const key = `${name}_${seed}`;
        if (!this.textures.has(key)) {
          this.textures.set(key, generator.call(this, baseColor, seed));
        }
        return this.textures.get(key);
      }
      
      // Sample texture at UV coordinates
      sampleTexture(textureData, u, v) {
        const size = this.size;
        // Wrap UVs
        u = ((u % 1) + 1) % 1;
        v = ((v % 1) + 1) % 1;
        
        const x = Math.floor(u * size);
        const y = Math.floor(v * size);
        const i = (y * size + x) * 4;
        
        return [
          textureData.data[i],
          textureData.data[i + 1],
          textureData.data[i + 2]
        ];
      }
    }
    
    // ============ CORE ENGINE (with texture support) ============
    
    class World {
      constructor(config = {}) {
        this.width = config.width || 32;
        this.height = config.height || 32;
        this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill('void'));
        this.sectorTypes = new Map();
        this.sectorTypes.set('void', {
          floor: -10, ceiling: -10, walkable: false,
          floorColor: [20, 20, 25], wallColor: [40, 40, 50], name: 'VOID',
          wallTexture: 'concrete', floorTexture: 'concrete'
        });
      }
      
      registerSectorTypes(types) {
        for (const [key, def] of Object.entries(types)) {
          this.sectorTypes.set(key, def);
        }
      }
      
      getSector(x, y) {
        const gx = Math.floor(x), gy = Math.floor(y);
        if (gx < 0 || gx >= this.width || gy < 0 || gy >= this.height) {
          return this.sectorTypes.get('void');
        }
        return this.sectorTypes.get(this.grid[gy][gx]) || this.sectorTypes.get('void');
      }
      
      fillRect(x1, y1, x2, y2, type) {
        for (let y = Math.min(y1,y2); y <= Math.max(y1,y2); y++) {
          for (let x = Math.min(x1,x2); x <= Math.max(x1,x2); x++) {
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
              this.grid[y][x] = type;
            }
          }
        }
      }
      
      countWalkable() {
        let count = 0;
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (this.getSector(x, y).walkable) count++;
          }
        }
        return count;
      }
    }
    
    class Visibility {
      constructor(world, config = {}) {
        this.world = world;
        this.viewDistance = config.viewDistance || 14;
        this.discovered = new Set();
        this.currentlyVisible = new Set();
        this.totalWalkable = world.countWalkable();
        this.lastCell = null;
      }
      
      update(x, y) {
        const cell = `${Math.floor(x)},${Math.floor(y)}`;
        if (cell === this.lastCell) return;
        this.lastCell = cell;
        
        this.currentlyVisible.clear();
        for (let i = 0; i < 180; i++) {
          const angle = (i / 180) * Math.PI * 2;
          let rx = x, ry = y;
          const dx = Math.cos(angle) * 0.4;
          const dy = Math.sin(angle) * 0.4;
          
          for (let d = 0; d < this.viewDistance; d += 0.4) {
            rx += dx; ry += dy;
            const key = `${Math.floor(rx)},${Math.floor(ry)}`;
            this.currentlyVisible.add(key);
            const sector = this.world.getSector(rx, ry);
            if (sector.walkable) this.discovered.add(key);
            if (!sector.walkable) break;
          }
        }
      }
      
      isVisible(gx, gy) { return this.currentlyVisible.has(`${gx},${gy}`); }
      isDiscovered(gx, gy) { return this.discovered.has(`${gx},${gy}`); }
      
      getDiscoveryPercent() {
        let count = 0;
        for (const key of this.discovered) {
          const [x, y] = key.split(',').map(Number);
          if (this.world.getSector(x, y).walkable) count++;
        }
        return Math.round((count / this.totalWalkable) * 100);
      }
    }
    
    class Movement {
      constructor(world) { this.world = world; }
      
      move(entity, dx, dy) {
        const r = entity.radius || 0.2;
        const newX = entity.x + dx, newY = entity.y + dy;
        if (this._canOccupy(newX, newY, r)) return { x: newX, y: newY };
        if (this._canOccupy(newX, entity.y, r)) return { x: newX, y: entity.y };
        if (this._canOccupy(entity.x, newY, r)) return { x: entity.x, y: newY };
        return { x: entity.x, y: entity.y };
      }
      
      _canOccupy(x, y, r) {
        const points = [[x,y], [x-r,y-r], [x+r,y-r], [x-r,y+r], [x+r,y+r]];
        for (const [px, py] of points) {
          if (!this.world.getSector(px, py).walkable) return false;
        }
        return true;
      }
    }
    
    class Input {
      constructor() { this.keys = {}; this.mouseDX = 0; this.locked = false; }
      
      init(target) {
        window.addEventListener('keydown', e => {
          this.keys[e.code] = true;
          if (['KeyW','KeyA','KeyS','KeyD','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        document.addEventListener('mousemove', e => { if (this.locked) this.mouseDX += e.movementX; });
        document.addEventListener('pointerlockchange', () => {
          this.locked = document.pointerLockElement === target;
          document.getElementById('click-prompt').classList.toggle('hidden', this.locked);
        });
        target.addEventListener('click', () => { if (!this.locked) target.requestPointerLock(); });
      }
      
      getMovement(dt, speed) {
        let forward = 0, strafe = 0, turn = 0;
        if (this.keys['KeyW'] || this.keys['ArrowUp']) forward += speed;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) forward -= speed;
        if (this.keys['KeyA']) strafe -= speed;
        if (this.keys['KeyD']) strafe += speed;
        if (this.keys['ArrowLeft']) turn -= 2.2 * dt;
        if (this.keys['ArrowRight']) turn += 2.2 * dt;
        if (this.keys['ShiftLeft'] || this.keys['ShiftRight']) { forward *= 1.7; strafe *= 1.7; }
        turn += this.mouseDX * 0.002;
        this.mouseDX = 0;
        return { forward, strafe, turn };
      }
    }
    
    // ============ TEXTURED RENDERER ============
    class TexturedRenderer {
      constructor(config = {}) {
        this.rayCount = config.rayCount || 280; // Slightly fewer rays to compensate for texture sampling
        this.fov = config.fov || Math.PI * 0.6;
        this.maxDepth = 20;
        this.ambient = 0.35;
        this.texGen = new TextureGenerator(64);
        this.textureCache = new Map();
      }
      
      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this._generateTextures();
      }
      
      resize() {
        const c = this.canvas.parentElement;
        this.width = c.clientWidth;
        this.height = c.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
      }
      
      _generateTextures() {
        // Pre-generate all textures
        this.textureCache.set('metal', this.texGen.generateMetalPanels([110, 115, 125], 42));
        this.textureCache.set('metal_gold', this.texGen.generateMetalPanels([140, 130, 100], 43));
        this.textureCache.set('tech', this.texGen.generateTechWall([80, 90, 110], 44));
        this.textureCache.set('concrete', this.texGen.generateConcrete([95, 100, 105], 45));
        this.textureCache.set('concrete_green', this.texGen.generateConcrete([85, 105, 90], 46));
        this.textureCache.set('brick', this.texGen.generateBrick([130, 125, 110], 47));
        this.textureCache.set('grating', this.texGen.generateGrating([100, 105, 115], 48));
        this.textureCache.set('crate', this.texGen.generateCrate([150, 125, 85], 49));
        this.textureCache.set('pillar', this.texGen.generateConcrete([145, 140, 135], 50));
        
        document.getElementById('stat-materials').textContent = this.textureCache.size;
      }
      
      _getTextureForSector(sector) {
        // Map sector types to textures
        const textureMap = {
          'HANGAR': 'metal',
          'PLATFORM': 'metal_gold',
          'CORRIDOR': 'grating',
          'OPS CENTER': 'concrete_green',
          'TERMINAL BAY': 'tech',
          'EXTERIOR': 'brick',
          'PILLAR': 'pillar',
          'CRATE': 'crate',
          'VOID': 'concrete'
        };
        
        const texName = textureMap[sector.name] || 'concrete';
        return this.textureCache.get(texName);
      }
      
      render(world, visibility, px, py, angle) {
        const ctx = this.ctx, w = this.width, h = this.height;
        
        // Sky with slight gradient
        const sky = ctx.createLinearGradient(0, 0, 0, h * 0.5);
        sky.addColorStop(0, '#12151f');
        sky.addColorStop(1, '#252a38');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, w, h * 0.5);
        
        // Floor
        const floor = ctx.createLinearGradient(0, h * 0.5, 0, h);
        floor.addColorStop(0, '#32363f');
        floor.addColorStop(1, '#15171c');
        ctx.fillStyle = floor;
        ctx.fillRect(0, h * 0.5, w, h * 0.5);
        
        // Cast rays
        const colW = Math.ceil(w / this.rayCount);
        
        for (let i = 0; i < this.rayCount; i++) {
          const rayAngle = angle + ((i / this.rayCount) - 0.5) * this.fov;
          this._castRay(ctx, world, visibility, px, py, angle, rayAngle, i, colW, w, h);
        }
        
        // Vignette
        const vig = ctx.createRadialGradient(w*0.5, h*0.5, h*0.25, w*0.5, h*0.5, h*0.9);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, w, h);
        
        // Crosshair
        const cx = w * 0.5, cy = h * 0.5;
        ctx.strokeStyle = 'rgba(51,255,51,0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 12, cy); ctx.lineTo(cx - 5, cy);
        ctx.moveTo(cx + 5, cy); ctx.lineTo(cx + 12, cy);
        ctx.moveTo(cx, cy - 12); ctx.lineTo(cx, cy - 5);
        ctx.moveTo(cx, cy + 5); ctx.lineTo(cx, cy + 12);
        ctx.stroke();
      }
      
      _castRay(ctx, world, vis, px, py, viewAngle, rayAngle, col, colW, w, h) {
        const step = 0.02;
        const cosA = Math.cos(rayAngle), sinA = Math.sin(rayAngle);
        const cosCorr = Math.cos(rayAngle - viewAngle);
        
        let x = px, y = py, dist = 0;
        
        while (dist < this.maxDepth) {
          x += cosA * step;
          y += sinA * step;
          dist += step;
          
          const gx = Math.floor(x), gy = Math.floor(y);
          const sector = world.getSector(x, y);
          
          if (!sector.walkable) {
            const visible = vis.isVisible(gx, gy);
            const discovered = vis.isDiscovered(gx, gy);
            if (!visible && !discovered) return;
            
            const corrDist = dist * cosCorr;
            const wallH = Math.min(h * 2, (h * 0.85) / corrDist);
            const wallTop = (h - wallH) * 0.5;
            
            // Determine which face was hit and calculate texture U coordinate
            const hitX = x - gx;
            const hitY = y - gy;
            let texU;
            let isNS;
            
            if (hitX < 0.02 || hitX > 0.98) {
              // Hit east/west face
              texU = hitY;
              isNS = true;
            } else {
              // Hit north/south face
              texU = hitX;
              isNS = false;
            }
            
            // Get texture for this sector
            const texture = this._getTextureForSector(sector);
            
            // Draw textured wall column
            const texSize = 64;
            const wallStartY = Math.max(0, wallTop);
            const wallEndY = Math.min(h, wallTop + wallH);
            
            for (let screenY = wallStartY; screenY < wallEndY; screenY++) {
              // Calculate texture V coordinate
              const wallProgress = (screenY - wallTop) / wallH;
              const texV = wallProgress;
              
              // Sample texture
              let [r, g, b] = this.texGen.sampleTexture(texture, texU, texV);
              
              // Side shading
              if (isNS) {
                r *= 0.8; g *= 0.8; b *= 0.8;
              }
              
              // Distance shading
              const shade = Math.max(this.ambient, 1 - corrDist * 0.055);
              r *= shade; g *= shade; b *= shade;
              
              // Fog
              const fog = Math.max(0, Math.min(1, (corrDist - 7) * 0.08));
              r = r * (1 - fog) + 20 * fog;
              g = g * (1 - fog) + 24 * fog;
              b = b * (1 - fog) + 32 * fog;
              
              // Desaturate if not visible
              if (!visible && discovered) {
                const lum = (r + g + b) / 3;
                r = lum * 0.55; g = lum * 0.55; b = lum * 0.6;
              }
              
              ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
              ctx.fillRect(col * colW, screenY, colW + 1, 1);
            }
            
            return;
          }
        }
      }
    }
    
    // ============ MINIMAP ============
    class Minimap {
      constructor(config = {}) {
        this.fov = config.fov || Math.PI * 0.6;
        this.viewDist = config.viewDistance || 14;
      }
      
      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
      }
      
      resize() {
        const c = this.canvas.parentElement;
        const size = Math.min(c.clientWidth - 20, c.clientHeight - 36);
        this.canvas.width = size;
        this.canvas.height = size;
      }
      
      render(world, vis, px, py, angle) {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        const cellW = w / world.width, cellH = h / world.height;
        
        ctx.fillStyle = '#030305';
        ctx.fillRect(0, 0, w, h);
        
        for (let gy = 0; gy < world.height; gy++) {
          for (let gx = 0; gx < world.width; gx++) {
            const sector = world.getSector(gx, gy);
            const visible = vis.isVisible(gx, gy);
            const discovered = vis.isDiscovered(gx, gy);
            
            let color;
            if (!discovered && !visible) color = '#06060a';
            else if (!sector.walkable) color = visible ? '#3a3a42' : '#1a1a22';
            else if (visible) {
              const c = sector.floorColor;
              color = `rgb(${c[0]*0.8|0},${c[1]*0.8|0},${c[2]*0.8|0})`;
            } else color = '#18181e';
            
            ctx.fillStyle = color;
            ctx.fillRect(gx * cellW, gy * cellH, cellW + 0.5, cellH + 0.5);
          }
        }
        
        const mapX = px * cellW, mapY = py * cellH;
        const coneLen = this.viewDist * cellW;
        
        ctx.fillStyle = 'rgba(51,255,51,0.12)';
        ctx.beginPath();
        ctx.moveTo(mapX, mapY);
        ctx.lineTo(mapX + Math.cos(angle - this.fov*0.5) * coneLen, mapY + Math.sin(angle - this.fov*0.5) * coneLen);
        ctx.arc(mapX, mapY, coneLen, angle - this.fov*0.5, angle + this.fov*0.5);
        ctx.fill();
        
        ctx.fillStyle = '#33ff33';
        ctx.shadowColor = '#33ff33';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(mapX, mapY, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.strokeStyle = '#33ff33';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(mapX, mapY);
        ctx.lineTo(mapX + Math.cos(angle) * 8, mapY + Math.sin(angle) * 8);
        ctx.stroke();
      }
    }
    
    // ============ LEVEL DATA WITH TEXTURES ============
    const SECTOR_TYPES = {
      hangar: { 
        floor: 0, ceiling: 1.4, 
        floorColor: [80, 82, 88], wallColor: [110, 115, 125], 
        walkable: true, name: 'HANGAR',
        wallTexture: 'metal', floorTexture: 'grating'
      },
      hangar_platform: { 
        floor: 0.2, ceiling: 1.4, 
        floorColor: [120, 110, 85], wallColor: [140, 130, 100], 
        walkable: true, name: 'PLATFORM',
        wallTexture: 'metal_gold', floorTexture: 'metal'
      },
      corridor: { 
        floor: 0, ceiling: 1.1, 
        floorColor: [75, 78, 85], wallColor: [100, 105, 115], 
        walkable: true, name: 'CORRIDOR',
        wallTexture: 'grating', floorTexture: 'metal'
      },
      zigzag: { 
        floor: 0.05, ceiling: 1.5, 
        floorColor: [70, 90, 78], wallColor: [95, 120, 105], 
        walkable: true, name: 'OPS CENTER',
        wallTexture: 'concrete_green', floorTexture: 'concrete'
      },
      computer: { 
        floor: 0.1, ceiling: 1.2, 
        floorColor: [75, 80, 100], wallColor: [100, 108, 130], 
        walkable: true, name: 'TERMINAL BAY',
        wallTexture: 'tech', floorTexture: 'grating'
      },
      outdoor: { 
        floor: -0.1, ceiling: 4.0, 
        floorColor: [100, 95, 80], wallColor: [130, 125, 110], 
        walkable: true, name: 'EXTERIOR',
        wallTexture: 'brick', floorTexture: 'concrete'
      },
      pillar: { 
        floor: 0, ceiling: 1.5, 
        floorColor: [130, 125, 118], wallColor: [150, 145, 138], 
        walkable: false, name: 'PILLAR',
        wallTexture: 'pillar', floorTexture: 'concrete'
      },
      crate: { 
        floor: 0.5, ceiling: 1.2, 
        floorColor: [130, 105, 70], wallColor: [150, 125, 85], 
        walkable: false, name: 'CRATE',
        wallTexture: 'crate', floorTexture: 'crate'
      }
    };
    
    const REGIONS = [
      { type: 'hangar', x1: 1, y1: 9, x2: 7, y2: 15 },
      { type: 'hangar_platform', x1: 4, y1: 11, x2: 6, y2: 13 },
      { type: 'corridor', x1: 7, y1: 11, x2: 11, y2: 13 },
      { type: 'corridor', x1: 17, y1: 11, x2: 19, y2: 13 },
      { type: 'zigzag', x1: 11, y1: 7, x2: 17, y2: 17 },
      { type: 'pillar', x1: 13, y1: 9, x2: 13, y2: 9 },
      { type: 'pillar', x1: 15, y1: 9, x2: 15, y2: 9 },
      { type: 'pillar', x1: 13, y1: 15, x2: 13, y2: 15 },
      { type: 'pillar', x1: 15, y1: 15, x2: 15, y2: 15 },
      { type: 'computer', x1: 19, y1: 9, x2: 23, y2: 15 },
      { type: 'crate', x1: 21, y1: 10, x2: 22, y2: 10 },
      { type: 'crate', x1: 21, y1: 14, x2: 21, y2: 14 },
      { type: 'outdoor', x1: 1, y1: 1, x2: 7, y2: 7 },
      { type: 'hangar', x1: 3, y1: 8, x2: 5, y2: 8 }
    ];
    
    // ============ SETUP ============
    const world = new World({ width: 24, height: 24 });
    world.registerSectorTypes(SECTOR_TYPES);
    REGIONS.forEach(r => world.fillRect(r.x1, r.y1, r.x2, r.y2, r.type));
    
    const visibility = new Visibility(world, { viewDistance: 14 });
    const movement = new Movement(world);
    const input = new Input();
    const renderer = new TexturedRenderer({ rayCount: 280 });
    const minimap = new Minimap({ viewDistance: 14 });
    
    const player = { x: 3.5, y: 12.5, angle: 0, radius: 0.2, speed: 3.0 };
    
    renderer.init(document.getElementById('game-canvas'));
    minimap.init(document.getElementById('minimap-canvas'));
    input.init(document.getElementById('viewport'));
    visibility.update(player.x, player.y);
    
    // UI
    function showMessage(text) {
      const log = document.getElementById('messages');
      const msg = document.createElement('div');
      msg.className = 'message';
      msg.textContent = text;
      log.appendChild(msg);
      setTimeout(() => msg.remove(), 2500);
    }
    
    // Game loop
    let lastTime = 0, frameCount = 0, fpsTime = 0, currentFPS = 0;
    
    function gameLoop(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.1);
      lastTime = time;
      
      frameCount++;
      fpsTime += dt;
      if (fpsTime >= 0.5) {
        currentFPS = Math.round(frameCount / fpsTime);
        document.getElementById('stat-fps').textContent = currentFPS;
        frameCount = 0;
        fpsTime = 0;
      }
      
      const move = input.getMovement(dt, player.speed * dt);
      player.angle += move.turn;
      while (player.angle < 0) player.angle += Math.PI * 2;
      while (player.angle >= Math.PI * 2) player.angle -= Math.PI * 2;
      
      const fx = Math.cos(player.angle), fy = Math.sin(player.angle);
      const sx = Math.cos(player.angle + Math.PI * 0.5), sy = Math.sin(player.angle + Math.PI * 0.5);
      const dx = fx * move.forward + sx * move.strafe;
      const dy = fy * move.forward + sy * move.strafe;
      
      if (dx !== 0 || dy !== 0) {
        const result = movement.move(player, dx, dy);
        player.x = result.x;
        player.y = result.y;
      }
      
      visibility.update(player.x, player.y);
      
      renderer.render(world, visibility, player.x, player.y, player.angle);
      minimap.render(world, visibility, player.x, player.y, player.angle);
      
      document.getElementById('stat-explored').textContent = visibility.getDiscoveryPercent() + '%';
      document.getElementById('stat-sector').textContent = world.getSector(player.x, player.y).name || '--';
      
      requestAnimationFrame(gameLoop);
    }
    
    showMessage('SECTOR ENGINE - Textured Edition');
    showMessage('Procedural textures: 9 materials');
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
