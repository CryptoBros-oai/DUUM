<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GIGAMECH - Overworld Alpha</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0c; color: #33ff33; font-family: 'Share Tech Mono', monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
    #header { background: linear-gradient(180deg, #1a1a1f 0%, #0d0d10 100%); border-bottom: 2px solid #33ff33; padding: 8px 16px; display: flex; justify-content: space-between; align-items: center; }
    #header h1 { font-family: 'Orbitron', sans-serif; font-size: 1rem; letter-spacing: 3px; }
    .tag { font-size: 0.5rem; color: #ff9933; margin-left: 8px; letter-spacing: 2px; background: rgba(255,153,51,0.15); padding: 2px 6px; border-radius: 3px; }
    #stats { display: flex; gap: 16px; font-size: 0.7rem; }
    .stat { display: flex; flex-direction: column; align-items: center; }
    .stat-label { color: #555; font-size: 0.55rem; letter-spacing: 1px; }
    .stat-value { color: #33ff33; } .stat-value.warn { color: #ffaa33; } .stat-value.danger { color: #ff3333; }
    #main { flex: 1; display: flex; padding: 8px; min-height: 0; gap: 8px; }
    #viewport { flex: 2; position: relative; border: 2px solid #1a1a1a; border-radius: 4px; overflow: hidden; background: #000; }
    #game-canvas { width: 100%; height: 100%; display: block; }
    #cockpit-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    #click-prompt { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); border: 1px solid #33ff33; padding: 14px 28px; text-align: center; cursor: pointer; z-index: 10; }
    #click-prompt:hover { background: rgba(51,255,51,0.1); }
    #click-prompt.hidden { display: none; }
    #click-prompt h2 { font-family: 'Orbitron', sans-serif; font-size: 0.85rem; letter-spacing: 2px; }
    #sidebar { width: 280px; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; }
    .panel { background: #0f0f12; border: 1px solid #222; border-radius: 4px; padding: 8px; }
    .panel-title { font-family: 'Orbitron', sans-serif; font-size: 0.6rem; letter-spacing: 2px; color: #444; margin-bottom: 6px; }
    #minimap-panel { height: 200px; display: flex; flex-direction: column; }
    #minimap-canvas { flex: 1; width: 100%; border: 1px solid #1a1a1a; background: #030305; }
    .perf-row { display: flex; justify-content: space-between; font-size: 0.65rem; color: #666; margin-bottom: 3px; }
    .perf-value { color: #33ff33; min-width: 55px; text-align: right; }
    .slider-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.6rem; color: #888; margin-bottom: 4px; }
    .slider-row input[type="range"] { width: 80px; }
    .slider-value { color: #33ff33; min-width: 35px; text-align: right; }
    .control-row { display: flex; justify-content: space-between; font-size: 0.6rem; color: #888; margin-bottom: 3px; }
    .key { background: #1a1a1f; border: 1px solid #2a2a2a; padding: 1px 4px; border-radius: 2px; color: #33ff33; font-size: 0.55rem; }
    #messages { position: absolute; top: 10px; left: 10px; max-width: 300px; z-index: 5; }
    .message { background: rgba(0,0,0,0.85); border-left: 2px solid #33ff33; padding: 4px 8px; margin-bottom: 2px; font-size: 0.7rem; animation: msgIn 0.2s ease-out, msgOut 0.3s ease-in 3s forwards; }
    @keyframes msgIn { from { opacity: 0; transform: translateX(-10px); } }
    @keyframes msgOut { to { opacity: 0; } }
  </style>
</head>
<body>
  <div id="header">
    <h1>GIGAMECH <span class="tag">OVERWORLD ALPHA</span></h1>
    <div id="stats">
      <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="stat-fps">--</span></div>
      <div class="stat"><span class="stat-label">FRAME</span><span class="stat-value" id="stat-frame">--</span></div>
      <div class="stat"><span class="stat-label">HEAT</span><span class="stat-value" id="stat-heat">--</span></div>
      <div class="stat"><span class="stat-label">SPEED</span><span class="stat-value" id="stat-speed">--</span></div>
      <div class="stat"><span class="stat-label">SECTOR</span><span class="stat-value" id="stat-sector">--</span></div>
    </div>
  </div>
  <div id="main">
    <div id="viewport">
      <canvas id="game-canvas"></canvas>
      <canvas id="cockpit-canvas"></canvas>
      <div id="click-prompt"><h2>[ ENGAGE REACTOR ]</h2></div>
      <div id="messages"></div>
    </div>
    <div id="sidebar">
      <div class="panel" id="minimap-panel"><div class="panel-title">TACTICAL MAP</div><canvas id="minimap-canvas"></canvas></div>
      <div class="panel">
        <div class="panel-title">‚ö° PERFORMANCE</div>
        <div class="perf-row"><span>Frame Total</span><span class="perf-value" id="perf-frame">--</span></div>
        <div class="perf-row"><span>‚îú Walls</span><span class="perf-value" id="perf-walls">--</span></div>
        <div class="perf-row"><span>‚îú Floors</span><span class="perf-value" id="perf-floors">--</span></div>
        <div class="perf-row"><span>‚îî Sprites</span><span class="perf-value" id="perf-sprites">--</span></div>
      </div>
      <div class="panel">
        <div class="panel-title">üéõÔ∏è RENDER</div>
        <div class="slider-row"><span>Rays</span><input type="range" id="tune-rays" min="200" max="800" value="500"><span class="slider-value" id="tune-rays-val">500</span></div>
        <div class="slider-row"><span>View</span><input type="range" id="tune-viewdist" min="12" max="32" value="20"><span class="slider-value" id="tune-viewdist-val">20</span></div>
      </div>
      <div class="panel">
        <div class="panel-title">ü§ñ MECH CONTROLS</div>
        <div class="control-row"><span>Throttle</span><span><span class="key">W</span><span class="key">S</span></span></div>
        <div class="control-row"><span>Turn Legs</span><span><span class="key">A</span><span class="key">D</span></span></div>
        <div class="control-row"><span>Torso</span><span>Mouse</span></div>
        <div class="control-row"><span>Flashlight</span><span><span class="key">F</span></span></div>
      </div>
      <div class="panel">
        <div class="panel-title">üìä MECH STATUS</div>
        <div class="perf-row"><span>Chassis</span><span class="perf-value" id="mech-chassis">CENTURION</span></div>
        <div class="perf-row"><span>Tonnage</span><span class="perf-value">50 tons</span></div>
        <div class="perf-row"><span>Max Speed</span><span class="perf-value">54 KPH</span></div>
        <div class="perf-row"><span>Armor</span><span class="perf-value" id="mech-armor">100%</span></div>
      </div>
    </div>
  </div>
<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GIGAMECH - OVERWORLD ALPHA
// Built on SectorEngine - A 2.5D Mech Combat Game
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ‚îÄ PROFILER ‚îÄ‚îÄ‚îÄ
class Profiler {
  constructor() { this.t = {}; this.h = {}; }
  start(n) { this.t[n] = performance.now(); }
  end(n) { if (!this.t[n]) return; const d = performance.now() - this.t[n]; if (!this.h[n]) this.h[n] = []; this.h[n].push(d); if (this.h[n].length > 60) this.h[n].shift(); }
  getAvg(n) { const h = this.h[n]; return h?.length ? h.reduce((a,b)=>a+b,0)/h.length : 0; }
}
const profiler = new Profiler();

// ‚îÄ‚îÄ‚îÄ SPRITE SYSTEM ‚îÄ‚îÄ‚îÄ
class Sprite {
  constructor(cfg) {
    this.x = cfg.x||0;
    this.y = cfg.y||0;
    this.texture = cfg.texture||0;
    this.scale = cfg.scale||1;
    this.type = cfg.type||'decoration';
    this.active = true;
    this.screenX = 0;
    this.distance = 0;
  }
}

class SpriteManager {
  constructor() { this.sprites = []; this.visible = []; }
  add(cfg) { const s = new Sprite(cfg); this.sprites.push(s); return s; }
  update(px, py, angle, fov, maxDist) {
    const halfFov = fov/2, cosA = Math.cos(-angle), sinA = Math.sin(-angle);
    this.visible = [];
    for (const s of this.sprites) {
      if (!s.active) continue;
      const dx = s.x - px, dy = s.y - py;
      const camY = dx * cosA - dy * sinA, camX = dx * sinA + dy * cosA;
      if (camY <= 0.1 || camY > maxDist) continue;
      if (Math.abs(Math.atan2(camX, camY)) > halfFov + 0.3) continue;
      s.screenX = camX / camY; s.distance = camY;
      this.visible.push(s);
    }
    this.visible.sort((a, b) => b.distance - a.distance);
  }
  getVisible() { return this.visible; }
}

// ‚îÄ‚îÄ‚îÄ SPRITE TEXTURE GENERATOR - OUTDOOR THEMED ‚îÄ‚îÄ‚îÄ
class SpriteTexGen {
  constructor(s=64) { this.s = s; }
  _n(x,y,seed=0) { const n = Math.sin(x*12.9898+y*78.233+seed)*43758.5453; return n-Math.floor(n); }

  // Pine tree
  tree(seed=0) {
    const s=this.s, d=new Uint8Array(s*s*4), cx=s/2;
    for(let y=0;y<s;y++) for(let x=0;x<s;x++) {
      const i=(y*s+x)*4;
      const trunkW = s*0.08;
      const inTrunk = Math.abs(x-cx) < trunkW && y > s*0.6;
      const treeTop = s*0.1;
      const treeBot = s*0.7;
      const progress = (y - treeTop) / (treeBot - treeTop);
      const width = progress * s * 0.4;
      const inFoliage = y >= treeTop && y <= treeBot && Math.abs(x-cx) < width;

      if (inTrunk) {
        const n = this._n(x,y,seed) * 30;
        d[i] = 60 + n; d[i+1] = 40 + n; d[i+2] = 25 + n; d[i+3] = 255;
      } else if (inFoliage) {
        const n = this._n(x*2,y*2,seed) * 40;
        const shade = 1 - Math.abs(x-cx)/(width+1) * 0.3;
        d[i] = (30 + n) * shade; d[i+1] = (70 + n) * shade; d[i+2] = (30 + n*0.5) * shade; d[i+3] = 255;
      } else {
        d[i]=d[i+1]=d[i+2]=d[i+3]=0;
      }
    }
    return d;
  }

  // Deciduous tree
  tree2(seed=0) {
    const s=this.s, d=new Uint8Array(s*s*4), cx=s/2, cy=s*0.35;
    for(let y=0;y<s;y++) for(let x=0;x<s;x++) {
      const i=(y*s+x)*4;
      const inTrunk = Math.abs(x-cx) < s*0.06 && y > s*0.5;
      const dx = x-cx, dy = y-cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const inFoliage = dist < s*0.35 && y < s*0.65;

      if (inTrunk) {
        const n = this._n(x,y,seed) * 25;
        d[i] = 70 + n; d[i+1] = 50 + n; d[i+2] = 30 + n; d[i+3] = 255;
      } else if (inFoliage) {
        const n = this._n(x*3,y*3,seed) * 50;
        const shade = 1 - dist/(s*0.35) * 0.4;
        d[i] = (40 + n*0.5) * shade; d[i+1] = (90 + n) * shade; d[i+2] = (35 + n*0.3) * shade; d[i+3] = 255;
      } else {
        d[i]=d[i+1]=d[i+2]=d[i+3]=0;
      }
    }
    return d;
  }

  // Building
  building(seed=0) {
    const s=this.s, d=new Uint8Array(s*s*4), cx=s/2;
    const bw = s*0.4, bh = s*0.8;
    for(let y=0;y<s;y++) for(let x=0;x<s;x++) {
      const i=(y*s+x)*4;
      const inBuilding = Math.abs(x-cx) < bw && y > s-bh;
      if (!inBuilding) { d[i]=d[i+1]=d[i+2]=d[i+3]=0; continue; }

      const n = this._n(x,y,seed) * 15;
      const wx = ((x-cx+bw) % 12) < 6;
      const wy = (y % 14) < 8 && y < s-10;
      const isWindow = wx && wy && y > s*0.3;

      if (isWindow) {
        const glow = this._n(Math.floor(x/12), Math.floor(y/14), seed+50) > 0.5;
        if (glow) {
          d[i] = 180; d[i+1] = 170; d[i+2] = 120; d[i+3] = 255;
        } else {
          d[i] = 30; d[i+1] = 40; d[i+2] = 50; d[i+3] = 255;
        }
      } else {
        d[i] = 90 + n; d[i+1] = 85 + n; d[i+2] = 80 + n; d[i+3] = 255;
      }
    }
    return d;
  }

  // Rock
  rock(seed=0) {
    const s=this.s, d=new Uint8Array(s*s*4), cx=s/2, cy=s*0.55;
    for(let y=0;y<s;y++) for(let x=0;x<s;x++) {
      const i=(y*s+x)*4;
      const dx = (x-cx)/(s*0.4), dy = (y-cy)/(s*0.35);
      const dist = dx*dx + dy*dy;
      if (dist > 1) { d[i]=d[i+1]=d[i+2]=d[i+3]=0; continue; }

      const n = this._n(x*2,y*2,seed) * 40;
      const shade = 1 - dist * 0.3 - dx * 0.2;
      d[i] = (100 + n) * shade; d[i+1] = (95 + n) * shade; d[i+2] = (85 + n) * shade; d[i+3] = 255;
    }
    return d;
  }

  // Wreckage
  wreckage(seed=0) {
    const s=this.s, d=new Uint8Array(s*s*4), cx=s/2;
    for(let y=0;y<s;y++) for(let x=0;x<s;x++) {
      const i=(y*s+x)*4;
      const tilt = (y/s) * 10;
      const inBody = Math.abs(x-cx-tilt) < s*0.25 && y > s*0.3;

      if (!inBody) { d[i]=d[i+1]=d[i+2]=d[i+3]=0; continue; }

      const n = this._n(x,y,seed) * 30;
      const damaged = this._n(x*3,y*3,seed+100) > 0.7;

      if (damaged) {
        d[i] = 40 + n; d[i+1] = 35 + n; d[i+2] = 30 + n; d[i+3] = 255;
      } else {
        d[i] = 70 + n; d[i+1] = 75 + n; d[i+2] = 65 + n; d[i+3] = 255;
      }
    }
    return d;
  }

  // Tower
  tower(seed=0) {
    const s=this.s, d=new Uint8Array(s*s*4), cx=s/2;
    for(let y=0;y<s;y++) for(let x=0;x<s;x++) {
      const i=(y*s+x)*4;
      const inPole = Math.abs(x-cx) < s*0.03;
      const beamY = y % 16 < 3;
      const beamWidth = (1 - y/s) * s * 0.3;
      const inBeam = beamY && Math.abs(x-cx) < beamWidth && y < s*0.9;
      const inDish = y < s*0.15 && Math.abs(x-cx) < s*0.15;

      if (inPole || inBeam || inDish) {
        const n = this._n(x,y,seed) * 20;
        d[i] = 120 + n; d[i+1] = 115 + n; d[i+2] = 110 + n; d[i+3] = 255;
      } else {
        d[i]=d[i+1]=d[i+2]=d[i+3]=0;
      }
    }
    return d;
  }
}

// ‚îÄ‚îÄ‚îÄ LIGHTING SYSTEM ‚îÄ‚îÄ‚îÄ
class LightingSystem {
  constructor() { this.lights=[]; this.ambientLevel=0.25; this.time=0; this._pos=new Float32Array(16*2); this._col=new Float32Array(16*3); this._par=new Float32Array(16*2); }
  addLight(c) {
    if(this.lights.length>=16) return null;
    const l={id:this.lights.length,x:c.x||0,y:c.y||0,radius:c.radius||5,intensity:c.intensity||1,color:c.color||[1,0.95,0.85],flicker:c.flicker||0,flickerOffset:Math.random()*100,pulse:c.pulse||0,pulseMin:c.pulseMin||0.5,active:true,type:c.type||'point',currentIntensity:c.intensity||1};
    this.lights.push(l); return l;
  }
  update(dt,px,py,angle) {
    this.time+=dt;
    for(const l of this.lights) {
      if(l.type==='player') { l.x=px+Math.cos(angle)*0.3; l.y=py+Math.sin(angle)*0.3; }
      l.currentIntensity=l.intensity;
      if(l.flicker>0) { const fn=Math.sin(this.time*15+l.flickerOffset)*0.3+Math.sin(this.time*23+l.flickerOffset*2)*0.2; l.currentIntensity*=1+fn*l.flicker*0.3; }
      if(l.pulse>0) { const pv=(Math.sin(this.time*l.pulse)+1)*0.5; l.currentIntensity*=l.pulseMin+(1-l.pulseMin)*pv; }
      l.currentIntensity=Math.max(0,Math.min(2,l.currentIntensity));
    }
  }
  getLightData() {
    let count=0;
    for(const l of this.lights) { if(!l.active||count>=16) continue; this._pos[count*2]=l.x; this._pos[count*2+1]=l.y; this._col[count*3]=l.color[0]; this._col[count*3+1]=l.color[1]; this._col[count*3+2]=l.color[2]; this._par[count*2]=l.radius; this._par[count*2+1]=l.currentIntensity; count++; }
    return {positions:this._pos,colors:this._col,params:this._par,count};
  }
  calcLightAt(wx,wy) {
    let total=this.ambientLevel, tR=0,tG=0,tB=0;
    for(const l of this.lights) { if(!l.active) continue; const dx=wx-l.x,dy=wy-l.y,dist=Math.sqrt(dx*dx+dy*dy); let a=Math.max(0,1-dist/l.radius); a=a*a*l.currentIntensity; total+=a; tR+=l.color[0]*a; tG+=l.color[1]*a; tB+=l.color[2]*a; }
    return {intensity:Math.min(total,2),tint:[tR,tG,tB]};
  }
  setAmbient(v) { this.ambientLevel=v; }
}

// ‚îÄ‚îÄ‚îÄ WALL TEXTURE GENERATOR ‚îÄ‚îÄ‚îÄ
class TexGen {
  constructor(s=64) { this.s=s; }
  _n(x,y,seed=0) { const n=Math.sin(x*12.9898+y*78.233+seed)*43758.5453; return n-Math.floor(n); }
  _fbm(x,y,oct=4,seed=0) { let v=0,a=0.5,f=1; for(let i=0;i<oct;i++) { v+=a*this._n(x*f,y*f,seed+i*100); a*=0.5; f*=2; } return v; }
  gen(fn,...args) { const s=this.s,d=new Uint8Array(s*s*4); for(let y=0;y<s;y++) for(let x=0;x<s;x++) { const[r,g,b]=fn.call(this,x,y,s,...args); const i=(y*s+x)*4; d[i]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255; } return d; }
  cliff(x,y,s,base,seed) { const n=this._fbm(x/4,y/8,4,seed)*60; return [Math.max(0,Math.min(255,base[0]+n)),Math.max(0,Math.min(255,base[1]+n-5)),Math.max(0,Math.min(255,base[2]+n-10))]; }
  brick(x,y,s,base,seed) { const row=Math.floor(y/8),ox=(row%2)*8,bx=(x+ox)%16,by=y%8; if(bx<2||by<2) return [55,52,48]; const bv=(this._n(Math.floor((x+ox)/16)+row*1000,0,seed)-0.5)*60; return [Math.max(0,Math.min(255,base[0]+bv)),Math.max(0,Math.min(255,base[1]+bv*0.8)),Math.max(0,Math.min(255,base[2]+bv*0.6))]; }
  concrete(x,y,s,base,seed) { const t=this._fbm(x/4,y/4,4,seed)*50-25; return [Math.max(0,Math.min(255,base[0]+t)),Math.max(0,Math.min(255,base[1]+t)),Math.max(0,Math.min(255,base[2]+t))]; }
  grass(x,y,s,base,seed) { const n=this._fbm(x/3,y/3,4,seed)*40-20; const blade=this._n(x*10,y*10,seed)>0.85?20:0; return [Math.max(0,Math.min(255,base[0]+n)),Math.max(0,Math.min(255,base[1]+n+blade)),Math.max(0,Math.min(255,base[2]+n))]; }
  dirt(x,y,s,base,seed) { const n=this._fbm(x/4,y/4,4,seed)*50-25; return [Math.max(0,Math.min(255,base[0]+n)),Math.max(0,Math.min(255,base[1]+n*0.9)),Math.max(0,Math.min(255,base[2]+n*0.7))]; }
  sand(x,y,s,base,seed) { const n=this._fbm(x/5,y/5,3,seed)*30-15; return [Math.max(0,Math.min(255,base[0]+n)),Math.max(0,Math.min(255,base[1]+n)),Math.max(0,Math.min(255,base[2]+n*0.8))]; }
  road(x,y,s,base,seed) { const stripe=(Math.abs(x-s/2)<3&&(y%20)<12)?1:0; if(stripe) return [200,180,50]; const n=this._n(x,y,seed)*15; return [Math.max(0,Math.min(255,base[0]+n)),Math.max(0,Math.min(255,base[1]+n)),Math.max(0,Math.min(255,base[2]+n))]; }
  sky(x,y,s,base,seed) { if(this._n(x*5,y*5,seed)>0.97) return [220,220,240]; return [base[0],base[1],base[2]]; }
}

// ‚îÄ‚îÄ‚îÄ WEBGL2 RENDERER ‚îÄ‚îÄ‚îÄ
class Renderer {
  constructor(cfg={}) { this.rayCount=cfg.rayCount||500; this.fov=cfg.fov||Math.PI*0.55; this.maxDepth=cfg.maxDepth||20; this.texGen=new TexGen(64); this.spriteTexGen=new SpriteTexGen(64); this.drawCalls=0; this.spriteCount=0; }

  init(canvas) {
    this.canvas=canvas; this.gl=canvas.getContext('webgl2',{antialias:false,alpha:false});
    if(!this.gl) return false;
    this._initWallProg(); this._initFloorProg(); this._initSpriteProg();
    this._initBuffers(); this._initTextures(); this._initSpriteTextures(); this._initWorldTex();
    this.resize(); window.addEventListener('resize',()=>this.resize());
    return true;
  }

  resize() { const c=this.canvas.parentElement; this.width=c.clientWidth; this.height=c.clientHeight; this.canvas.width=this.width; this.canvas.height=this.height; this.gl.viewport(0,0,this.width,this.height); }
  _compile(type,src) { const gl=this.gl,s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s)); return s; }
  _program(vs,fs) { const gl=this.gl,p=gl.createProgram(); gl.attachShader(p,this._compile(gl.VERTEX_SHADER,vs)); gl.attachShader(p,this._compile(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p); return p; }

  _initWallProg() {
    const vs=`#version 300 es
      in vec2 aPos; in vec2 aUV; in float aTex; in float aFog; in float aSide; in vec2 aWP;
      out vec2 vUV; flat out int vTex; out float vFog; out float vSide; out vec2 vWP;
      void main() { gl_Position=vec4(aPos,0,1); vUV=aUV; vTex=int(aTex); vFog=aFog; vSide=aSide; vWP=aWP; }`;
    const fs=`#version 300 es
      precision highp float; precision highp sampler2DArray;
      in vec2 vUV; flat in int vTex; in float vFog; in float vSide; in vec2 vWP;
      uniform sampler2DArray uTex; uniform float uAmb; uniform int uLC; uniform vec2 uLP[16]; uniform vec3 uLCol[16]; uniform vec2 uLPar[16];
      out vec4 fc;
      void main() {
        vec3 c=texture(uTex,vec3(fract(vUV),float(vTex))).rgb; c*=mix(1.0,0.75,vSide);
        float tl=uAmb; vec3 tint=vec3(0);
        for(int i=0;i<16;i++) { if(i>=uLC) break; float d=distance(vWP,uLP[i]); float a=max(0.0,1.0-d/uLPar[i].x); a=a*a*uLPar[i].y; tl+=a; tint+=uLCol[i]*a; }
        c*=min(tl,2.0); if(length(tint)>0.01) c*=normalize(vec3(1)+tint*0.5);
        c=mix(c,vec3(0.55,0.60,0.70),vFog); fc=vec4(c,1);
      }`;
    this.wallProg=this._program(vs,fs);
    const gl=this.gl;
    this.wA={pos:gl.getAttribLocation(this.wallProg,'aPos'),uv:gl.getAttribLocation(this.wallProg,'aUV'),tex:gl.getAttribLocation(this.wallProg,'aTex'),fog:gl.getAttribLocation(this.wallProg,'aFog'),side:gl.getAttribLocation(this.wallProg,'aSide'),wp:gl.getAttribLocation(this.wallProg,'aWP')};
    this.wU={tex:gl.getUniformLocation(this.wallProg,'uTex'),amb:gl.getUniformLocation(this.wallProg,'uAmb'),lc:gl.getUniformLocation(this.wallProg,'uLC'),lp:gl.getUniformLocation(this.wallProg,'uLP'),lcol:gl.getUniformLocation(this.wallProg,'uLCol'),lpar:gl.getUniformLocation(this.wallProg,'uLPar')};
  }

  _initFloorProg() {
    const vs=`#version 300 es
      in vec2 aPos; out vec2 vSP; void main() { gl_Position=vec4(aPos,0,1); vSP=aPos; }`;
    const fs=`#version 300 es
      precision highp float; precision highp sampler2DArray; precision highp sampler2D;
      in vec2 vSP;
      uniform sampler2DArray uTex; uniform sampler2D uWD; uniform sampler2D uWM;
      uniform vec2 uPP; uniform float uPA; uniform float uFov; uniform float uMD; uniform int uRC; uniform float uWS;
      uniform float uAmb; uniform int uLC; uniform vec2 uLP[16]; uniform vec3 uLCol[16]; uniform vec2 uLPar[16];
      out vec4 fc;
      int gFT(int t) { if(t==1) return 8; if(t==2) return 9; if(t==3) return 10; if(t==4) return 8; return 8; }
      int gCT(int t) { return 11; }
      void main() {
        vec2 uv=vSP*0.5+0.5; bool isF=uv.y<0.5; float p=isF?(0.5-uv.y):(uv.y-0.5);
        if(p<0.001) { fc=vec4(0.55,0.60,0.70,1); return; }
        float rd=0.5/p; if(rd>uMD) { fc=vec4(0.55,0.60,0.70,1); return; }
        float wd=texture(uWD,vec2(uv.x*float(uRC)/1024.0,0.5)).r;
        if(rd>wd) discard;
        float ra=uPA+(uv.x-0.5)*uFov; float wx=uPP.x+rd*cos(ra); float wy=uPP.y+rd*sin(ra);
        vec2 muv=vec2(wx/uWS,wy/uWS);
        if(muv.x<0.0||muv.x>1.0||muv.y<0.0||muv.y>1.0) { fc=vec4(0.55,0.60,0.70,1); return; }
        int st=int(texture(uWM,muv).r*255.0+0.5);
        if(st==0||st>=10) { fc=vec4(0.55,0.60,0.70,1); return; }
        vec3 c=texture(uTex,vec3(fract(vec2(wx,wy)),float(isF?gFT(st):gCT(st)))).rgb;
        float tl=uAmb; vec3 tint=vec3(0); vec2 wp=vec2(wx,wy);
        for(int i=0;i<16;i++) { if(i>=uLC) break; float d=distance(wp,uLP[i]); float a=max(0.0,1.0-d/uLPar[i].x); a=a*a*uLPar[i].y; tl+=a; tint+=uLCol[i]*a; }
        c*=min(tl,2.0); if(length(tint)>0.01) c*=normalize(vec3(1)+tint*0.5);
        c*=max(0.6,1.0-rd*0.02); c=mix(c,vec3(0.55,0.60,0.70),clamp((rd-10.0)*0.04,0.0,1.0));
        fc=vec4(c,1);
      }`;
    this.floorProg=this._program(vs,fs);
    const gl=this.gl;
    this.fA={pos:gl.getAttribLocation(this.floorProg,'aPos')};
    this.fU={tex:gl.getUniformLocation(this.floorProg,'uTex'),wd:gl.getUniformLocation(this.floorProg,'uWD'),wm:gl.getUniformLocation(this.floorProg,'uWM'),pp:gl.getUniformLocation(this.floorProg,'uPP'),pa:gl.getUniformLocation(this.floorProg,'uPA'),fov:gl.getUniformLocation(this.floorProg,'uFov'),md:gl.getUniformLocation(this.floorProg,'uMD'),rc:gl.getUniformLocation(this.floorProg,'uRC'),ws:gl.getUniformLocation(this.floorProg,'uWS'),amb:gl.getUniformLocation(this.floorProg,'uAmb'),lc:gl.getUniformLocation(this.floorProg,'uLC'),lp:gl.getUniformLocation(this.floorProg,'uLP'),lcol:gl.getUniformLocation(this.floorProg,'uLCol'),lpar:gl.getUniformLocation(this.floorProg,'uLPar')};
  }

  _initSpriteProg() {
    const vs=`#version 300 es
      in vec2 aPos; in vec2 aUV; in float aTex; in float aLight; in vec3 aTint; in float aDist;
      out vec2 vUV; out vec2 vScreenPos; flat out int vTex; out float vLight; out vec3 vTint; out float vDist;
      void main() { gl_Position=vec4(aPos,0,1); vUV=aUV; vScreenPos=aPos; vTex=int(aTex); vLight=aLight; vTint=aTint; vDist=aDist; }`;
    const fs=`#version 300 es
      precision highp float; precision highp sampler2DArray; precision highp sampler2D;
      in vec2 vUV; in vec2 vScreenPos; flat in int vTex; in float vLight; in vec3 vTint; in float vDist;
      uniform sampler2DArray uSTex;
      uniform sampler2D uWallDist;
      uniform int uRayCount;
      out vec4 fc;
      void main() {
        vec4 c=texture(uSTex,vec3(vUV,float(vTex)));
        if(c.a<0.5) discard;
        float screenU = (vScreenPos.x + 1.0) * 0.5;
        float wallDist = texture(uWallDist, vec2(screenU * float(uRayCount) / 1024.0, 0.5)).r;
        if(vDist >= wallDist) discard;
        c.rgb*=vLight; if(length(vTint)>0.01) c.rgb*=normalize(vec3(1)+vTint*0.5);
        fc=c;
      }`;
    this.spriteProg=this._program(vs,fs);
    const gl=this.gl;
    this.sA={pos:gl.getAttribLocation(this.spriteProg,'aPos'),uv:gl.getAttribLocation(this.spriteProg,'aUV'),tex:gl.getAttribLocation(this.spriteProg,'aTex'),light:gl.getAttribLocation(this.spriteProg,'aLight'),tint:gl.getAttribLocation(this.spriteProg,'aTint'),dist:gl.getAttribLocation(this.spriteProg,'aDist')};
    this.sU={tex:gl.getUniformLocation(this.spriteProg,'uSTex'),wallDist:gl.getUniformLocation(this.spriteProg,'uWallDist'),rayCount:gl.getUniformLocation(this.spriteProg,'uRayCount')};
  }

  _initBuffers() {
    const gl=this.gl;
    this.wallVAO=gl.createVertexArray(); gl.bindVertexArray(this.wallVAO);
    this.wallBuf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,this.wallBuf);
    const ws=9*4;
    gl.enableVertexAttribArray(this.wA.pos); gl.vertexAttribPointer(this.wA.pos,2,gl.FLOAT,false,ws,0);
    gl.enableVertexAttribArray(this.wA.uv); gl.vertexAttribPointer(this.wA.uv,2,gl.FLOAT,false,ws,8);
    gl.enableVertexAttribArray(this.wA.tex); gl.vertexAttribPointer(this.wA.tex,1,gl.FLOAT,false,ws,16);
    gl.enableVertexAttribArray(this.wA.fog); gl.vertexAttribPointer(this.wA.fog,1,gl.FLOAT,false,ws,20);
    gl.enableVertexAttribArray(this.wA.side); gl.vertexAttribPointer(this.wA.side,1,gl.FLOAT,false,ws,24);
    gl.enableVertexAttribArray(this.wA.wp); gl.vertexAttribPointer(this.wA.wp,2,gl.FLOAT,false,ws,28);
    this.floorVAO=gl.createVertexArray(); gl.bindVertexArray(this.floorVAO);
    this.floorBuf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,this.floorBuf);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,-1,1,1,-1,1]),gl.STATIC_DRAW);
    gl.enableVertexAttribArray(this.fA.pos); gl.vertexAttribPointer(this.fA.pos,2,gl.FLOAT,false,0,0);
    this.spriteVAO=gl.createVertexArray(); gl.bindVertexArray(this.spriteVAO);
    this.spriteBuf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,this.spriteBuf);
    const ss=10*4;
    gl.enableVertexAttribArray(this.sA.pos); gl.vertexAttribPointer(this.sA.pos,2,gl.FLOAT,false,ss,0);
    gl.enableVertexAttribArray(this.sA.uv); gl.vertexAttribPointer(this.sA.uv,2,gl.FLOAT,false,ss,8);
    gl.enableVertexAttribArray(this.sA.tex); gl.vertexAttribPointer(this.sA.tex,1,gl.FLOAT,false,ss,16);
    gl.enableVertexAttribArray(this.sA.light); gl.vertexAttribPointer(this.sA.light,1,gl.FLOAT,false,ss,20);
    gl.enableVertexAttribArray(this.sA.tint); gl.vertexAttribPointer(this.sA.tint,3,gl.FLOAT,false,ss,24);
    gl.enableVertexAttribArray(this.sA.dist); gl.vertexAttribPointer(this.sA.dist,1,gl.FLOAT,false,ss,36);
    gl.bindVertexArray(null);
    this.wallData=new Float32Array(1000*6*9); this.wallDistData=new Float32Array(1024); this.spriteData=new Float32Array(300*6*10);
  }

  _initTextures() {
    const gl=this.gl,tg=this.texGen,s=64;
    const texs=[
      tg.gen(tg.cliff,[120,110,100],42),
      tg.gen(tg.brick,[145,95,75],43),
      tg.gen(tg.concrete,[100,100,105],44),
      tg.gen(tg.cliff,[90,100,90],45),
      tg.gen(tg.concrete,[80,85,80],46),
      tg.gen(tg.brick,[100,90,85],47),
      tg.gen(tg.cliff,[110,105,95],48),
      tg.gen(tg.concrete,[90,95,100],49),
      tg.gen(tg.grass,[45,70,35],60),
      tg.gen(tg.dirt,[100,85,65],61),
      tg.gen(tg.road,[60,60,65],62),
      tg.gen(tg.sky,[135,160,200],70),
    ];
    this.texAtlas=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D_ARRAY,this.texAtlas);
    gl.texImage3D(gl.TEXTURE_2D_ARRAY,0,gl.RGBA,s,s,texs.length,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    for(let i=0;i<texs.length;i++) gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,0,0,0,i,s,s,1,gl.RGBA,gl.UNSIGNED_BYTE,texs[i]);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_WRAP_S,gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_WRAP_T,gl.REPEAT);
    gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
    this.wallDistTex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,this.wallDistTex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.R32F,1024,1,0,gl.RED,gl.FLOAT,null);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
    this.wallTexMap={'CLIFF':0,'BRICK':1,'CONCRETE':2,'MOSSY':3,'BUILDING':4,'TREE':4,'ROCK':0};
  }

  _initSpriteTextures() {
    const gl=this.gl,stg=this.spriteTexGen,s=64;
    const stexs=[stg.tree(42),stg.tree2(43),stg.building(44),stg.rock(45),stg.wreckage(46),stg.tower(47)];
    this.spriteAtlas=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D_ARRAY,this.spriteAtlas);
    gl.texImage3D(gl.TEXTURE_2D_ARRAY,0,gl.RGBA,s,s,stexs.length,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    for(let i=0;i<stexs.length;i++) gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,0,0,0,i,s,s,1,gl.RGBA,gl.UNSIGNED_BYTE,stexs[i]);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    gl.generateMipmap(gl.TEXTURE_2D_ARRAY);
  }

  _initWorldTex() {
    const gl=this.gl;
    this.worldSize = 48;
    this.worldMapTex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,this.worldMapTex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.R8,this.worldSize,this.worldSize,0,gl.RED,gl.UNSIGNED_BYTE,null);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
    this._worldMapData=new Uint8Array(this.worldSize*this.worldSize);
    this._worldMapTM={'void':0,'grass':1,'dirt':2,'road':3,'building':4};
  }

  updateWorldMap(world) {
    const gl=this.gl,data=this._worldMapData,tm=this._worldMapTM,ws=this.worldSize;
    for(let y=0;y<ws;y++) for(let x=0;x<ws;x++) data[y*ws+x]=tm[world.grid[y]?.[x]]||0;
    gl.bindTexture(gl.TEXTURE_2D,this.worldMapTex);
    gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,ws,ws,gl.RED,gl.UNSIGNED_BYTE,data);
  }

  setRayCount(n) { this.rayCount=n; }
  setViewDist(d) { this.maxDepth=d; }

  render(world,vis,px,py,angle,lighting,spriteManager) {
    const gl=this.gl; gl.clearColor(0.55,0.60,0.70,1); gl.clear(gl.COLOR_BUFFER_BIT);
    const ld=lighting.getLightData();

    profiler.start('walls');
    const colW=2/this.rayCount; let wv=0; const wd=this.wallData;
    for(let i=0;i<this.rayCount;i++) {
      const ra=angle+((i/this.rayCount)-0.5)*this.fov;
      const hit=this._castRay(world,vis,px,py,angle,ra);
      this.wallDistData[i]=hit?hit.dist:this.maxDepth;
      if(hit) {
        const x0=-1+i*colW,x1=x0+colW;
        const vs=[[x0,hit.top,hit.u,0],[x1,hit.top,hit.u,0],[x0,hit.bottom,hit.u,1],[x1,hit.top,hit.u,0],[x1,hit.bottom,hit.u,1],[x0,hit.bottom,hit.u,1]];
        for(let v=0;v<6;v++) { const idx=wv*9; wd[idx]=vs[v][0]; wd[idx+1]=vs[v][1]; wd[idx+2]=vs[v][2]; wd[idx+3]=vs[v][3]; wd[idx+4]=hit.tex; wd[idx+5]=hit.fog; wd[idx+6]=hit.side; wd[idx+7]=hit.worldX; wd[idx+8]=hit.worldY; wv++; }
      }
    }
    gl.bindTexture(gl.TEXTURE_2D,this.wallDistTex);
    gl.texSubImage2D(gl.TEXTURE_2D,0,0,0,this.rayCount,1,gl.RED,gl.FLOAT,this.wallDistData.subarray(0,this.rayCount));
    profiler.end('walls');

    profiler.start('floors');
    this.drawCalls=0;
    gl.useProgram(this.floorProg); gl.bindVertexArray(this.floorVAO);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D_ARRAY,this.texAtlas); gl.uniform1i(this.fU.tex,0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D,this.wallDistTex); gl.uniform1i(this.fU.wd,1);
    gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D,this.worldMapTex); gl.uniform1i(this.fU.wm,2);
    gl.uniform2f(this.fU.pp,px,py); gl.uniform1f(this.fU.pa,angle); gl.uniform1f(this.fU.fov,this.fov); gl.uniform1f(this.fU.md,this.maxDepth); gl.uniform1i(this.fU.rc,this.rayCount); gl.uniform1f(this.fU.ws,this.worldSize);
    gl.uniform1f(this.fU.amb,lighting.ambientLevel); gl.uniform1i(this.fU.lc,ld.count);
    gl.uniform2fv(this.fU.lp,ld.positions); gl.uniform3fv(this.fU.lcol,ld.colors); gl.uniform2fv(this.fU.lpar,ld.params);
    gl.drawArrays(gl.TRIANGLES,0,6); this.drawCalls++;
    profiler.end('floors');

    if(wv>0) {
      gl.useProgram(this.wallProg); gl.bindVertexArray(this.wallVAO);
      gl.bindBuffer(gl.ARRAY_BUFFER,this.wallBuf); gl.bufferData(gl.ARRAY_BUFFER,wd.subarray(0,wv*9),gl.DYNAMIC_DRAW);
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D_ARRAY,this.texAtlas); gl.uniform1i(this.wU.tex,0);
      gl.uniform1f(this.wU.amb,lighting.ambientLevel); gl.uniform1i(this.wU.lc,ld.count);
      gl.uniform2fv(this.wU.lp,ld.positions); gl.uniform3fv(this.wU.lcol,ld.colors); gl.uniform2fv(this.wU.lpar,ld.params);
      gl.drawArrays(gl.TRIANGLES,0,wv); this.drawCalls++;
    }

    profiler.start('sprites');
    this._renderSprites(spriteManager,px,py,angle,lighting);
    profiler.end('sprites');
  }

  _renderSprites(spriteManager,px,py,angle,lighting) {
    const gl=this.gl, sprites=spriteManager.getVisible();
    if(sprites.length===0) { this.spriteCount=0; return; }
    const sd=this.spriteData; let sv=0;
    const halfFov=this.fov/2, halfFovTan=Math.tan(halfFov), ar=this.width/this.height;

    for(const sp of sprites) {
      const screenX=sp.screenX/halfFovTan, dist=sp.distance;
      const sH=(sp.scale*1.5)/dist, sW=sH/ar;
      const left=screenX-sW/2, right=screenX+sW/2;
      const top=sH*0.35, bottom=-sH*0.65;
      if(right<-1||left>1) continue;

      const leftU = (left + 1.0) * 0.5;
      const rightU = (right + 1.0) * 0.5;
      const leftCol = Math.floor(leftU * this.rayCount);
      const rightCol = Math.floor(rightU * this.rayCount);
      const colStart = Math.max(0, leftCol);
      const colEnd = Math.min(this.rayCount - 1, rightCol);

      let hasVisiblePortion = false;
      for (let col = colStart; col <= colEnd; col++) {
        if (dist < this.wallDistData[col]) { hasVisiblePortion = true; break; }
      }
      if (!hasVisiblePortion) continue;

      const li=lighting.calcLightAt(sp.x,sp.y);
      const verts=[[left,top,0,0],[right,top,1,0],[left,bottom,0,1],[right,top,1,0],[right,bottom,1,1],[left,bottom,0,1]];
      for(let v=0;v<6;v++) { const idx=sv*10; sd[idx]=verts[v][0]; sd[idx+1]=verts[v][1]; sd[idx+2]=verts[v][2]; sd[idx+3]=verts[v][3]; sd[idx+4]=sp.texture; sd[idx+5]=li.intensity; sd[idx+6]=li.tint[0]; sd[idx+7]=li.tint[1]; sd[idx+8]=li.tint[2]; sd[idx+9]=dist; sv++; }
    }

    this.spriteCount=sv/6;
    if(sv>0) {
      gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
      gl.useProgram(this.spriteProg); gl.bindVertexArray(this.spriteVAO);
      gl.bindBuffer(gl.ARRAY_BUFFER,this.spriteBuf); gl.bufferData(gl.ARRAY_BUFFER,sd.subarray(0,sv*10),gl.DYNAMIC_DRAW);
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D_ARRAY,this.spriteAtlas); gl.uniform1i(this.sU.tex,0);
      gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D,this.wallDistTex); gl.uniform1i(this.sU.wallDist,1);
      gl.uniform1i(this.sU.rayCount,this.rayCount);
      gl.drawArrays(gl.TRIANGLES,0,sv); this.drawCalls++;
      gl.disable(gl.BLEND);
    }
  }

  _castRay(world,vis,px,py,va,ra) {
    const step=0.02,cosA=Math.cos(ra),sinA=Math.sin(ra),cosCorr=Math.cos(ra-va);
    let x=px,y=py,dist=0;
    while(dist<this.maxDepth) {
      x+=cosA*step; y+=sinA*step; dist+=step;
      const gx=Math.floor(x),gy=Math.floor(y),sec=world.getSector(x,y);
      if(!sec.walkable) {
        if(!vis.isVisible(gx,gy)&&!vis.isDiscovered(gx,gy)) return null;
        const cd=dist*cosCorr,wh=Math.min(2,1.7/cd);
        const hx=x-gx,hy=y-gy,isNS=hx<0.03||hx>0.97;
        return {dist:cd,top:wh/2,bottom:-wh/2,u:isNS?hy:hx,tex:this.wallTexMap[sec.name]||0,fog:Math.max(0,Math.min(1,(cd-8)*0.05)),side:isNS?1:0,worldX:x,worldY:y};
      }
    }
    return null;
  }
}

// ‚îÄ‚îÄ‚îÄ WORLD ‚îÄ‚îÄ‚îÄ
class World {
  constructor(cfg={}) { this.width=cfg.width||48; this.height=cfg.height||48; this.grid=Array(this.height).fill(null).map(()=>Array(this.width).fill('void')); this.sectorTypes=new Map(); this.sectorTypes.set('void',{walkable:false,floorColor:[30,30,35],name:'VOID'}); }
  registerSectorTypes(types) { for(const[k,v] of Object.entries(types)) this.sectorTypes.set(k,{...v}); }
  getSector(x,y) { const gx=Math.floor(x),gy=Math.floor(y); if(gx<0||gx>=this.width||gy<0||gy>=this.height) return this.sectorTypes.get('void'); return this.sectorTypes.get(this.grid[gy][gx])||this.sectorTypes.get('void'); }
  fillRect(x1,y1,x2,y2,type) { for(let y=Math.min(y1,y2);y<=Math.max(y1,y2);y++) for(let x=Math.min(x1,x2);x<=Math.max(x1,x2);x++) if(x>=0&&x<this.width&&y>=0&&y<this.height) this.grid[y][x]=type; }
  setCell(x,y,type) { if(x>=0&&x<this.width&&y>=0&&y<this.height) this.grid[y][x]=type; }
}

// ‚îÄ‚îÄ‚îÄ VISIBILITY ‚îÄ‚îÄ‚îÄ
class Visibility {
  constructor(world,cfg={}) { this.world=world; this.viewDistance=cfg.viewDistance||20; this.discovered=new Set(); this.currentlyVisible=new Set(); }
  update(x,y) {
    this.currentlyVisible.clear();
    for(let i=0;i<180;i++) {
      const angle=(i/180)*Math.PI*2;
      let rx=x,ry=y;
      const dx=Math.cos(angle)*0.5,dy=Math.sin(angle)*0.5;
      for(let d=0;d<this.viewDistance;d+=0.5) {
        rx+=dx; ry+=dy;
        const k=`${Math.floor(rx)},${Math.floor(ry)}`;
        this.currentlyVisible.add(k);
        const s=this.world.getSector(rx,ry);
        if(s.walkable) this.discovered.add(k);
        if(!s.walkable) break;
      }
    }
  }
  isVisible(gx,gy) { return this.currentlyVisible.has(`${gx},${gy}`); }
  isDiscovered(gx,gy) { return this.discovered.has(`${gx},${gy}`); }
}

// ‚îÄ‚îÄ‚îÄ MECH MOVEMENT ‚îÄ‚îÄ‚îÄ
class MechMovement {
  constructor(world) { this.world=world; }
  move(mech,dt) {
    const newX = mech.x + mech.velocity.x * dt;
    const newY = mech.y + mech.velocity.y * dt;
    const r = mech.radius || 0.3;

    if(this._canMove(newX, newY, r)) {
      mech.x = newX; mech.y = newY;
    } else if(this._canMove(newX, mech.y, r)) {
      mech.x = newX; mech.velocity.y *= 0.5;
    } else if(this._canMove(mech.x, newY, r)) {
      mech.y = newY; mech.velocity.x *= 0.5;
    } else {
      mech.velocity.x *= 0.3; mech.velocity.y *= 0.3;
    }
  }
  _canMove(x,y,r) {
    for(const[px,py] of [[x,y],[x-r,y-r],[x+r,y-r],[x-r,y+r],[x+r,y+r]])
      if(!this.world.getSector(px,py).walkable) return false;
    return true;
  }
}

// ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ
class Input {
  constructor() { this.keys={}; this.mouseDX=0; this.locked=false; }
  init(target) {
    window.addEventListener('keydown',e=>{ this.keys[e.code]=true; if(['KeyW','KeyA','KeyS','KeyD','KeyF'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup',e=>this.keys[e.code]=false);
    document.addEventListener('mousemove',e=>{ if(this.locked) this.mouseDX+=e.movementX; });
    document.addEventListener('pointerlockchange',()=>{ this.locked=document.pointerLockElement===target; document.getElementById('click-prompt').classList.toggle('hidden',this.locked); });
    target.addEventListener('click',()=>{ if(!this.locked) target.requestPointerLock(); });
  }
  consumeMouseDX() { const dx = this.mouseDX; this.mouseDX = 0; return dx; }
}

// ‚îÄ‚îÄ‚îÄ MINIMAP ‚îÄ‚îÄ‚îÄ
class Minimap {
  constructor(cfg={}) { this.fov=cfg.fov||Math.PI*0.55; }
  init(canvas) { this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.resize(); window.addEventListener('resize',()=>this.resize()); }
  resize() { const c=this.canvas.parentElement; const sz=Math.min(c.clientWidth-16,c.clientHeight-24); this.canvas.width=sz; this.canvas.height=sz; }
  render(world,vis,px,py,legAngle,torsoAngle,velocityAngle,sprites) {
    const ctx=this.ctx,w=this.canvas.width,h=this.canvas.height,cw=w/world.width,ch=h/world.height;
    ctx.fillStyle='#030305'; ctx.fillRect(0,0,w,h);
    for(let gy=0;gy<world.height;gy++) for(let gx=0;gx<world.width;gx++) {
      const sec=world.getSector(gx,gy),v=vis.isVisible(gx,gy),d=vis.isDiscovered(gx,gy);
      let col; if(!d&&!v) col='#050508'; else if(!sec.walkable) col=v?'#3a3a45':'#1a1a22'; else if(v) { const c=sec.floorColor; col=`rgb(${c[0]*0.6|0},${c[1]*0.6|0},${c[2]*0.6|0})`; } else col='#121215';
      ctx.fillStyle=col; ctx.fillRect(gx*cw,gy*ch,cw+0.5,ch+0.5);
    }
    ctx.fillStyle='#336633';
    for(const sp of sprites) { ctx.beginPath(); ctx.arc(sp.x*cw,sp.y*ch,2,0,Math.PI*2); ctx.fill(); }
    const mx=px*cw,my=py*ch;
    // Velocity direction (yellow)
    if(velocityAngle !== null) {
      ctx.strokeStyle='#ffaa00'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(velocityAngle)*14,my+Math.sin(velocityAngle)*14); ctx.stroke();
    }
    // Legs direction (gray)
    ctx.strokeStyle='#666'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(legAngle)*10,my+Math.sin(legAngle)*10); ctx.stroke();
    // Torso direction (green)
    ctx.strokeStyle='#33ff33'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(mx,my); ctx.lineTo(mx+Math.cos(torsoAngle)*12,my+Math.sin(torsoAngle)*12); ctx.stroke();
    // Center
    ctx.fillStyle='#33ff33'; ctx.shadowColor='#33ff33'; ctx.shadowBlur=5;
    ctx.beginPath(); ctx.arc(mx,my,4,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COCKPIT HUD - Wing Commander Style
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CockpitHUD {
  constructor() {
    this.chassisVariant = 0; // Different cockpit styles per mech
    this.warningFlash = 0;
    this.damageFlash = 0;
  }

  init(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.resize();
    window.addEventListener('resize', () => this.resize());
  }

  resize() {
    const c = this.canvas.parentElement;
    this.width = c.clientWidth;
    this.height = c.clientHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
  }

  render(mech, time) {
    const ctx = this.ctx, w = this.width, h = this.height;
    ctx.clearRect(0, 0, w, h);

    // Calculate derived values
    const speed = Math.sqrt(mech.velocity.x ** 2 + mech.velocity.y ** 2) * 3.6;
    const heatPct = mech.heat / mech.maxHeat;
    const throttlePct = mech.throttle;

    // Velocity angle (direction of actual movement)
    let velocityAngle = null;
    if (speed > 1) {
      velocityAngle = Math.atan2(mech.velocity.y, mech.velocity.x);
    }

    // Draw cockpit frame
    this._drawCockpitFrame(ctx, w, h);

    // Draw left console (throttle, speed)
    this._drawLeftConsole(ctx, w, h, throttlePct, speed, mech.maxSpeed);

    // Draw right console (heat, armor)
    this._drawRightConsole(ctx, w, h, heatPct, mech.armor || 1.0, time);

    // Draw center console (targeting, velocity vector)
    this._drawCenterHUD(ctx, w, h, mech, velocityAngle, speed);

    // Draw indicator lights panel
    this._drawIndicatorLights(ctx, w, h, mech, heatPct, time);

    // Draw compass/heading
    this._drawCompass(ctx, w, h, mech.torsoAngle, mech.legAngle);

    // Vignette
    const vig = ctx.createRadialGradient(w/2, h/2, h*0.3, w/2, h/2, h*0.85);
    vig.addColorStop(0, 'rgba(0,0,0,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.6)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, w, h);
  }

  _drawCockpitFrame(ctx, w, h) {
    // Main cockpit frame - angled panels
    ctx.fillStyle = '#1a1a1f';
    ctx.strokeStyle = '#2a2a30';
    ctx.lineWidth = 2;

    // Bottom panel (main console)
    ctx.beginPath();
    ctx.moveTo(0, h);
    ctx.lineTo(0, h * 0.78);
    ctx.lineTo(w * 0.15, h * 0.72);
    ctx.lineTo(w * 0.35, h * 0.75);
    ctx.lineTo(w * 0.5, h * 0.78);
    ctx.lineTo(w * 0.65, h * 0.75);
    ctx.lineTo(w * 0.85, h * 0.72);
    ctx.lineTo(w, h * 0.78);
    ctx.lineTo(w, h);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Left strut
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(w * 0.08, 0);
    ctx.lineTo(w * 0.12, h * 0.3);
    ctx.lineTo(w * 0.08, h * 0.72);
    ctx.lineTo(0, h * 0.78);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Right strut
    ctx.beginPath();
    ctx.moveTo(w, 0);
    ctx.lineTo(w * 0.92, 0);
    ctx.lineTo(w * 0.88, h * 0.3);
    ctx.lineTo(w * 0.92, h * 0.72);
    ctx.lineTo(w, h * 0.78);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Top frame
    ctx.beginPath();
    ctx.moveTo(w * 0.08, 0);
    ctx.lineTo(w * 0.92, 0);
    ctx.lineTo(w * 0.88, h * 0.05);
    ctx.lineTo(w * 0.12, h * 0.05);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Panel details (rivets/screws) - reduced count for perf
    ctx.fillStyle = '#333';
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      ctx.arc(w * 0.05, h * 0.15 + i * (h * 0.15), 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(w * 0.95, h * 0.15 + i * (h * 0.15), 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  _drawLeftConsole(ctx, w, h, throttlePct, speed, maxSpeed) {
    const consoleX = w * 0.03;
    const consoleY = h * 0.73;
    const consoleW = w * 0.18;
    const consoleH = h * 0.24;

    // Console background
    ctx.fillStyle = '#0a0a0c';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(consoleX, consoleY, consoleW, consoleH, 4);
    ctx.fill();
    ctx.stroke();

    // THROTTLE label
    ctx.fillStyle = '#666';
    ctx.font = '10px "Share Tech Mono"';
    ctx.fillText('THROTTLE', consoleX + 8, consoleY + 14);

    // Throttle gauge (vertical bar with needle)
    const gaugeX = consoleX + 20;
    const gaugeY = consoleY + 22;
    const gaugeW = 30;
    const gaugeH = consoleH - 50;

    // Gauge background
    ctx.fillStyle = '#111';
    ctx.fillRect(gaugeX, gaugeY, gaugeW, gaugeH);

    // Gauge markings
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      const y = gaugeY + gaugeH * (1 - i / 10);
      ctx.beginPath();
      ctx.moveTo(gaugeX, y);
      ctx.lineTo(gaugeX + (i % 5 === 0 ? 8 : 4), y);
      ctx.stroke();
    }

    // Zero line (center for reverse)
    const zeroY = gaugeY + gaugeH * 0.77; // 30% reverse range
    ctx.strokeStyle = '#ff6633';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(gaugeX, zeroY);
    ctx.lineTo(gaugeX + gaugeW, zeroY);
    ctx.stroke();

    // Throttle fill
    const normalizedThrottle = (throttlePct + 0.3) / 1.3; // -0.3 to 1.0 -> 0 to 1
    const fillH = normalizedThrottle * gaugeH;
    const fillY = gaugeY + gaugeH - fillH;

    const throttleGrad = ctx.createLinearGradient(gaugeX, gaugeY + gaugeH, gaugeX, gaugeY);
    if (throttlePct < 0) {
      throttleGrad.addColorStop(0, '#ff3333');
      throttleGrad.addColorStop(0.3, '#ff6633');
    } else {
      throttleGrad.addColorStop(0, '#33aa33');
      throttleGrad.addColorStop(0.5, '#33ff33');
      throttleGrad.addColorStop(1, '#aaff33');
    }
    ctx.fillStyle = throttleGrad;
    ctx.fillRect(gaugeX + 2, fillY, gaugeW - 4, fillH);

    // Throttle percentage
    ctx.fillStyle = throttlePct < 0 ? '#ff6633' : '#33ff33';
    ctx.font = 'bold 14px "Orbitron"';
    ctx.textAlign = 'right';
    ctx.fillText((throttlePct * 100).toFixed(0) + '%', consoleX + consoleW - 10, gaugeY + gaugeH / 2);
    ctx.textAlign = 'left';

    // SPEED dial gauge
    const dialX = consoleX + consoleW - 50;
    const dialY = consoleY + consoleH - 35;
    const dialR = 28;

    this._drawDialGauge(ctx, dialX, dialY, dialR, speed, maxSpeed, 'KPH', '#33ff33');
  }

  _drawRightConsole(ctx, w, h, heatPct, armorPct, time) {
    const consoleX = w * 0.79;
    const consoleY = h * 0.73;
    const consoleW = w * 0.18;
    const consoleH = h * 0.24;

    // Console background
    ctx.fillStyle = '#0a0a0c';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(consoleX, consoleY, consoleW, consoleH, 4);
    ctx.fill();
    ctx.stroke();

    // HEAT label
    ctx.fillStyle = '#666';
    ctx.font = '10px "Share Tech Mono"';
    ctx.fillText('REACTOR HEAT', consoleX + 8, consoleY + 14);

    // Heat gauge (vertical thermometer style)
    const gaugeX = consoleX + consoleW - 45;
    const gaugeY = consoleY + 22;
    const gaugeW = 25;
    const gaugeH = consoleH - 50;

    // Gauge background
    ctx.fillStyle = '#111';
    ctx.strokeStyle = '#333';
    ctx.beginPath();
    ctx.roundRect(gaugeX, gaugeY, gaugeW, gaugeH, 4);
    ctx.fill();
    ctx.stroke();

    // Danger zone markings
    ctx.fillStyle = 'rgba(255,50,50,0.2)';
    ctx.fillRect(gaugeX + 2, gaugeY + 2, gaugeW - 4, gaugeH * 0.3);

    // Warning zone
    ctx.fillStyle = 'rgba(255,170,50,0.15)';
    ctx.fillRect(gaugeX + 2, gaugeY + gaugeH * 0.3, gaugeW - 4, gaugeH * 0.2);

    // Heat fill
    const fillH = heatPct * (gaugeH - 4);
    const fillY = gaugeY + gaugeH - 2 - fillH;

    let heatColor;
    if (heatPct > 0.9) {
      heatColor = `rgba(255,50,50,${0.8 + Math.sin(time * 10) * 0.2})`;
    } else if (heatPct > 0.7) {
      heatColor = '#ff6633';
    } else if (heatPct > 0.5) {
      heatColor = '#ffaa33';
    } else {
      heatColor = '#33ff33';
    }
    ctx.fillStyle = heatColor;
    ctx.fillRect(gaugeX + 4, fillY, gaugeW - 8, fillH);

    // Heat percentage
    ctx.fillStyle = heatPct > 0.7 ? '#ff6633' : '#33ff33';
    ctx.font = 'bold 12px "Orbitron"';
    ctx.fillText((heatPct * 100).toFixed(0) + '¬∞', consoleX + 10, gaugeY + 20);

    // Armor dial gauge
    const dialX = consoleX + 45;
    const dialY = consoleY + consoleH - 35;
    const dialR = 28;

    this._drawDialGauge(ctx, dialX, dialY, dialR, armorPct * 100, 100, 'ARM', armorPct > 0.5 ? '#33ff33' : armorPct > 0.25 ? '#ffaa33' : '#ff3333');
  }

  _drawDialGauge(ctx, x, y, r, value, max, label, color) {
    // Dial background
    ctx.fillStyle = '#0a0a0c';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Dial arc (270 degrees)
    const startAngle = Math.PI * 0.75;
    const endAngle = Math.PI * 2.25;
    const arcRange = endAngle - startAngle;

    // Background arc
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x, y, r - 6, startAngle, endAngle);
    ctx.stroke();

    // Value arc
    const valueAngle = startAngle + (Math.min(value, max) / max) * arcRange;
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x, y, r - 6, startAngle, valueAngle);
    ctx.stroke();

    // Tick marks
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      const tickAngle = startAngle + (i / 10) * arcRange;
      const inner = r - 12;
      const outer = r - (i % 5 === 0 ? 16 : 14);
      ctx.beginPath();
      ctx.moveTo(x + Math.cos(tickAngle) * inner, y + Math.sin(tickAngle) * inner);
      ctx.lineTo(x + Math.cos(tickAngle) * outer, y + Math.sin(tickAngle) * outer);
      ctx.stroke();
    }

    // Needle
    ctx.strokeStyle = '#ff3333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(valueAngle) * (r - 10), y + Math.sin(valueAngle) * (r - 10));
    ctx.stroke();

    // Center cap
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fill();

    // Label
    ctx.fillStyle = '#666';
    ctx.font = '8px "Share Tech Mono"';
    ctx.textAlign = 'center';
    ctx.fillText(label, x, y + r + 10);
    ctx.textAlign = 'left';
  }

  _drawCenterHUD(ctx, w, h, mech, velocityAngle, speed) {
    const cx = w / 2;
    const cy = h / 2;

    // Targeting reticle
    ctx.strokeStyle = 'rgba(51,255,51,0.8)';
    ctx.lineWidth = 2;

    // Outer brackets
    const bracketSize = 40;
    const bracketGap = 30;

    // Top-left bracket
    ctx.beginPath();
    ctx.moveTo(cx - bracketGap - bracketSize, cy - bracketGap);
    ctx.lineTo(cx - bracketGap, cy - bracketGap);
    ctx.lineTo(cx - bracketGap, cy - bracketGap - bracketSize);
    ctx.stroke();

    // Top-right bracket
    ctx.beginPath();
    ctx.moveTo(cx + bracketGap + bracketSize, cy - bracketGap);
    ctx.lineTo(cx + bracketGap, cy - bracketGap);
    ctx.lineTo(cx + bracketGap, cy - bracketGap - bracketSize);
    ctx.stroke();

    // Bottom-left bracket
    ctx.beginPath();
    ctx.moveTo(cx - bracketGap - bracketSize, cy + bracketGap);
    ctx.lineTo(cx - bracketGap, cy + bracketGap);
    ctx.lineTo(cx - bracketGap, cy + bracketGap + bracketSize);
    ctx.stroke();

    // Bottom-right bracket
    ctx.beginPath();
    ctx.moveTo(cx + bracketGap + bracketSize, cy + bracketGap);
    ctx.lineTo(cx + bracketGap, cy + bracketGap);
    ctx.lineTo(cx + bracketGap, cy + bracketGap + bracketSize);
    ctx.stroke();

    // Inner crosshair
    ctx.strokeStyle = 'rgba(51,255,51,0.9)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx - 15, cy); ctx.lineTo(cx - 5, cy);
    ctx.moveTo(cx + 5, cy); ctx.lineTo(cx + 15, cy);
    ctx.moveTo(cx, cy - 15); ctx.lineTo(cx, cy - 5);
    ctx.moveTo(cx, cy + 5); ctx.lineTo(cx, cy + 15);
    ctx.stroke();

    // Center dot
    ctx.fillStyle = '#33ff33';
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fill();

    // Velocity vector indicator (shows direction of actual movement)
    if (velocityAngle !== null && speed > 2) {
      // Calculate relative angle between movement direction and where torso is facing
      let relativeAngle = velocityAngle - mech.torsoAngle;
      // Normalize to -PI to PI
      while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
      while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;

      // Project onto screen - horizontal offset based on angle difference
      // When moving where you're looking, marker is centered
      // When moving sideways/backwards, marker shifts to show that
      const maxOffsetX = w * 0.3;  // Max horizontal offset
      const maxOffsetY = h * 0.15; // Max vertical offset

      // Use sin for horizontal (left/right of view) and cos for depth feel
      const vvX = cx + Math.sin(relativeAngle) * maxOffsetX;
      // Vertical offset: moving backward = marker goes up, forward = down slightly
      const vvY = cy - Math.cos(relativeAngle) * maxOffsetY * 0.5 + maxOffsetY * 0.3;

      // Only draw if the marker would be reasonably on screen
      if (Math.abs(relativeAngle) < Math.PI * 0.8) {
        // Velocity vector marker (flight path marker style)
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 2;

        // Circle
        ctx.beginPath();
        ctx.arc(vvX, vvY, 10, 0, Math.PI * 2);
        ctx.stroke();

        // Wings (horizontal lines)
        ctx.beginPath();
        ctx.moveTo(vvX - 10, vvY);
        ctx.lineTo(vvX - 20, vvY);
        ctx.moveTo(vvX + 10, vvY);
        ctx.lineTo(vvX + 20, vvY);
        // Tail (vertical line down)
        ctx.moveTo(vvX, vvY + 10);
        ctx.lineTo(vvX, vvY + 18);
        ctx.stroke();
      } else {
        // Moving mostly backwards - show indicator at edge
        const edgeX = relativeAngle > 0 ? w * 0.85 : w * 0.15;
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(edgeX, cy - 15);
        ctx.lineTo(edgeX + (relativeAngle > 0 ? 10 : -10), cy);
        ctx.lineTo(edgeX, cy + 15);
        ctx.stroke();
        ctx.fillStyle = '#ff6600';
        ctx.font = '10px "Share Tech Mono"';
        ctx.textAlign = 'center';
        ctx.fillText('REV', edgeX, cy + 28);
        ctx.textAlign = 'left';
      }
    }

    // Speed readout (large, center bottom)
    ctx.fillStyle = '#33ff33';
    ctx.font = 'bold 28px "Orbitron"';
    ctx.textAlign = 'center';
    ctx.fillText(speed.toFixed(0), cx, h * 0.88);
    ctx.font = '12px "Share Tech Mono"';
    ctx.fillStyle = '#666';
    ctx.fillText('KPH', cx, h * 0.91);
    ctx.textAlign = 'left';
  }

  _drawIndicatorLights(ctx, w, h, mech, heatPct, time) {
    const panelX = w * 0.35;
    const panelY = h * 0.76;
    const panelW = w * 0.30;

    // Panel background
    ctx.fillStyle = 'rgba(10,10,12,0.9)';
    ctx.beginPath();
    ctx.roundRect(panelX, panelY, panelW, 22, 3);
    ctx.fill();

    // Indicator lights
    const lights = [
      { label: 'PWR', on: true, color: '#33ff33' },
      { label: 'THRT', on: Math.abs(mech.throttle) > 0.1, color: '#33ff33' },
      { label: 'HEAT', on: heatPct > 0.5, color: heatPct > 0.8 ? '#ff3333' : '#ffaa33', blink: heatPct > 0.8 },
      { label: 'LOCK', on: false, color: '#ff3333' },
      { label: 'WEAP', on: true, color: '#33ff33' },
      { label: 'AMMO', on: true, color: '#33ff33' },
    ];

    const lightSpacing = panelW / lights.length;

    lights.forEach((light, i) => {
      const lx = panelX + 15 + i * lightSpacing;
      const ly = panelY + 11;

      // Light housing
      ctx.fillStyle = '#1a1a1a';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(lx, ly, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Light
      let isOn = light.on;
      if (light.blink) {
        isOn = isOn && Math.sin(time * 8) > 0;
      }

      if (isOn) {
        ctx.fillStyle = light.color;
      } else {
        ctx.fillStyle = '#222';
      }
      ctx.beginPath();
      ctx.arc(lx, ly, 4, 0, Math.PI * 2);
      ctx.fill();

      // Label
      ctx.fillStyle = '#555';
      ctx.font = '7px "Share Tech Mono"';
      ctx.textAlign = 'center';
      ctx.fillText(light.label, lx, ly + 16);
    });
    ctx.textAlign = 'left';
  }

  _drawCompass(ctx, w, h, torsoAngle, legAngle) {
    const cx = w / 2;
    const cy = h * 0.06;
    const compassW = 200;

    // Compass background
    ctx.fillStyle = 'rgba(10,10,12,0.9)';
    ctx.beginPath();
    ctx.roundRect(cx - compassW/2, cy - 12, compassW, 24, 3);
    ctx.fill();

    // Convert angle to heading (0-360, 0=North)
    let heading = (-torsoAngle * 180 / Math.PI + 90) % 360;
    if (heading < 0) heading += 360;

    // Draw compass tape
    ctx.save();
    ctx.beginPath();
    ctx.rect(cx - compassW/2 + 5, cy - 10, compassW - 10, 20);
    ctx.clip();

    ctx.font = '10px "Share Tech Mono"';
    ctx.textAlign = 'center';

    const cardinals = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];

    for (let deg = -180; deg <= 540; deg += 15) {
      const relDeg = ((deg - heading + 180) % 360) - 180;
      const x = cx + relDeg * 1.5;

      if (x < cx - compassW/2 || x > cx + compassW/2) continue;

      const normDeg = ((deg % 360) + 360) % 360;

      if (normDeg % 45 === 0) {
        // Cardinal/intercardinal
        const idx = normDeg / 45;
        ctx.fillStyle = normDeg === 0 ? '#ff3333' : '#33ff33';
        ctx.fillText(cardinals[idx], x, cy + 4);
      } else if (normDeg % 15 === 0) {
        // Tick mark
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, cy - 6);
        ctx.lineTo(x, cy + 6);
        ctx.stroke();
      }
    }

    ctx.restore();

    // Center marker
    ctx.strokeStyle = '#33ff33';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy - 12);
    ctx.lineTo(cx, cy - 8);
    ctx.moveTo(cx, cy + 8);
    ctx.lineTo(cx, cy + 12);
    ctx.stroke();

    // Heading readout
    ctx.fillStyle = '#33ff33';
    ctx.font = 'bold 10px "Orbitron"';
    ctx.textAlign = 'center';
    ctx.fillText(heading.toFixed(0).padStart(3, '0') + '¬∞', cx, cy + 24);
    ctx.textAlign = 'left';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// WORLD GENERATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const SECTOR_TYPES = {
  grass: { walkable: true, floorColor: [50, 75, 40], name: 'GRASSLAND' },
  dirt: { walkable: true, floorColor: [95, 80, 60], name: 'DIRT PATH' },
  road: { walkable: true, floorColor: [65, 65, 70], name: 'ROAD' },
  building: { walkable: false, floorColor: [80, 80, 85], name: 'BUILDING' },
  tree: { walkable: false, floorColor: [40, 60, 35], name: 'TREE' },
  rock: { walkable: false, floorColor: [100, 95, 85], name: 'CLIFF' },
};

function generateOverworld(world, spriteManager) {
  world.fillRect(1, 1, world.width-2, world.height-2, 'grass');

  for(let i = 0; i < 8; i++) {
    const cx = 5 + Math.floor(Math.random() * (world.width - 10));
    const cy = 5 + Math.floor(Math.random() * (world.height - 10));
    const r = 2 + Math.floor(Math.random() * 3);
    world.fillRect(cx-r, cy-r, cx+r, cy+r, 'dirt');
  }

  world.fillRect(1, 22, world.width-2, 25, 'road');
  world.fillRect(22, 1, 25, world.height-2, 'road');

  const townX = 30, townY = 30;
  for(let i = 0; i < 5; i++) {
    const bx = townX + (i % 3) * 5;
    const by = townY + Math.floor(i / 3) * 5;
    world.fillRect(bx, by, bx+2, by+2, 'building');
    spriteManager.add({ x: bx + 1.5, y: by + 1.5, texture: 2, scale: 2.5 });
  }

  for(let i = 0; i < 40; i++) {
    const tx = 3 + Math.floor(Math.random() * 15);
    const ty = 3 + Math.floor(Math.random() * 15);
    if(world.getSector(tx, ty).walkable && world.getSector(tx, ty).name !== 'ROAD') {
      spriteManager.add({ x: tx + 0.5, y: ty + 0.5, texture: Math.random() > 0.5 ? 0 : 1, scale: 1.5 + Math.random() * 0.5 });
    }
  }

  for(let i = 0; i < 30; i++) {
    const tx = 2 + Math.floor(Math.random() * (world.width - 4));
    const ty = 2 + Math.floor(Math.random() * (world.height - 4));
    if(world.getSector(tx, ty).walkable && world.getSector(tx, ty).name === 'GRASSLAND') {
      spriteManager.add({ x: tx + 0.5, y: ty + 0.5, texture: Math.random() > 0.5 ? 0 : 1, scale: 1.2 + Math.random() * 0.6 });
    }
  }

  for(let i = 0; i < 8; i++) {
    const rx = 5 + Math.floor(Math.random() * (world.width - 10));
    const ry = 5 + Math.floor(Math.random() * (world.height - 10));
    if(world.getSector(rx, ry).name === 'GRASSLAND') {
      world.setCell(rx, ry, 'rock');
      spriteManager.add({ x: rx + 0.5, y: ry + 0.5, texture: 3, scale: 1.0 + Math.random() * 0.5 });
    }
  }

  spriteManager.add({ x: 15.5, y: 35.5, texture: 4, scale: 2.0 });
  spriteManager.add({ x: 40.5, y: 10.5, texture: 4, scale: 1.8 });

  spriteManager.add({ x: 8.5, y: 8.5, texture: 5, scale: 2.5 });
  spriteManager.add({ x: 42.5, y: 42.5, texture: 5, scale: 2.2 });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MECH STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const mech = {
  x: 24,
  y: 24,
  legAngle: 0,
  torsoAngle: 0,
  velocity: { x: 0, y: 0 },
  throttle: 0,
  maxSpeed: 54,        // Reduced from 86 - more mech-like (was way too fast)
  acceleration: 8,     // Reduced from 25 - slower to build up speed
  deceleration: 12,    // Slightly faster braking than accel
  turnRate: 0.6,       // Reduced from 1.0 - mechs are lumbering
  torsoTurnRate: 2.5,
  torsoTwistLimit: Math.PI / 2.5,
  heat: 0,
  maxHeat: 30,
  heatDissipation: 2,
  radius: 0.4,
  armor: 1.0,
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SETUP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const world = new World({ width: 48, height: 48 });
world.registerSectorTypes(SECTOR_TYPES);

const spriteManager = new SpriteManager();
generateOverworld(world, spriteManager);

const visibility = new Visibility(world, { viewDistance: 22 });
const mechMovement = new MechMovement(world);
const input = new Input();
const renderer = new Renderer({ rayCount: 500, maxDepth: 22 });
const cockpitHUD = new CockpitHUD();
const minimap = new Minimap();
const lighting = new LightingSystem();

lighting.setAmbient(0.35);
lighting.addLight({ x: 24, y: 24, radius: 30, intensity: 0.3, color: [1, 0.98, 0.9], flicker: 0 });

const flashlight = lighting.addLight({ x: mech.x, y: mech.y, radius: 10, intensity: 0, color: [1, 1, 0.95], type: 'player' });
let flashlightOn = false;

renderer.init(document.getElementById('game-canvas'));
renderer.updateWorldMap(world);
cockpitHUD.init(document.getElementById('cockpit-canvas'));
minimap.init(document.getElementById('minimap-canvas'));
input.init(document.getElementById('viewport'));
visibility.update(mech.x, mech.y);

document.getElementById('tune-rays').addEventListener('input', e => {
  renderer.setRayCount(parseInt(e.target.value));
  document.getElementById('tune-rays-val').textContent = e.target.value;
});
document.getElementById('tune-viewdist').addEventListener('input', e => {
  renderer.setViewDist(parseInt(e.target.value));
  visibility.viewDistance = parseInt(e.target.value);
  document.getElementById('tune-viewdist-val').textContent = e.target.value;
});

function showMessage(t) {
  const log = document.getElementById('messages');
  const msg = document.createElement('div');
  msg.className = 'message';
  msg.textContent = t;
  log.appendChild(msg);
  setTimeout(() => msg.remove(), 3500);
}

let lastFKey = false;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let lastTime = 0, uiTimer = 0, gameTime = 0;

function gameLoop(time) {
  profiler.start('frame');
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  gameTime += dt;

  // ‚îÄ‚îÄ‚îÄ INPUT PROCESSING ‚îÄ‚îÄ‚îÄ

  // Throttle is a LEVER - stays where you set it (no decay!)
  if (input.keys['KeyW']) {
    mech.throttle = Math.min(1, mech.throttle + dt * 0.4); // Slower ramp up
  } else if (input.keys['KeyS']) {
    mech.throttle = Math.max(-0.3, mech.throttle - dt * 0.4); // Slower ramp down
  }
  // NO ELSE - throttle stays where it is!

  if (input.keys['KeyA']) mech.legAngle -= mech.turnRate * dt;
  if (input.keys['KeyD']) mech.legAngle += mech.turnRate * dt;

  while (mech.legAngle < 0) mech.legAngle += Math.PI * 2;
  while (mech.legAngle >= Math.PI * 2) mech.legAngle -= Math.PI * 2;

  const mouseDX = input.consumeMouseDX();
  mech.torsoAngle += mouseDX * 0.003;

  let torsoOffset = mech.torsoAngle - mech.legAngle;
  while (torsoOffset > Math.PI) torsoOffset -= Math.PI * 2;
  while (torsoOffset < -Math.PI) torsoOffset += Math.PI * 2;

  if (torsoOffset > mech.torsoTwistLimit) {
    mech.torsoAngle = mech.legAngle + mech.torsoTwistLimit;
  } else if (torsoOffset < -mech.torsoTwistLimit) {
    mech.torsoAngle = mech.legAngle - mech.torsoTwistLimit;
  }

  if (input.keys['KeyF'] && !lastFKey) {
    flashlightOn = !flashlightOn;
    flashlight.intensity = flashlightOn ? 1.2 : 0;
    showMessage(flashlightOn ? 'SPOTLIGHT ON' : 'SPOTLIGHT OFF');
  }
  lastFKey = input.keys['KeyF'];

  // ‚îÄ‚îÄ‚îÄ MECH PHYSICS ‚îÄ‚îÄ‚îÄ

  const targetSpeed = mech.throttle * mech.maxSpeed / 3.6;
  const currentSpeed = Math.sqrt(mech.velocity.x ** 2 + mech.velocity.y ** 2);
  const speedDiff = targetSpeed - currentSpeed;

  // Use acceleration when speeding up, deceleration when slowing down
  const accelRate = speedDiff > 0 ? mech.acceleration : mech.deceleration;
  const accel = Math.sign(speedDiff) * Math.min(Math.abs(speedDiff), accelRate * dt);

  const targetVelX = Math.cos(mech.legAngle) * (currentSpeed + accel);
  const targetVelY = Math.sin(mech.legAngle) * (currentSpeed + accel);

  // Slower velocity blending for heavier mech feel
  mech.velocity.x += (targetVelX - mech.velocity.x) * 0.05;
  mech.velocity.y += (targetVelY - mech.velocity.y) * 0.05;

  mechMovement.move(mech, dt);

  mech.heat = Math.max(0, mech.heat - mech.heatDissipation * dt);

  // ‚îÄ‚îÄ‚îÄ UPDATE SYSTEMS ‚îÄ‚îÄ‚îÄ

  visibility.update(mech.x, mech.y);
  lighting.update(dt, mech.x, mech.y, mech.torsoAngle);
  spriteManager.update(mech.x, mech.y, mech.torsoAngle, renderer.fov, renderer.maxDepth);

  // ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ

  renderer.render(world, visibility, mech.x, mech.y, mech.torsoAngle, lighting, spriteManager);
  cockpitHUD.render(mech, gameTime);

  // Calculate velocity angle for minimap
  const speed = Math.sqrt(mech.velocity.x ** 2 + mech.velocity.y ** 2) * 3.6;
  let velocityAngle = null;
  if (speed > 1) {
    velocityAngle = Math.atan2(mech.velocity.y, mech.velocity.x);
  }
  minimap.render(world, visibility, mech.x, mech.y, mech.legAngle, mech.torsoAngle, velocityAngle, spriteManager.sprites);

  profiler.end('frame');

  // ‚îÄ‚îÄ‚îÄ UI UPDATES ‚îÄ‚îÄ‚îÄ

  uiTimer += dt;
  if (uiTimer > 0.1) {
    uiTimer = 0;
    const frame = profiler.getAvg('frame');
    const fps = frame > 0 ? 1000 / frame : 0;
    const heatPct = (mech.heat / mech.maxHeat) * 100;

    document.getElementById('stat-fps').textContent = fps.toFixed(0);
    document.getElementById('stat-fps').className = 'stat-value' + (fps >= 55 ? '' : fps >= 30 ? ' warn' : ' danger');
    document.getElementById('stat-frame').textContent = frame.toFixed(1) + 'ms';
    document.getElementById('stat-heat').textContent = heatPct.toFixed(0) + '%';
    document.getElementById('stat-heat').className = 'stat-value' + (heatPct < 70 ? '' : heatPct < 90 ? ' warn' : ' danger');
    document.getElementById('stat-speed').textContent = speed.toFixed(0) + ' KPH';
    document.getElementById('stat-sector').textContent = world.getSector(mech.x, mech.y).name || '--';

    document.getElementById('perf-frame').textContent = frame.toFixed(2) + 'ms';
    document.getElementById('perf-walls').textContent = profiler.getAvg('walls').toFixed(2) + 'ms';
    document.getElementById('perf-floors').textContent = profiler.getAvg('floors').toFixed(2) + 'ms';
    document.getElementById('perf-sprites').textContent = profiler.getAvg('sprites').toFixed(2) + 'ms';
  }

  requestAnimationFrame(gameLoop);
}

// ‚îÄ‚îÄ‚îÄ START ‚îÄ‚îÄ‚îÄ
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('  GIGAMECH - OVERWORLD ALPHA');
console.log('  World size: 48x48');
console.log('  Sprites:', spriteManager.sprites.length);
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
showMessage('REACTOR ONLINE');
showMessage('WEAPONS ONLINE');
showMessage('ALL SYSTEMS NOMINAL');
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
